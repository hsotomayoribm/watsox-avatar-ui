{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { otperformance as performance } from '../platform';\nvar NANOSECOND_DIGITS = 9;\nvar NANOSECOND_DIGITS_IN_MILLIS = 6;\nvar MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);\nvar SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n/**\n * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).\n * @param epochMillis\n */\n\nexport function millisToHrTime(epochMillis) {\n  var epochSeconds = epochMillis / 1000; // Decimals only.\n\n  var seconds = Math.trunc(epochSeconds); // Round sub-nanosecond accuracy to nanosecond.\n\n  var nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);\n  return [seconds, nanos];\n}\nexport function getTimeOrigin() {\n  var timeOrigin = performance.timeOrigin;\n\n  if (typeof timeOrigin !== 'number') {\n    var perf = performance;\n    timeOrigin = perf.timing && perf.timing.fetchStart;\n  }\n\n  return timeOrigin;\n}\n/**\n * Returns an hrtime calculated via performance component.\n * @param performanceNow\n */\n\nexport function hrTime(performanceNow) {\n  var timeOrigin = millisToHrTime(getTimeOrigin());\n  var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : performance.now());\n  return addHrTimes(timeOrigin, now);\n}\n/**\n *\n * Converts a TimeInput to an HrTime, defaults to _hrtime().\n * @param time\n */\n\nexport function timeInputToHrTime(time) {\n  // process.hrtime\n  if (isTimeInputHrTime(time)) {\n    return time;\n  } else if (typeof time === 'number') {\n    // Must be a performance.now() if it's smaller than process start time.\n    if (time < getTimeOrigin()) {\n      return hrTime(time);\n    } else {\n      // epoch milliseconds or performance.timeOrigin\n      return millisToHrTime(time);\n    }\n  } else if (time instanceof Date) {\n    return millisToHrTime(time.getTime());\n  } else {\n    throw TypeError('Invalid input type');\n  }\n}\n/**\n * Returns a duration of two hrTime.\n * @param startTime\n * @param endTime\n */\n\nexport function hrTimeDuration(startTime, endTime) {\n  var seconds = endTime[0] - startTime[0];\n  var nanos = endTime[1] - startTime[1]; // overflow\n\n  if (nanos < 0) {\n    seconds -= 1; // negate\n\n    nanos += SECOND_TO_NANOSECONDS;\n  }\n\n  return [seconds, nanos];\n}\n/**\n * Convert hrTime to timestamp, for example \"2019-05-14T17:00:00.000123456Z\"\n * @param time\n */\n\nexport function hrTimeToTimeStamp(time) {\n  var precision = NANOSECOND_DIGITS;\n  var tmp = \"\" + '0'.repeat(precision) + time[1] + \"Z\";\n  var nanoString = tmp.substr(tmp.length - precision - 1);\n  var date = new Date(time[0] * 1000).toISOString();\n  return date.replace('000Z', nanoString);\n}\n/**\n * Convert hrTime to nanoseconds.\n * @param time\n */\n\nexport function hrTimeToNanoseconds(time) {\n  return time[0] * SECOND_TO_NANOSECONDS + time[1];\n}\n/**\n * Convert hrTime to milliseconds.\n * @param time\n */\n\nexport function hrTimeToMilliseconds(time) {\n  return Math.round(time[0] * 1e3 + time[1] / 1e6);\n}\n/**\n * Convert hrTime to microseconds.\n * @param time\n */\n\nexport function hrTimeToMicroseconds(time) {\n  return Math.round(time[0] * 1e6 + time[1] / 1e3);\n}\n/**\n * check if time is HrTime\n * @param value\n */\n\nexport function isTimeInputHrTime(value) {\n  return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';\n}\n/**\n * check if input value is a correct types.TimeInput\n * @param value\n */\n\nexport function isTimeInput(value) {\n  return isTimeInputHrTime(value) || typeof value === 'number' || value instanceof Date;\n}\n/**\n * Given 2 HrTime formatted times, return their sum as an HrTime.\n */\n\nexport function addHrTimes(time1, time2) {\n  var out = [time1[0] + time2[0], time1[1] + time2[1]]; // Nanoseconds\n\n  if (out[1] >= SECOND_TO_NANOSECONDS) {\n    out[1] -= SECOND_TO_NANOSECONDS;\n    out[0] += 1;\n  }\n\n  return out;\n} //# sourceMappingURL=time.js.map","map":null,"metadata":{},"sourceType":"module"}