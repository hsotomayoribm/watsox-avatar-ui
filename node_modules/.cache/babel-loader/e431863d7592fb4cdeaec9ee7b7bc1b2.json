{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport { ExportResultCode, hrTimeToMicroseconds } from '@opentelemetry/core';\n/**\n * This is implementation of {@link SpanExporter} that prints spans to the\n * console. This class can be used for diagnostic purposes.\n */\n\n/* eslint-disable no-console */\n\nvar ConsoleSpanExporter =\n/** @class */\nfunction () {\n  function ConsoleSpanExporter() {}\n  /**\n   * Export spans.\n   * @param spans\n   * @param resultCallback\n   */\n\n\n  ConsoleSpanExporter.prototype.export = function (spans, resultCallback) {\n    return this._sendSpans(spans, resultCallback);\n  };\n  /**\n   * Shutdown the exporter.\n   */\n\n\n  ConsoleSpanExporter.prototype.shutdown = function () {\n    this._sendSpans([]);\n\n    return Promise.resolve();\n  };\n  /**\n   * converts span info into more readable format\n   * @param span\n   */\n\n\n  ConsoleSpanExporter.prototype._exportInfo = function (span) {\n    var _a;\n\n    return {\n      traceId: span.spanContext().traceId,\n      parentId: span.parentSpanId,\n      traceState: (_a = span.spanContext().traceState) === null || _a === void 0 ? void 0 : _a.serialize(),\n      name: span.name,\n      id: span.spanContext().spanId,\n      kind: span.kind,\n      timestamp: hrTimeToMicroseconds(span.startTime),\n      duration: hrTimeToMicroseconds(span.duration),\n      attributes: span.attributes,\n      status: span.status,\n      events: span.events,\n      links: span.links\n    };\n  };\n  /**\n   * Showing spans in console\n   * @param spans\n   * @param done\n   */\n\n\n  ConsoleSpanExporter.prototype._sendSpans = function (spans, done) {\n    var e_1, _a;\n\n    try {\n      for (var spans_1 = __values(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {\n        var span = spans_1_1.value;\n        console.dir(this._exportInfo(span), {\n          depth: 3\n        });\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (spans_1_1 && !spans_1_1.done && (_a = spans_1.return)) _a.call(spans_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (done) {\n      return done({\n        code: ExportResultCode.SUCCESS\n      });\n    }\n  };\n\n  return ConsoleSpanExporter;\n}();\n\nexport { ConsoleSpanExporter }; //# sourceMappingURL=ConsoleSpanExporter.js.map","map":null,"metadata":{},"sourceType":"module"}