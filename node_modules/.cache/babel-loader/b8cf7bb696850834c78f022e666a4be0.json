{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport { baggageEntryMetadataFromString } from '@opentelemetry/api';\nimport { BAGGAGE_ITEMS_SEPARATOR, BAGGAGE_PROPERTIES_SEPARATOR, BAGGAGE_KEY_PAIR_SEPARATOR, BAGGAGE_MAX_TOTAL_LENGTH } from './constants';\nexport function serializeKeyPairs(keyPairs) {\n  return keyPairs.reduce(function (hValue, current) {\n    var value = \"\" + hValue + (hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : '') + current;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, '');\n}\nexport function getKeyPairs(baggage) {\n  return baggage.getAllEntries().map(function (_a) {\n    var _b = __read(_a, 2),\n        key = _b[0],\n        value = _b[1];\n\n    var entry = encodeURIComponent(key) + \"=\" + encodeURIComponent(value.value); // include opaque metadata if provided\n    // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation\n\n    if (value.metadata !== undefined) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n\n    return entry;\n  });\n}\nexport function parsePairKeyValue(entry) {\n  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);\n  if (valueProps.length <= 0) return;\n  var keyPairPart = valueProps.shift();\n  if (!keyPairPart) return;\n  var keyPair = keyPairPart.split(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (keyPair.length !== 2) return;\n  var key = decodeURIComponent(keyPair[0].trim());\n  var value = decodeURIComponent(keyPair[1].trim());\n  var metadata;\n\n  if (valueProps.length > 0) {\n    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));\n  }\n\n  return {\n    key: key,\n    value: value,\n    metadata: metadata\n  };\n}\n/**\n * Parse a string serialized in the baggage HTTP Format (without metadata):\n * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md\n */\n\nexport function parseKeyPairsIntoRecord(value) {\n  if (typeof value !== 'string' || value.length === 0) return {};\n  return value.split(BAGGAGE_ITEMS_SEPARATOR).map(function (entry) {\n    return parsePairKeyValue(entry);\n  }).filter(function (keyPair) {\n    return keyPair !== undefined && keyPair.value.length > 0;\n  }).reduce(function (headers, keyPair) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    headers[keyPair.key] = keyPair.value;\n    return headers;\n  }, {});\n} //# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module"}