{"ast":null,"code":"/**\n * @module smwebsdk\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\n/*\n * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.\n */\n\nimport { Persona } from './Persona';\nimport { SmEvent } from './SmEvent';\nimport { LocalSession } from './LocalSession';\nimport { Session } from './Session';\nimport { WebSocketSession } from './WebSocketSession';\nimport { WebsocketCategory, WebsocketKind } from './websocket-message/index';\nimport { SpeechState } from './websocket-message/enums/SpeechState';\nimport { SceneResponseError } from './websocket-message/scene/index';\nimport { FeatureFlag } from './websocket-message/scene/response-body/StateResponseBody';\nimport { ContentAwareness } from './ContentAwareness';\nimport { Logger } from './utils/Logger';\nimport { ROOT_CONTEXT } from '@opentelemetry/api';\nimport { makeError } from './utils/make-error';\nimport convertToUserMedia from './utils/convertToUserMedia';\nimport { convertWssToHttps, getUrlHost } from './utils/utils';\nimport { UserMedia } from './types/scene';\nimport { Conversation } from './Conversation';\nimport { MetadataSender } from './MetadataSender';\nimport { ConnectionState } from './ConnectionState';\nimport { SmTracerProvider } from './SmTelemetry';\nimport { websdkVersion } from './env-vars';\n\nfunction sleep(t) {\n  return new Promise(function (resolve) {\n    return setTimeout(function () {\n      return resolve();\n    }, t);\n  });\n}\n\nvar DEFAULT_RETRY_COUNT = 50;\nvar DEFAULT_RETRY_DELAY = 200;\nvar DEFAULT_PERSONA_ID = 1;\n\nfunction retry(task, retryOptions, scene) {\n  if (retryOptions === void 0) {\n    retryOptions = {};\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var errors, count, delay, result, i, error_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          errors = [];\n          count = retryOptions.maxRetries || DEFAULT_RETRY_COUNT;\n          delay = retryOptions.delayMs || DEFAULT_RETRY_DELAY;\n          i = 0;\n          _a.label = 1;\n\n        case 1:\n          if (!(i < count)) return [3\n          /*break*/\n          , 8];\n          _a.label = 2;\n\n        case 2:\n          _a.trys.push([2, 4,, 6]);\n\n          return [4\n          /*yield*/\n          , task()];\n\n        case 3:\n          result = _a.sent(); // store the result on the scene object\n\n          scene.connectionResult = {\n            message: 'success',\n            value: result,\n            retries: errors\n          };\n          return [3\n          /*break*/\n          , 6];\n\n        case 4:\n          error_1 = _a.sent(); // collect a history of errors encountered during connect\n\n          errors.push(error_1); // store the result on the scene object\n\n          scene.connectionResult = {\n            message: 'failed',\n            retries: errors\n          }; //if error is 'noResumeSession` should cleanup session storage\n\n          if (error_1 instanceof Error && error_1.name === 'noSessionToResume') {\n            clearSessionData();\n          } // any error other than 'noScene' should throw immediately\n          // and should not retry repeatedly.\n          // allows for proper errors and also string errors\n\n\n          if (!(error_1 instanceof Error) || error_1.name !== 'noScene') {\n            throw error_1;\n          } // when we have reached the max number of retries,\n          // we should give up and throw the error\n\n\n          if (errors.length === count) {\n            console.warn(\"Retry gave up after \".concat(count, \" retries:\\n\").concat(errors.map(function (e) {\n              return e instanceof Error ? e.message : e.toString();\n            }).join('\\n'))); // throw the most recent error as the primary cause of failure\n\n            throw error_1;\n          }\n\n          return [4\n          /*yield*/\n          , sleep(delay)];\n\n        case 5:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 7];\n\n        case 6:\n          return [3\n          /*break*/\n          , 8];\n\n        case 7:\n          i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 8:\n          return [2\n          /*return*/\n          , result];\n      }\n    });\n  });\n}\n\nfunction storeSessionData(server, sessionId, apiKey) {\n  sessionStorage.setItem('sm-server', server);\n  sessionStorage.setItem('sm-session-id', sessionId);\n  sessionStorage.setItem('sm-api-key', apiKey);\n}\n\nfunction getSessionData() {\n  return {\n    server: sessionStorage.getItem('sm-server'),\n    resumeSessionId: sessionStorage.getItem('sm-session-id'),\n    savedApiKey: sessionStorage.getItem('sm-api-key')\n  };\n}\n\nfunction clearSessionData() {\n  sessionStorage.removeItem('sm-server');\n  sessionStorage.removeItem('sm-session-id');\n  sessionStorage.removeItem('sm-api-key');\n}\n/**\n * Scene class to hold a webrtc connection to a scene containing a persona.\n * @public\n */\n\n\nvar Scene =\n/** @class */\nfunction () {\n  function Scene(videoOrOptions, audioOnly, requestedUserMedia, requiredUserMedia, contentAwarenessDebounceTime, loggingConfig, tracerOptions) {\n    if (audioOnly === void 0) {\n      audioOnly = false;\n    }\n\n    if (requestedUserMedia === void 0) {\n      requestedUserMedia = UserMedia.MicrophoneAndCamera;\n    }\n\n    if (requiredUserMedia === void 0) {\n      requiredUserMedia = UserMedia.Microphone;\n    }\n\n    var _this = this;\n\n    this._onConversationResultEvents = {}; // persona id -> SmEvent with function(persona, result)\n\n    this._onSpeechMarkerEvents = {}; // persona id -> SmEvent function(persona, marker)\n\n    this._session = undefined;\n    this._isWebSocketOnly = false;\n    this._transactionId = 0;\n    this._pendingResponses = {};\n    this._microphoneUnmuteTimer = undefined;\n    this._echoCancellationEnabled = true;\n    this._serverControlledCameras = false;\n    this._stopSpeakingWhenNotVisible = true;\n    this._loggingConfig = {\n      session: {},\n      contentAwareness: {}\n    };\n    this._logger = new Logger();\n    this._tracerOptions = {\n      disableTracing: false,\n      parentCtx: ROOT_CONTEXT,\n      url: SmTracerProvider.defaultUrl\n    };\n    this._sessionResumeEnabled = false;\n    this._isResumedSession = false;\n    this._sendMetadata = {\n      pageUrl: false\n    };\n    this._onMicrophoneActive = new SmEvent();\n    this._onCameraActive = new SmEvent();\n    this.currentPersonaId = DEFAULT_PERSONA_ID;\n    /** Returns the version of the webSdk and platformSdk */\n\n    this.version = {\n      webSdk: websdkVersion,\n      platformSdk: 'unknown'\n    };\n\n    this.iosVisibilityChange = function () {\n      var visible = document.visibilityState === 'visible';\n      setTimeout(function () {\n        if (_this._session) {\n          _this._session.sendRtcEvent('ui', {\n            visible: visible\n          });\n        }\n      }, 500); // allow 100ms for the H.264 decoder to become fully available again\n    };\n\n    this.stopSpeakingWhenNotVisible = function () {\n      if (document.visibilityState !== 'visible') {\n        _this.sendRequest('stopSpeaking', {\n          personaId: _this.currentPersonaId\n        });\n      }\n    };\n\n    this.stopSpeakingWhenUnloaded = function () {\n      _this.sendRequest('stopSpeaking', {\n        personaId: _this.currentPersonaId\n      });\n    }; // use the first parameter of the constructor to figure out\n    // whether it was constructed using SceneOptions, or using\n    // the deprecated multi-param format.\n\n\n    if (this.isSceneOptions(videoOrOptions)) {\n      // pull all private property initial values from the config object,\n      // with fallbacks to the constructor property defaults if not provided\n      var options = videoOrOptions;\n      this._videoElement = options.videoElement;\n      this._apiKey = options.apiKey;\n      this._audioOnly = options.audioOnly || audioOnly; // default is \"true\" so can't use a shorthand falsy assessment to read this config option\n\n      if (options.stopSpeakingWhenNotVisible === false) {\n        this._stopSpeakingWhenNotVisible = false;\n      }\n\n      this._requestedUserMedia = convertToUserMedia(options.requestedMediaDevices, requestedUserMedia);\n      this._requiredUserMedia = convertToUserMedia(options.requiredMediaDevices, requiredUserMedia);\n      this.contentAwarenessDebounceTime = options.contentAwarenessDebounceTime;\n      this._loggingConfig = __assign(__assign({}, this._loggingConfig), options.loggingConfig || {});\n\n      if (options.sendMetadata) {\n        this._sendMetadata = options.sendMetadata;\n      }\n\n      if (options.tracerOptions) {\n        this._tracerOptions = options.tracerOptions;\n      }\n    } else {\n      // take all private property initial values directly from the constructor props\n      this._videoElement = videoOrOptions;\n      this._audioOnly = audioOnly;\n      this._requestedUserMedia = requestedUserMedia;\n      this._requiredUserMedia = requiredUserMedia;\n      this.contentAwarenessDebounceTime = contentAwarenessDebounceTime;\n      this._loggingConfig = __assign(__assign({}, this._loggingConfig), loggingConfig);\n\n      if (tracerOptions) {\n        this._tracerOptions = tracerOptions;\n      }\n    }\n\n    this._logger = new Logger(this._loggingConfig.session.minLogLevel, this._loggingConfig.session.enabled);\n    /**\n     * call onStateEvent.addListener(function(scene, state)) to be called when a state message is received as per the scene protocol\n     * call onStateEvent.removeListener(function(scene, state)) to deregister a listener.\n     */\n\n    this._onStateEvent = new SmEvent();\n\n    this._onStateEvent.addListener(function (scene, state) {\n      if (_this._onState) {\n        _this._onState(scene, state);\n      }\n    });\n    /**\n     * call onRecognizeResultsEvent.addListener(function(scene, status, errorMessage, results)) to be called when speech to text results are recognized, results are documented in scene protocol.\n     * call onRecognizeResultsEvent.removeListener(function(scene, status, errorMessage, results)) to deregister a listener.\n     */\n\n\n    this._onRecognizeResultsEvent = new SmEvent();\n\n    this._onRecognizeResultsEvent.addListener(function (scene, status, errorMessage, results) {\n      if (_this._onRecognizeResults) {\n        _this._onRecognizeResults(scene, status, errorMessage, results);\n      }\n    });\n    /**\n     * call onDisconnectedEvent.addListener(function(scene, sessionId, reason)) to be  called when the session is disconnected.\n     * call onDisconnectedEvent.removeListener(function(scene, sessionId, reason)) to deregister a listener.\n     */\n\n\n    this._onDisconnectedEvent = new SmEvent();\n\n    this._onDisconnectedEvent.addListener(function (scene, sessionId, reason) {\n      clearSessionData();\n\n      _this.cleanupEventListeners();\n\n      if (_this._onDisconnected) {\n        _this._onDisconnected(scene, sessionId, reason);\n      }\n    });\n    /**\n     * call onUserTextEvent.addListener(function(scene, text)) to be called when a custom text message is sent from the orchestration server\n     * call onUserTextEvent.removeListener(function(scene, text)) to deregister a listener.\n     */\n\n\n    this._onUserTextEvent = new SmEvent();\n\n    this._onUserTextEvent.addListener(function (scene, text) {\n      if (_this._onUserText) {\n        _this._onUserText(scene, text);\n      }\n    });\n\n    this._onDemoModeEvent = new SmEvent();\n    this._underRuntimeHost = Boolean(window.SmIsUnderRuntimeHost); // Generate a random id for the scene. This is used internally with the _transactionId\n    // to ensure unique transaction ids when mulitple Scene instances access the same BL instances\n    // eg multiple Soul Studio windows\n\n    var randArray = new Uint32Array(3);\n    window.crypto.getRandomValues(randArray);\n    this._sceneId = randArray.toString().replace(/,/g, '-');\n    this.conversation = new Conversation();\n    this.connectionState = new ConnectionState();\n    this._metadataSender = new MetadataSender(this);\n\n    this._logger.log('debug', 'websdk version:', this.version.webSdk);\n  }\n  /**\n   * Tests the first value of the Scene construtor to decide if\n   * it matches the new-style config options format.\n   */\n\n\n  Scene.prototype.isSceneOptions = function (videoOrOptions) {\n    // scene options must be defined, even if they're an empty object\n    var isDefined = !!videoOrOptions; // scene options object will not have a tagName\n\n    var isHTMLElement = !!(videoOrOptions === null || videoOrOptions === void 0 ? void 0 : videoOrOptions.tagName);\n    return isDefined && !isHTMLElement;\n  };\n\n  Scene.prototype.connectionValid = function () {\n    if (this._underRuntimeHost) {\n      return true;\n    }\n\n    if (this._session && this._session.serverConnection) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Check if the scene connection is open and valid.\n   *\n   * @returns Returns true if the connection is open and valid otherwise false.\n   */\n\n\n  Scene.prototype.isConnected = function () {\n    if (this.connectionValid() && this._session && this._session.serverConnection && this._session.serverConnection.readyState === this._session.serverConnection.OPEN) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Extends the server side timeout. This also happens automatically whenever the persona speaks.\n   */\n\n\n  Scene.prototype.keepAlive = function () {\n    if (this._session && this._session.peerConnection !== null) {\n      this._session.sendRtcEvent('keepAlive', {});\n    }\n  };\n  /**\n   * Disconnects the session\n   */\n\n\n  Scene.prototype.disconnect = function () {\n    var _a, _b;\n\n    clearSessionData();\n    this.cleanupEventListeners();\n    this.connectionState.reset();\n    this.conversation.reset();\n    (_a = this.contentAwareness) === null || _a === void 0 ? void 0 : _a.disconnect();\n\n    this._metadataSender.disconnect();\n\n    (_b = this._session) === null || _b === void 0 ? void 0 : _b.close(true);\n    this._session = undefined;\n  };\n\n  Scene.prototype.connect = function (serverUriOrOptions, userText, accessToken, retryOptions) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var connectStartTime, config, span, recordEventsToSpan, hasPassedInTokenServerAuth, response, data, server, error_2, _d, initTracerStartTime, initTracerEndTime;\n\n      var _this = this;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            connectStartTime = Date.now();\n            config = this.connectArgsToConfig(serverUriOrOptions, userText, accessToken, retryOptions);\n\n            recordEventsToSpan = function (event) {\n              span === null || span === void 0 ? void 0 : span.addEvent(event.name);\n            };\n\n            this.connectionState.onConnectionStateUpdated.addListener(recordEventsToSpan);\n            if (!this._underRuntimeHost) return [3\n            /*break*/\n            , 1];\n            this._session = new LocalSession(this._videoElement, this._logger);\n            return [3\n            /*break*/\n            , 8];\n\n          case 1:\n            hasPassedInTokenServerAuth = config.tokenServerUri || config.tokenServerAccessToken;\n\n            if (this._apiKey && hasPassedInTokenServerAuth) {\n              this._logger.log('warn', 'You are trying to connect via an API key and a token server. Please use one or the other');\n            }\n\n            if (!(this._apiKey && !hasPassedInTokenServerAuth)) return [3\n            /*break*/\n            , 6];\n            _e.label = 2;\n\n          case 2:\n            _e.trys.push([2, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.fetchAuthConfig(this._apiKey)];\n\n          case 3:\n            response = _e.sent();\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 4:\n            data = _e.sent();\n            server = getSessionData().server;\n            config.tokenServerUri = data.url;\n            config.tokenServerAccessToken = data.jwt;\n\n            if (server) {\n              config.tokenServerUri = getUrlHost(data.url) + 'server/' + server;\n            }\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            error_2 = _e.sent();\n\n            if (error_2 instanceof Error && error_2.message === 'Broken API key') {\n              this._logger.log('error', 'Broken API key. Please check your key or re copy the key from DDNA Studio.');\n            } else {\n              this._logger.log('error', 'Invalid API key: Please check your key configuration in DDNA Studio. For more information click here https://soulmachines-support.atlassian.net/wiki/spaces/SSAS/pages/1320058919/Connecting+Using+API+Keys#Troubleshooting');\n            }\n\n            throw makeError('Invalid API key', 'serverConnectionFailed');\n\n          case 6:\n            if (!config.tokenServerUri || !config.tokenServerAccessToken) {\n              throw makeError('Please authenticate via an API key or with a serverUri and accessToken', 'serverConnectionFailed');\n            }\n\n            return [4\n            /*yield*/\n            , this.initializeTracer(config.tokenServerUri, config.tokenServerAccessToken)];\n\n          case 7:\n            _d = _e.sent(), initTracerStartTime = _d.initTracerStartTime, initTracerEndTime = _d.initTracerEndTime;\n            span = (_c = (_b = (_a = SmTracerProvider.getTracer()) === null || _a === void 0 ? void 0 : _a.startSpan('createSessionAndConnect')) === null || _b === void 0 ? void 0 : _b.setAttribute('sm.websdk.connection.pretraceinitduration.milliseconds', initTracerStartTime - connectStartTime)) === null || _c === void 0 ? void 0 : _c.setAttribute('sm.websdk.connection.traceinitduration.milliseconds', initTracerEndTime - initTracerStartTime);\n\n            if (this._isWebSocketOnly) {\n              this._session = new WebSocketSession(config.tokenServerUri, config.tokenServerAccessToken, this._logger);\n            } else {\n              this._session = new Session(this._videoElement, config.tokenServerUri, config.userText, config.tokenServerAccessToken, this._audioOnly, this._requestedUserMedia, this._requiredUserMedia, this._echoCancellationEnabled, this._logger, this.connectionState);\n            }\n\n            _e.label = 8;\n\n          case 8:\n            if (!this._session) {\n              throw makeError('Failed to create session', 'unknown');\n            }\n\n            this._session.onConnected = this.sessionConnected.bind(this);\n            this._session.onMessage = this.onMessage.bind(this);\n            this._session.onClose = this.sessionClosed.bind(this);\n            this._session.onUserText = this.rtcUserText.bind(this);\n\n            if ('microphoneActiveCallbacks' in this._session) {\n              this._session.microphoneActiveCallbacks = this._onMicrophoneActive;\n            }\n\n            if ('cameraActiveCallbacks' in this._session) {\n              this._session.cameraActiveCallbacks = this._onCameraActive;\n            }\n\n            if (this._session.features.isIos) {\n              document.addEventListener('visibilitychange', this.iosVisibilityChange);\n            }\n\n            return [4\n            /*yield*/\n            , retry(function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , this._session.connect()];\n\n                    case 1:\n                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                      return [2\n                      /*return*/\n                      , _a.sent()];\n                  }\n                });\n              });\n            }, config.retryOptions, this).finally(function () {\n              _this.connectionState.onConnectionStateUpdated.removeListener(recordEventsToSpan);\n\n              span === null || span === void 0 ? void 0 : span.end();\n            })];\n\n          case 9:\n            return [2\n            /*return*/\n            , _e.sent()];\n        }\n      });\n    });\n  };\n\n  Scene.prototype.initializeTracer = function (tokenServerUri, tokenServerAccessToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      var initTracerStartTime, error_3, base;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            initTracerStartTime = Date.now();\n            if (!(!this._tracerOptions.disableTracing && !SmTracerProvider.isInitialized())) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.initTelemetryToken({\n              tokenServerUri: tokenServerUri,\n              authToken: tokenServerAccessToken\n            })];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            error_3 = _a.sent();\n            base = 'Could not initialize tracer telemetry token: ';\n\n            if (error_3 instanceof ReferenceError && error_3.message === 'fetch is not defined') {\n              // This happens in a non-browser environment (usually a test\n              // environment), so we can't get a telemetry token. Just log to\n              // debug.\n              this._logger.log('debug', base + error_3.name + ': ' + error_3.message);\n            } else if (error_3 instanceof Error) {\n              this._logger.log('warn', base + error_3.name + ': ' + error_3.message);\n            } else {\n              this._logger.log('warn', base + 'unknown error type');\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            , {\n              initTracerStartTime: initTracerStartTime,\n              initTracerEndTime: Date.now()\n            }];\n        }\n      });\n    });\n  };\n\n  Scene.prototype.initTelemetryToken = function (_a) {\n    var tokenServerUri = _a.tokenServerUri,\n        authToken = _a.authToken;\n    return __awaiter(this, void 0, void 0, function () {\n      var otelJwtEndpoint, tracesEndpoint, telemetryHost, resp, otelResponse;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            otelJwtEndpoint = 'api/telemetry/jwt';\n            tracesEndpoint = 'api/telemetry/v1/traces';\n            telemetryHost = getUrlHost(convertWssToHttps(tokenServerUri));\n\n            if (!telemetryHost) {\n              this._logger.log('debug', 'Could not initialize tracer telemetry token: invalid token server URI');\n\n              return [2\n              /*return*/\n              ];\n            }\n\n            return [4\n            /*yield*/\n            , fetch(telemetryHost + otelJwtEndpoint, {\n              headers: {\n                Authorization: 'Bearer ' + authToken\n              }\n            })];\n\n          case 1:\n            resp = _b.sent();\n\n            if (!resp) {\n              this._logger.log('warn', 'Failed to receive response from otel token endpoint');\n\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (!resp.ok) {\n              this._logger.log('warn', 'Failed to fetch otel token: ' + resp.status + ': ' + resp.statusText);\n\n              return [2\n              /*return*/\n              ];\n            }\n\n            return [4\n            /*yield*/\n            , resp.json()];\n\n          case 2:\n            otelResponse = _b.sent();\n\n            if (!otelResponse.success) {\n              this._logger.log('warn', 'Failed: otel response not successful');\n\n              return [2\n              /*return*/\n              ];\n            }\n\n            try {\n              SmTracerProvider.init({\n                jwt: otelResponse.telemetryJwt,\n                url: telemetryHost + tracesEndpoint,\n                webSDKVersion: this.version.webSdk\n              });\n\n              this._logger.log('log', 'Telemetry initialized');\n            } catch (error) {\n              if (error instanceof Error) {\n                this._logger.log('warn', 'Failed to initialize tracer: ' + error.message);\n              } else {\n                this._logger.log('warn', 'Failed to initialize tracer: unknown error');\n              }\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Scene.prototype.onMessage = function (message) {\n    var category = message.category;\n\n    if (category === 'scene') {\n      var sceneMessage = message;\n      this.onSceneMessage(sceneMessage);\n      return;\n    }\n  };\n\n  Scene.prototype.sendOnewaySceneRequest = function (name, body) {\n    if (!this._session) {\n      return;\n    }\n\n    var payload = {\n      name: name,\n      body: body,\n      category: WebsocketCategory.Scene,\n      kind: WebsocketKind.Request\n    };\n\n    this._session.sendMessage(payload);\n  };\n  /**\n   * The internal method used for sending request messages.\n   *\n   * All offically supported message have their own public methods (e.g. `conversationSend()` or `scene.startRecognize()`). \\\n   * Please use those instead.\n   *\n   * @internal\n   */\n\n\n  Scene.prototype.sendRequest = function (name, body) {\n    var _this = this;\n\n    if (body === void 0) {\n      body = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      if (!_this._session) {\n        reject(makeError('No session available', 'noSession'));\n        return;\n      }\n\n      var transaction = _this._sceneId + '_' + ++_this._transactionId;\n      var payload = {\n        transaction: transaction,\n        name: name,\n        body: body,\n        category: WebsocketCategory.Scene,\n        kind: WebsocketKind.Request\n      };\n      var pending = {\n        resolve: resolve,\n        reject: reject\n      };\n      _this._pendingResponses[transaction] = pending;\n\n      if (_this._session) {\n        _this._session.sendMessage(payload);\n      }\n    });\n  };\n\n  Scene.prototype.onSceneMessage = function (message) {\n    var _a, _b, _c;\n\n    var name = message.name,\n        body = message.body,\n        kind = message.kind,\n        status = message.status,\n        transaction = message.transaction; // Process events\n\n    if (body && name === 'state') {\n      var responseBody = body;\n\n      this._onStateEvent.call(this, responseBody);\n\n      if ((_a = responseBody.scene) === null || _a === void 0 ? void 0 : _a.featureFlags) {\n        this.enableFlaggedFeatures(responseBody.scene.featureFlags);\n      }\n\n      if ((_b = responseBody.scene) === null || _b === void 0 ? void 0 : _b.sdkVersion) {\n        this.version.platformSdk = (_c = responseBody.scene) === null || _c === void 0 ? void 0 : _c.sdkVersion;\n\n        this._logger.log('debug', 'platformSdk version:', this.version.platformSdk);\n      }\n\n      this.conversation.processStateMessage(responseBody); // mute the microphone while a persona is speaking\n\n      this.controlMicrophoneMute(body);\n    } else if (body && name === 'recognizeResults') {\n      var _d = body,\n          status_1 = _d.status,\n          errorMessage = _d.errorMessage,\n          results = _d.results;\n      this.conversation.processRecognizeResultsMessage(body);\n\n      this._onRecognizeResultsEvent.call(this, status_1, errorMessage, results);\n    } else if (body && name === 'conversationResult') {\n      this.conversation.onConversationResult(body);\n      var personaId = body.personaId;\n\n      if (personaId) {\n        var persona = new Persona(this, personaId);\n        var event_1 = this._onConversationResultEvents[personaId];\n        event_1.call(persona, body);\n        this.currentPersonaId = personaId;\n      }\n    } else if (body && name === 'speechMarker') {\n      this.conversation.onSpeechMarker(body);\n      var personaId = body.personaId;\n\n      if (personaId) {\n        var persona = new Persona(this, personaId);\n        var event_2 = this._onSpeechMarkerEvents[personaId];\n        event_2.call(persona, body);\n        this.currentPersonaId = personaId;\n      }\n    } else if (body && name === 'demoMode') {\n      this._onDemoModeEvent.call(this, body);\n    } // Process responses, message should always be a response as far as we're aware\n\n\n    if (kind === WebsocketKind.Response && transaction) {\n      this.processResponse(body, name, status, transaction);\n    }\n  };\n\n  Scene.prototype.processResponse = function (body, name, status, transaction) {\n    // Check for a pending response\n    var pending = this._pendingResponses[transaction];\n\n    if (pending) {\n      if (status === 0) {\n        // Success\n        pending.resolve(body);\n      } else {\n        // Failure\n        var error = new SceneResponseError();\n        error.requestName = name;\n        error.status = status;\n        error.responseBody = body;\n        pending.reject(error);\n      }\n\n      delete this._pendingResponses[transaction];\n    }\n  };\n\n  Scene.prototype.controlMicrophoneMute = function (state) {\n    var _this = this; // Watch for speaking state transitions and mute the\n    // microphone during persona speech to prevent self interruption\n\n\n    if (state.persona && this._session && this._session.microphoneMuteDelay !== -1) {\n      // iterate through the personas looking for speaking state changes\n      for (var personaId in state.persona) {\n        var persona_state = state.persona[personaId];\n\n        if (!persona_state.speechState) {\n          continue;\n        }\n\n        if (persona_state.speechState === SpeechState.Speaking) {\n          // A persona is speaking, mute the microphone\n          if (!this._session.microphoneMuted) {\n            this._logger.log('warn', 'Persona is speaking - mute microphone');\n\n            this._session.microphoneMuted = true;\n          }\n\n          if (this._microphoneUnmuteTimer) {\n            // ensure an in-progress timeout doesn't incorrectly unmute\n            clearTimeout(this._microphoneUnmuteTimer);\n            this._microphoneUnmuteTimer = undefined;\n          }\n        } else {\n          // A persona has stopped speaking, unmute the microphone after\n          // the microphone mute delay\n          if (this._session.microphoneMuted && !this._microphoneUnmuteTimer) {\n            this._microphoneUnmuteTimer = setTimeout(function () {\n              if (!_this._session || !_this._microphoneUnmuteTimer) {\n                return;\n              }\n\n              _this._logger.log(\"warn\", 'Persona is no longer speaking - unmute microphone');\n\n              _this._session.microphoneMuted = false;\n              _this._microphoneUnmuteTimer = undefined;\n            }, this._session.microphoneMuteDelay);\n          }\n        }\n      }\n    }\n  };\n  /** Close the current scene connection */\n\n\n  Scene.prototype.close = function () {\n    // close/disconnect the session\n    if (this._session) {\n      this._session.close(true);\n    }\n  };\n\n  Scene.prototype.sessionConnected = function (resumeRequested, isResumedSession, server, sessionId) {\n    this.contentAwareness = new ContentAwareness(this, this.contentAwarenessDebounceTime, new Logger(this._loggingConfig.contentAwareness.minLogLevel, this._loggingConfig.contentAwareness.enabled));\n    /*\n    Interrupt DP from speaking so it does not continue talking when user switches tabs\n    */\n\n    if (this._stopSpeakingWhenNotVisible) {\n      document.addEventListener('visibilitychange', this.stopSpeakingWhenNotVisible);\n    } //when user navigates to a new page, widget DP should stop speaking to allow new welcome message coming through in the new page\n    //however browser doesn't trigger visibilitychange event, only \"beforeunload\" event is sure to be triggered\n\n\n    window.addEventListener('beforeunload', this.stopSpeakingWhenUnloaded);\n\n    if (this._sendMetadata.pageUrl) {\n      this._metadataSender.observeUrlChanges();\n    } //update resume session data\n\n\n    this._isResumedSession = isResumedSession;\n\n    if (resumeRequested) {\n      this._sessionResumeEnabled = true;\n      storeSessionData(server, sessionId, this._apiKey || '');\n    } // When page navigation happens, check if any value in _sendMetadata is true and send it back to NLP so conversation writers can use it\n\n\n    if (isResumedSession && this._sendMetadata.pageUrl) {\n      this._metadataSender.send();\n    }\n  };\n\n  Scene.prototype.cleanupEventListeners = function () {\n    var _a;\n\n    if ((_a = this._session) === null || _a === void 0 ? void 0 : _a.features.isIos) {\n      document.removeEventListener('visibilitychange', this.iosVisibilityChange);\n    }\n\n    if (this._stopSpeakingWhenNotVisible) {\n      document.removeEventListener('visibilitychange', this.stopSpeakingWhenNotVisible);\n    }\n\n    window.removeEventListener('beforeunload', this.stopSpeakingWhenUnloaded);\n  };\n\n  Scene.prototype.sessionClosed = function (reason) {\n    clearSessionData();\n    this.cleanupEventListeners();\n\n    if (this._session) {\n      this.connectionState.reset();\n      this.conversation.reset();\n\n      this._onDisconnectedEvent.call(this, this._session.sessionId, reason);\n    }\n  };\n\n  Scene.prototype.rtcUserText = function (text) {\n    this._onUserTextEvent.call(this, text);\n  };\n\n  Scene.prototype.enableFlaggedFeatures = function (featureFlags) {\n    this._serverControlledCameras = featureFlags.includes(FeatureFlag.UI_SDK_CAMERA_CONTROL);\n  };\n\n  Scene.prototype.sendContent = function () {\n    var _a;\n\n    if (!this.contentAwareness) {\n      console.warn('ContentAwareness is not enabled for this project');\n    }\n\n    (_a = this.contentAwareness) === null || _a === void 0 ? void 0 : _a.measure();\n  };\n  /**\n   * Sends updated video element size to server\n   * this gives the app the chance to choose what size should be rendered on server\n   * and the application is responsible to register for a video element size change\n   * event and call this method to maintain best possible video quality for the size\n   * and/or to set an updated video element size and then call this method.\n   * @param width - The width in pixels to render the video\n   * @param height - The height in pixels to render the video\n   */\n\n\n  Scene.prototype.sendVideoBounds = function (width, height) {\n    if (this._session) {\n      this._session.sendVideoBounds(width, height);\n    }\n  };\n  /**\n   * Send configuration to the scene\n   * @param configuration - Scene configuration as per the scene protocol\n   */\n\n\n  Scene.prototype.configure = function (configuration) {\n    return this.sendRequest('configure', configuration);\n  };\n  /**\n   * Send a custom user text message to the orchestration server\n   * @param text - Custom text sent to the orchestration server\n   */\n\n\n  Scene.prototype.sendUserText = function (text) {\n    if (this._session) {\n      this._session.sendUserText(text);\n    }\n  };\n  /**\n   * Start the speech to text recognizer\n   * @param audioSource - The audio source either smwebsdk.audioSource.processed or\n   *                    smwebsdk.audioSource.squelched, defaults to processed.\n   */\n\n\n  Scene.prototype.startRecognize = function (audioSource) {\n    var body = {};\n\n    if (audioSource !== undefined) {\n      body.audioSource = audioSource;\n    }\n\n    return this.sendRequest('startRecognize', body);\n  };\n  /** Stop the speech to text reconizer */\n\n\n  Scene.prototype.stopRecognize = function () {\n    return this.sendRequest('stopRecognize');\n  };\n  /** Is the microphone connected in the session */\n\n\n  Scene.prototype.isMicrophoneConnected = function () {\n    // public function rather than getter for back compatibility\n    if (this._session) {\n      return this._session.isMicrophoneConnected;\n    }\n\n    return false;\n  };\n  /** Is the camera connected in the session */\n\n\n  Scene.prototype.isCameraConnected = function () {\n    // public function rather than getter for back compatibility\n    if (this._session) {\n      return this._session.isCameraConnected;\n    }\n\n    return false;\n  };\n\n  Scene.prototype.session = function () {\n    // public function rather than getter for back compatibility\n    return this._session;\n  };\n\n  Scene.prototype.hasContentAwareness = function () {\n    return !!this.contentAwareness;\n  };\n\n  Scene.prototype.hasServerControlledCameras = function () {\n    return this._serverControlledCameras;\n  };\n  /**\n   * Check if session persistence feature is supported in current session\n   *\n   * @returns `boolean`\n   *\n   * Usage:\n   * ```javascript\n   * const isSessionPersistenceSupported = scene.supportsSessionPersistence();\n   * ```\n   */\n\n\n  Scene.prototype.supportsSessionPersistence = function () {\n    return this._sessionResumeEnabled;\n  };\n  /**\n   * Check if current session is a new session or a resumed session\n   *\n   * @returns `boolean`\n   *\n   * Usage:\n   * ```javascript\n   * const isResumedSession = scene.isResumedSession();\n   * ```\n   */\n\n\n  Scene.prototype.isResumedSession = function () {\n    return this._isResumedSession;\n  };\n\n  Object.defineProperty(Scene.prototype, \"onConversationResultEvents\", {\n    get: function () {\n      return this._onConversationResultEvents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onSpeechMarkerEvents\", {\n    get: function () {\n      return this._onSpeechMarkerEvents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Get the current scene state */\n\n  Scene.prototype.getState = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.sendRequest('getState')];\n      });\n    });\n  };\n\n  Object.defineProperty(Scene.prototype, \"onStateEvent\", {\n    get: function () {\n      return this._onStateEvent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onState\", {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    set: function (onState) {\n      this._onState = onState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onDisconnectedEvent\", {\n    get: function () {\n      return this._onDisconnectedEvent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onDisconnected\", {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    set: function (onDisconnected) {\n      this._onDisconnected = onDisconnected;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onRecognizeResultsEvent\", {\n    get: function () {\n      return this._onRecognizeResultsEvent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onRecognizeResults\", {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    set: function (onRecognizeResults) {\n      this._onRecognizeResults = onRecognizeResults;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onUserTextEvent\", {\n    get: function () {\n      return this._onUserTextEvent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onUserText\", {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    set: function (onUserText) {\n      this._onUserText = onUserText;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"echoCancellationEnabled\", {\n    get: function () {\n      return this._echoCancellationEnabled;\n    },\n    set: function (enabled) {\n      this._echoCancellationEnabled = enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onDemoModeEvent\", {\n    /**\n     * @internal\n     */\n    get: function () {\n      return this._onDemoModeEvent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"videoElement\", {\n    get: function () {\n      return this._videoElement;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"viewerOffsetX\", {\n    get: function () {\n      if (this._session) {\n        return this._session.offsetX;\n      }\n\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"viewerOffsetY\", {\n    get: function () {\n      if (this._session) {\n        return this._session.offsetY;\n      }\n\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"isWebSocketOnly\", {\n    get: function () {\n      return this._isWebSocketOnly;\n    },\n    set: function (isWebSocketOnly) {\n      this._isWebSocketOnly = isWebSocketOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onMicrophoneActive\", {\n    /**\n     * @returns an {@link SmEvent} associated with the microphone.\n     *\n     * Listeners can then be added to this event allowing you to call functions when the microphone active status changes.\n     *\n     * Usage:\n     * ```javascript\n     * scene.onMicrophoneActive.addListener(\n     *   (active) => console.log('Microphone Active: ', active));\n     * ```\n     */\n    get: function () {\n      return this._onMicrophoneActive;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Specifies if the microphone is currently active and streaming audio\n   * to the server.\n   *\n   * @returns `boolean`\n   *\n   * Usage:\n   * ```javascript\n   * const isMicrophoneActive = scene.isMicrophoneActive();\n   * ```\n   */\n\n  Scene.prototype.isMicrophoneActive = function () {\n    var _a;\n\n    return Boolean((_a = this._session) === null || _a === void 0 ? void 0 : _a.isMicrophoneActive());\n  };\n\n  Object.defineProperty(Scene.prototype, \"onCameraActive\", {\n    /**\n     * @returns an {@link SmEvent} associated with the camera.\n     *\n     * Listeners can then be added to this event allowing you to call functions when the camera active status changes.\n     *\n     * Usage:\n     * ```javascript\n     * scene.onCameraActive.addListener(\n     *   (active) => console.log('Camera Active: ', active));\n     * ```\n     */\n    get: function () {\n      return this._onCameraActive;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Specifies if the camera is currently active and streaming video\n   * to the server.\n   *\n   * @returns `boolean`\n   *\n   * Usage:\n   * ```javascript\n   * const isCameraActive = scene.isCameraActive();\n   * ```\n   */\n\n  Scene.prototype.isCameraActive = function () {\n    var _a;\n\n    return Boolean((_a = this._session) === null || _a === void 0 ? void 0 : _a.isCameraActive());\n  };\n  /**\n   * On success, starts or stops streaming video/audio to the server based on the values of `microphone` and `camera`.\n   *\n   * @param options.microphone - If `true`, activates the microphone and starts streaming audio. \\\n   * If `false` deactivates the microphone and stops streaming audio. \\\n   * If not set, microphone will retain its existing state.\n   * @param options.camera - If `true`, activates the camera and starts streaming video. \\\n   * If `false` deactivates the camera and stops streaming video. \\\n   * If not set, microphone will retain its existing state.\n   *\n   * @returns Returns a promise which is fulfilled when the media active state has been successfully changed. \\\n   * If the session is not defined it will return `undefined`. \\\n   * If the active state could not be changed, the promise is rejected with an Error object having the format:\n   * ```javascript\n   * {\n   *   message: string;\n   *   name: errorCode;\n   * }\n   * ```\n   * Where `errorCode` is one of:\n   *    - `noUserMedia` - the microphone/camera is either not available, not usable or the user declined permission to use them\n   *    - `failedUpgrade` - the media upgrade failed\n   *    - `notSupported` - user’s browser does not support the getUserMedia API\n   *    - `noConnection` - connection has not been established - ensure scene.connect() has been called previously\n   *\n   * Usage:\n   * ```javascript\n   * scene.setMediaDeviceActive({ microphone: true, camera: false })\n   *   .then(console.log('microphone activated, camera deactivated'));\n   *   .catch((error) => console.log('error occurred: ', error);\n   * ```\n   */\n\n\n  Scene.prototype.setMediaDeviceActive = function (options) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!this.isConnected()) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , (_a = this._session) === null || _a === void 0 ? void 0 : _a.setMediaDeviceActive({\n              microphone: options.microphone,\n              camera: options.camera\n            })];\n\n          case 1:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            throw makeError('Connection has not been established', 'noConnection');\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Play the video element and return results. Different browsers have different restrictions on autoplay.\n   * Using this method can handle all the cases browsers can have on inital video playback.\n   * @param videoElement - Optional parameter specifying the video element hosting the Digital Person. If not specified the video element passed to the Scene constructor will be used.\n   * @returns Returns a promise which is fulfilled when the video playback is successful, with indication of video and audio status.\n   * If the video element is not defined or video play fails the promise is rejected with an Error object having the format:\n   * ```javascript\n   * {\n   *   message: string;\n   *   name: errorCode;\n   * }\n   * ```\n   * Where `errorCode` is one of:\n   *    - `noVideoElement` - no HTMLVideoElement found from `videoElement` or `Scene` constructor\n   *    - `userInteractionRequired` - cannot start media playback due to browser restriction; user interaction is required before playing again\n   *\n   * Usage:\n   * ```javascript\n   * scene.startVideo()\n   *      .then(({ video, audio }) => {\n   *         if (!audio) {\n   *          //video is muted, ask user to unmute video\n   *         }\n   *      })\n   *      .catch((error) => {\n   *         if (error.name === 'userInteractionRequired') {\n   *          //ask user to interact with the UI\n   *          //unmute video and play again\n   *          video.muted = false;\n   *          video.play();\n   *         }\n   *      });\n   * ```\n   */\n\n\n  Scene.prototype.startVideo = function (videoElement) {\n    return __awaiter(this, void 0, void 0, function () {\n      var video;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            video = videoElement || this._videoElement;\n\n            if (!video) {\n              throw makeError('Cannot find HTMLVideoElement', 'noVideoElement');\n            }\n\n            return [4\n            /*yield*/\n            , this.playVideo(video)];\n\n          case 1:\n            // best case, play with audio\n            if (_a.sent()) {\n              return [2\n              /*return*/\n              , {\n                video: true,\n                audio: true\n              }];\n            } //second-best case, play without audio\n\n\n            video.muted = true;\n            return [4\n            /*yield*/\n            , this.playVideo(video)];\n\n          case 2:\n            if (_a.sent()) {\n              return [2\n              /*return*/\n              , {\n                video: true,\n                audio: false\n              }];\n            } //worst case, not able to play, require user interaction\n\n\n            throw makeError('Cannot start media playback', 'userInteractionRequired');\n        }\n      });\n    });\n  };\n\n  Scene.prototype.playVideo = function (videoElement) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _b.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , videoElement.play()];\n\n          case 1:\n            _b.sent();\n\n            return [2\n            /*return*/\n            , true];\n\n          case 2:\n            _a = _b.sent();\n            return [2\n            /*return*/\n            , false];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Scene.prototype.fetchAuthConfig = function (apiKey) {\n    var authServer;\n\n    try {\n      var decodedApiKey = JSON.parse(atob(apiKey));\n      authServer = decodedApiKey.authServer;\n    } catch (error) {\n      throw makeError('Broken API key', 'Failed to decode api key');\n    } // check if sessionId exists in browser storage\n\n\n    var _a = getSessionData(),\n        server = _a.server,\n        resumeSessionId = _a.resumeSessionId,\n        savedApiKey = _a.savedApiKey; // check if the current api key is same as saved api key (if it is intended to resume to the same DP)\n\n\n    if (server && resumeSessionId && savedApiKey === apiKey) {\n      authServer = authServer + '?sessionId=' + resumeSessionId;\n    }\n\n    return fetch(authServer, {\n      headers: {\n        key: apiKey\n      }\n    });\n  }; // Use the first parameter of the constructor to figure out\n  // whether it was constructed using ConnectOptions, or using the deprecated multi-param format.\n\n\n  Scene.prototype.connectArgsToConfig = function (serverUriOrOptions, userText, accessToken, retryOptions) {\n    var _a, _b;\n\n    if (typeof serverUriOrOptions === 'string') {\n      return {\n        tokenServerUri: serverUriOrOptions,\n        tokenServerAccessToken: accessToken,\n        userText: userText,\n        retryOptions: retryOptions\n      };\n    } else {\n      return {\n        tokenServerUri: ((_a = serverUriOrOptions === null || serverUriOrOptions === void 0 ? void 0 : serverUriOrOptions.tokenServer) === null || _a === void 0 ? void 0 : _a.uri) || '',\n        tokenServerAccessToken: (_b = serverUriOrOptions === null || serverUriOrOptions === void 0 ? void 0 : serverUriOrOptions.tokenServer) === null || _b === void 0 ? void 0 : _b.token,\n        userText: serverUriOrOptions === null || serverUriOrOptions === void 0 ? void 0 : serverUriOrOptions.userText,\n        retryOptions: serverUriOrOptions === null || serverUriOrOptions === void 0 ? void 0 : serverUriOrOptions.retryOptions\n      };\n    }\n  };\n  /**\n   * Check if the session logging is enabled.\n   *\n   * @returns Returns true if the session logging is enabled otherwise false.\n   */\n\n\n  Scene.prototype.isLoggingEnabled = function () {\n    return this._logger.isEnabled;\n  };\n  /**\n   * Check minimal log level of session logging.\n   *\n   * @returns Returns minimal log setting of session logging, type is LogLevel.\n   */\n\n\n  Scene.prototype.getMinLogLevel = function () {\n    return this._logger.getMinLogLevel();\n  };\n  /**\n   * Enable/disable session logging\n   * @param enable - set true to enable session log, false to disable\n   */\n\n\n  Scene.prototype.setLogging = function (enable) {\n    this._logger.enableLogging(enable);\n  };\n  /**\n   * Set minimal log level of session logging.\n   * @param level - use LogLevel type to set minimal log level of session logging\n   */\n\n\n  Scene.prototype.setMinLogLevel = function (level) {\n    this._logger.setMinLogLevel(level);\n  };\n\n  return Scene;\n}();\n\nexport { Scene }; //# sourceMappingURL=Scene.js.map","map":null,"metadata":{},"sourceType":"module"}