{"ast":null,"code":"import e from \"@babel/runtime/helpers/classCallCheck\";\nimport t from \"@babel/runtime/helpers/createClass\";\nimport n from \"@babel/runtime/helpers/assertThisInitialized\";\nimport r from \"@babel/runtime/helpers/inherits\";\nimport i from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport s from \"@babel/runtime/helpers/getPrototypeOf\";\nimport { Component as a, useRef as o, useEffect as u, useMemo as c } from \"react\";\nimport l from \"prop-types\";\nimport d from \"@babel/runtime/helpers/asyncToGenerator\";\nimport h from \"@babel/runtime/helpers/slicedToArray\";\nimport m from \"@babel/runtime/regenerator\";\nimport p from \"@babel/runtime/helpers/typeof\";\nvar f = \"object\" === (\"undefined\" == typeof window || \"undefined\" == typeof window ? \"undefined\" : p(window)),\n    v = f ? document : {},\n    g = [\"mousemove\", \"keydown\", \"wheel\", \"DOMMouseScroll\", \"mousewheel\", \"mousedown\", \"touchstart\", \"touchmove\", \"MSPointerDown\", \"MSPointerMove\", \"visibilitychange\"];\n\nfunction b(e, t) {\n  var n;\n\n  function r() {\n    for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++) i[s] = arguments[s];\n\n    n && clearTimeout(n), n = setTimeout(function () {\n      e.apply(void 0, i), n = null;\n    }, t);\n  }\n\n  return r.cancel = function () {\n    clearTimeout(n);\n  }, r;\n}\n\nfunction T(e, t) {\n  var n = 0;\n  return function () {\n    var r = new Date().getTime();\n    if (!(r - n < t)) return n = r, e.apply(void 0, arguments);\n  };\n}\n\nvar _ = 0,\n    y = 0;\n\nfunction w() {\n  var e = new Date().getTime();\n  return e === _ ? 1e3 * e + ++y : (_ = e, y = 0, 1e3 * e);\n}\n\nfunction k() {\n  return Math.random().toString(36).substring(2);\n}\n\nfunction A() {\n  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;\n  return new Promise(function (t) {\n    return setTimeout(t, e);\n  });\n}\n\nfunction I() {\n  return new Date().getTime();\n}\n\nvar E = {\n  create: function (e) {\n    var t = {\n      messagesCallback: null,\n      bc: new BroadcastChannel(e)\n    };\n    return t.bc.onmessage = function (e) {\n      t.messagesCallback && t.messagesCallback(e.data);\n    }, t;\n  },\n  close: function (e) {\n    e.bc.close();\n  },\n  onMessage: function (e, t) {\n    e.messagesCallback = t;\n  },\n  postMessage: function (e, t) {\n    try {\n      return e.bc.postMessage(t, !1), Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  canBeUsed: function () {\n    return \"function\" == typeof BroadcastChannel;\n  },\n  type: \"broadcastChannel\",\n  averageResponseTime: function () {\n    return 150;\n  },\n  microSeconds: w\n},\n    L = function () {\n  function n() {\n    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 6e4;\n    e(this, n), this.ttl = t, this.set = new Set(), this.timeMap = new Map();\n  }\n\n  return t(n, [{\n    key: \"has\",\n    value: function (e) {\n      return this.set.has(e);\n    }\n  }, {\n    key: \"add\",\n    value: function (e) {\n      this.timeMap.set(e, I()), this.set.add(e), this._removeTooOldValues();\n    }\n  }, {\n    key: \"clear\",\n    value: function () {\n      this.set.clear(), this.timeMap.clear();\n    }\n  }, {\n    key: \"_removeTooOldValues\",\n    value: function () {\n      for (var e = I() - this.ttl, t = this.set[Symbol.iterator]();;) {\n        var n = t.next().value;\n        if (!n) return;\n        if (!(this.timeMap.get(n) < e)) return;\n        this.timeMap.delete(n), this.set.delete(n);\n      }\n    }\n  }]), n;\n}();\n\nfunction O() {\n  var e;\n  if (\"undefined\" == typeof window) return null;\n\n  try {\n    e = window.localStorage, e = window[\"ie8-eventlistener/storage\"] || window.localStorage;\n  } catch (e) {}\n\n  return e;\n}\n\nfunction M(e, t) {\n  var n = e,\n      r = function (e) {\n    e.key === n && t(JSON.parse(e.newValue));\n  };\n\n  return window.addEventListener(\"storage\", r), r;\n}\n\nfunction D() {\n  var e = O();\n  if (!e) return !1;\n\n  try {\n    var t = \"__check\";\n    e.setItem(t, \"works\"), e.removeItem(t);\n  } catch (e) {\n    return !1;\n  }\n\n  return !0;\n}\n\nvar S = {\n  create: function (e) {\n    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n    if (!D()) throw new Error(\"❌ localStorage cannot be used.\");\n    var n = k(),\n        r = new L(t.removeTimeout),\n        i = {\n      channelName: e,\n      uuid: n,\n      eMIs: r\n    };\n    return i.listener = M(e, function (e) {\n      i.messagesCallback && e.uuid !== n && e.token && !r.has(e.token) && (e.data.time && e.data.time < i.messagesCallbackTime || (r.add(e.token), i.messagesCallback(e.data)));\n    }), i;\n  },\n  close: function (e) {\n    var t;\n    t = e.listener, window.removeEventListener(\"storage\", t);\n  },\n  onMessage: function (e, t, n) {\n    e.messagesCallbackTime = n, e.messagesCallback = t;\n  },\n  postMessage: function (e, t) {\n    return new Promise(function (n) {\n      var r = e.channelName,\n          i = {\n        token: k(),\n        time: new Date().getTime(),\n        data: t,\n        uuid: e.uuid\n      },\n          s = JSON.stringify(i);\n      O().setItem(r, s);\n      var a = document.createEvent(\"Event\");\n      a.initEvent(\"storage\", !0, !0), a.key = r, a.newValue = s, window.dispatchEvent(a), n();\n    });\n  },\n  canBeUsed: D,\n  type: \"localStorage\",\n  averageResponseTime: function () {\n    var e = navigator.userAgent.toLowerCase();\n    return e.includes(\"safari\") && !e.includes(\"chrome\") ? 240 : 120;\n  },\n  microSeconds: w\n},\n    P = new Set();\nvar C = {\n  create: function (e) {\n    var t = {\n      name: e,\n      messagesCallback: null\n    };\n    return P.add(t), t;\n  },\n  close: function (e) {\n    P.delete(e);\n  },\n  onMessage: function (e, t) {\n    e.messagesCallback = t;\n  },\n  postMessage: function (e, t) {\n    return new Promise(function (n) {\n      return setTimeout(function () {\n        Array.from(P).filter(function (t) {\n          return t.name === e.name;\n        }).filter(function (t) {\n          return t !== e;\n        }).filter(function (e) {\n          return !!e.messagesCallback;\n        }).forEach(function (e) {\n          return e.messagesCallback(t);\n        }), n();\n      }, 5);\n    });\n  },\n  canBeUsed: function () {\n    return !0;\n  },\n  type: \"simulate\",\n  averageResponseTime: function () {\n    return 5;\n  },\n  microSeconds: w\n},\n    x = [E, S];\n\nfunction B() {\n  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n\n  if (e.type) {\n    if (\"simulate\" === e.type) return C;\n    var t = x.find(function (t) {\n      return t.type === e.type;\n    });\n    if (t) return t;\n    throw new Error(\"❌ Method \".concat(e.type, \" is not supported.\"));\n  }\n\n  var n = x.find(function (e) {\n    return e.canBeUsed();\n  });\n  if (!n) throw new Error(\"❌ No method found \".concat(JSON.stringify(x.map(function (e) {\n    return e.type;\n  }))));\n  return n;\n}\n\nvar R = function () {\n  function n(t) {\n    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n    e(this, n), this.name = t, this.options = r, this.method = B(this.options), this.closed = !1, this._isListening = !1, this._onMessageListener = null, this._addEventListeners = {\n      message: [],\n      internal: []\n    }, this._unSendMessagePromises = new Set(), this._beforeClose = [], this._preparePromises = null, j(this);\n  }\n\n  return t(n, [{\n    key: \"postMessage\",\n    value: function (e) {\n      if (this.closed) throw new Error(\"❌ Cannot post message after channel has closed\");\n      return N(this, \"message\", e);\n    }\n  }, {\n    key: \"postInternal\",\n    value: function (e) {\n      return N(this, \"internal\", e);\n    }\n  }, {\n    key: \"onmessage\",\n    get: function () {\n      return this._onMessageListener;\n    },\n    set: function (e) {\n      var t = {\n        time: this.method.microSeconds(),\n        fn: e\n      };\n      U(this, \"message\", this._onMessageListener), e && \"function\" == typeof e ? (this._onMessageListener = t, Y(this, \"message\", t)) : this._onMessageListener = null;\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function (e, t) {\n      Y(this, e, {\n        time: this.method.microSeconds(),\n        fn: t\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function (e, t) {\n      U(this, e, this._addEventListeners[e].find(function (e) {\n        return e.fn === t;\n      }));\n    }\n  }, {\n    key: \"close\",\n    value: function () {\n      var e = this;\n\n      if (!this.closed) {\n        this.closed = !0;\n        var t = this._preparePromises ? this._preparePromises : Promise.resolve();\n        return this._onMessageListener = null, this._addEventListeners.message = [], t.then(function () {\n          return Promise.all(Array.from(e._unSendMessagePromises));\n        }).then(function () {\n          return Promise.all(e._beforeClose.map(function (e) {\n            return e();\n          }));\n        }).then(function () {\n          return e.method.close(e._state);\n        });\n      }\n    }\n  }, {\n    key: \"type\",\n    get: function () {\n      return this.method.type;\n    }\n  }, {\n    key: \"isClosed\",\n    value: function () {\n      return this.closed;\n    }\n  }]), n;\n}();\n\nfunction N(e, t, n) {\n  var r = {\n    time: e.method.microSeconds(),\n    type: t,\n    data: n\n  };\n  return (e._preparePromises ? e._preparePromises : Promise.resolve()).then(function () {\n    var t = e.method.postMessage(e._state, r);\n    return e._unSendMessagePromises.add(t), t.catch().then(function () {\n      return e._unSendMessagePromises.delete(t);\n    }), t;\n  });\n}\n\nfunction j(e) {\n  var t,\n      n = e.method.create(e.name, e.options);\n  (t = n) && \"function\" == typeof t.then ? (e._preparePromises = n, n.then(function (t) {\n    e._state = t;\n  })) : e._state = n;\n}\n\nfunction X(e) {\n  return e._addEventListeners.message.length > 0 || e._addEventListeners.internal.length > 0;\n}\n\nfunction Y(e, t, n) {\n  e._addEventListeners[t].push(n), function (e) {\n    if (!e._isListening && X(e)) {\n      var t = function (t) {\n        e._addEventListeners[t.type].forEach(function (e) {\n          t.time >= e.time && e.fn(t.data);\n        });\n      },\n          n = e.method.microSeconds();\n\n      e._preparePromises ? e._preparePromises.then(function () {\n        e._isListening = !0, e.method.onMessage(e._state, t, n);\n      }) : (e._isListening = !0, e.method.onMessage(e._state, t, n));\n    }\n  }(e);\n}\n\nfunction U(e, t, n) {\n  e._addEventListeners[t] = e._addEventListeners[t].filter(function (e) {\n    return e !== n;\n  }), function (e) {\n    if (e._isListening && !X(e)) {\n      e._isListening = !1;\n      var t = e.method.microSeconds();\n      e.method.onMessage(e._state, null, t);\n    }\n  }(e);\n}\n\nvar F = function () {\n  function n(t, r) {\n    var i = this;\n    e(this, n), this._channel = t, this._options = r, this.isLeader = !1, this.isDead = !1, this.token = k(), this._isApplying = !1, this._reApply = !1, this._unloadFns = [], this._listeners = [], this._intervals = [], this._duplicateListeners = function () {}, this._duplicateCalled = !1, this._onBeforeDie = d(m.mark(function e() {\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n          case \"end\":\n            return e.stop();\n        }\n      }, e);\n    }));\n\n    var s = function () {\n      var e = d(m.mark(function e() {\n        return m.wrap(function (e) {\n          for (;;) switch (e.prev = e.next) {\n            case 0:\n              return e.abrupt(\"return\", i.die());\n\n            case 1:\n            case \"end\":\n              return e.stop();\n          }\n        }, e);\n      }));\n      return function () {\n        return e.apply(this, arguments);\n      };\n    }();\n\n    f && (window.addEventListener(\"beforeUnload\", s), window.addEventListener(\"unload\", s), this._unloadFns.push([\"beforeUnload\", s]), this._unloadFns.push([\"unload\", s]));\n  }\n\n  var r;\n  return t(n, [{\n    key: \"applyOnce\",\n    value: function () {\n      var e = this;\n      if (this.isLeader) return Promise.resolve(!1);\n      if (this.isDead) return Promise.resolve(!1);\n      if (this._isApplying) return this._reApply = !0, Promise.resolve(!1);\n      this._isApplying = !0;\n\n      var t = !1,\n          n = function (n) {\n        \"leader\" === n.context && n.token !== e.token && (\"apply\" === n.action && n.token > e.token && (t = !0), \"tell\" === n.action && (t = !0));\n      };\n\n      return this._channel.addEventListener(\"internal\", n), V(this, \"apply\").then(function () {\n        return A(e._options.responseTime);\n      }).then(function () {\n        return t ? Promise.reject(new Error()) : V(e, \"apply\");\n      }).then(function () {\n        return A(e._options.responseTime);\n      }).then(function () {\n        return t ? Promise.reject(new Error()) : V(e);\n      }).then(function () {\n        return function (e) {\n          e.isLeader = !0;\n\n          var t = function (t) {\n            \"leader\" === t.context && \"apply\" === t.action && V(e, \"tell\"), \"leader\" !== t.context || \"tell\" !== t.action || e._duplicateCalled || (e._duplicateCalled = !0, e._duplicateListeners(), V(e, \"tell\"));\n          };\n\n          return e._channel.addEventListener(\"internal\", t), e._listeners.push(t), V(e, \"tell\");\n        }(e);\n      }).then(function () {\n        return !0;\n      }).catch(function () {\n        return !1;\n      }).then(function (t) {\n        return e._channel.removeEventListener(\"internal\", n), e._isApplying = !1, !t && e._reApply ? (e._reApply = !1, e.applyOnce()) : t;\n      });\n    }\n  }, {\n    key: \"awaitLeadership\",\n    value: function () {\n      var e;\n      return this._awaitLeadershipPromise || (this._awaitLeadershipPromise = (e = this).isLeader ? Promise.resolve() : new Promise(function (t) {\n        var n = !1;\n\n        function r() {\n          n || (n = !0, clearInterval(i), e._channel.removeEventListener(\"internal\", s), t(!0));\n        }\n\n        e.applyOnce().then(function () {\n          e.isLeader && r();\n        });\n        var i = setInterval(function () {\n          e.applyOnce().then(function () {\n            e.isLeader && r();\n          });\n        }, e._options.fallbackInterval);\n\n        e._intervals.push(i);\n\n        var s = function (t) {\n          \"leader\" === t.context && \"death\" === t.action && e.applyOnce().then(function () {\n            e.isLeader && r();\n          });\n        };\n\n        e._channel.addEventListener(\"internal\", s), e._listeners.push(s);\n      })), this._awaitLeadershipPromise;\n    }\n  }, {\n    key: \"onDuplicate\",\n    get: function () {\n      return this._duplicateListeners;\n    },\n    set: function (e) {\n      this._duplicateListeners = e;\n    }\n  }, {\n    key: \"onBeforeDie\",\n    get: function () {\n      return this._onBeforeDie;\n    },\n    set: function (e) {\n      this._onBeforeDie = e;\n    }\n  }, {\n    key: \"die\",\n    value: (r = d(m.mark(function e() {\n      var t = this;\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n            if (!this.isDead) {\n              e.next = 2;\n              break;\n            }\n\n            return e.abrupt(\"return\");\n\n          case 2:\n            return this.isDead = !0, e.next = 5, this.onBeforeDie();\n\n          case 5:\n            return this._listeners.forEach(function (e) {\n              return t._channel.removeEventListener(\"internal\", e);\n            }), this._intervals.forEach(function (e) {\n              return clearInterval(e);\n            }), this._unloadFns.forEach(function (e) {\n              f && window.removeEventListener(e[0], e[1]);\n            }), e.abrupt(\"return\", V(this, \"death\"));\n\n          case 9:\n          case \"end\":\n            return e.stop();\n        }\n      }, e, this);\n    })), function () {\n      return r.apply(this, arguments);\n    })\n  }]), n;\n}();\n\nfunction V(e, t) {\n  var n = {\n    context: \"leader\",\n    action: t,\n    token: e.token\n  };\n  return e._channel.postInternal(n);\n}\n\nvar J = function (e) {\n  var t = e.type,\n      n = e.channelName,\n      r = e.fallbackInterval,\n      i = e.responseTime,\n      s = e.emitOnAllTabs,\n      a = e.callbacks,\n      o = e.start,\n      u = e.reset,\n      c = e.pause,\n      l = e.resume,\n      p = new R(n, {\n    type: t\n  }),\n      f = function (e, t) {\n    if (e._leaderElector) throw new Error(\"❌ MessageChannel already has a leader-elector\");\n    var n = new F(e, t);\n    return e._beforeClose.push(d(m.mark(function e() {\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n            return e.abrupt(\"return\", n.die());\n\n          case 1:\n          case \"end\":\n            return e.stop();\n        }\n      }, e);\n    }))), e._leaderElector = n, n;\n  }(p, {\n    fallbackInterval: r,\n    responseTime: i\n  }),\n      v = {};\n\n  v[f.token] = !1;\n\n  var g = !1,\n      b = !0,\n      T = function () {\n    return g;\n  };\n\n  f.awaitLeadership().then(function () {\n    g = !0;\n  }), p.addEventListener(\"message\", function (e) {\n    var t = h(e, 2),\n        n = t[0],\n        r = t[1];\n\n    switch (n) {\n      case \"register\":\n        v[r] = !1;\n        break;\n\n      case \"deregister\":\n        delete v[r];\n        break;\n\n      case \"idle\":\n        _(r);\n\n        break;\n\n      case \"active\":\n        y(r);\n        break;\n\n      case \"emitIdle\":\n        a.onIdle();\n        break;\n\n      case \"emitActive\":\n        a.onActive();\n        break;\n\n      case \"start\":\n        o(!0);\n        break;\n\n      case \"reset\":\n        u(!0);\n        break;\n\n      case \"pause\":\n        c(!0);\n        break;\n\n      case \"resume\":\n        l(!0);\n    }\n  });\n\n  var _ = function () {\n    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f.token;\n    v[e] = !0;\n    var t = Object.values(v).every(function (e) {\n      return e;\n    });\n    !b && t && (b = !0, T() ? (a.onIdle(), s && w(\"emitIdle\")) : w(\"idle\"));\n  },\n      y = function () {\n    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f.token;\n    v[e] = !1;\n    var t = Object.values(v).some(function (e) {\n      return !e;\n    });\n    b && t && (b = !1, T() ? (a.onActive(), s && w(\"emitActive\")) : w(\"active\"));\n  };\n\n  f.onDuplicate = d(m.mark(function e() {\n    return m.wrap(function (e) {\n      for (;;) switch (e.prev = e.next) {\n        case 0:\n          return e.next = 2, f.die();\n\n        case 2:\n          return e.abrupt(\"return\", e.sent);\n\n        case 3:\n        case \"end\":\n          return e.stop();\n      }\n    }, e);\n  })), f.onBeforeDie = d(m.mark(function e() {\n    return m.wrap(function (e) {\n      for (;;) switch (e.prev = e.next) {\n        case 0:\n          return e.next = 2, w(\"deregister\");\n\n        case 2:\n          return e.abrupt(\"return\", e.sent);\n\n        case 3:\n        case \"end\":\n          return e.stop();\n      }\n    }, e);\n  }));\n\n  var w = function () {\n    var e = d(m.mark(function e(t) {\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n            return e.abrupt(\"return\", p.postMessage([t, f.token]));\n\n          case 1:\n          case \"end\":\n            return e.stop();\n        }\n      }, e);\n    }));\n    return function (t) {\n      return e.apply(this, arguments);\n    };\n  }(),\n      k = function () {\n    var e = d(m.mark(function e() {\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n            return e.next = 2, f.die();\n\n          case 2:\n            return e.next = 4, p.close();\n\n          case 4:\n          case \"end\":\n            return e.stop();\n        }\n      }, e);\n    }));\n    return function () {\n      return e.apply(this, arguments);\n    };\n  }();\n\n  return w(\"register\"), {\n    close: k,\n    send: w,\n    isLeader: T,\n    idle: _,\n    active: y,\n    isAllIdle: function () {\n      return b;\n    },\n    setAllIdle: function (e) {\n      b = e;\n    }\n  };\n};\n\nfunction z(e) {\n  var t = function () {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n\n    try {\n      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n    } catch (e) {\n      return !1;\n    }\n  }();\n\n  return function () {\n    var n,\n        r = s(e);\n\n    if (t) {\n      var a = s(this).constructor;\n      n = Reflect.construct(r, arguments, a);\n    } else n = r.apply(this, arguments);\n\n    return i(this, n);\n  };\n}\n\nvar G = function (i) {\n  r(o, a);\n  var s = z(o);\n\n  function o(t) {\n    var r;\n    if (e(this, o), (r = s.call(this, t)).state = {\n      idle: !1,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      lastIdle: null,\n      idleTime: 0,\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }, r.tId = null, r.eventsBound = !1, r.callbackRefs = {}, t.debounce > 0 && t.throttle > 0) throw new Error(\"onAction can either be throttled or debounced (not both)\");\n    return t.debounce > 0 ? r._onAction = b(t.onAction, t.debounce) : t.throttle > 0 ? r._onAction = T(t.onAction, t.throttle) : r._onAction = t.onAction, t.eventsThrottle > 0 ? r.handleEvent = T(r._handleEvent.bind(n(r)), t.eventsThrottle) : r.handleEvent = r._handleEvent.bind(n(r)), t.startOnMount && !t.startManually || (r.state.idle = !0), r._toggleIdleState = r._toggleIdleState.bind(n(r)), r.start = r.start.bind(n(r)), r.reset = r.reset.bind(n(r)), r.pause = r.pause.bind(n(r)), r.resume = r.resume.bind(n(r)), r.isIdle = r.isIdle.bind(n(r)), r.getRemainingTime = r.getRemainingTime.bind(n(r)), r.getElapsedTime = r.getElapsedTime.bind(n(r)), r.getLastActiveTime = r.getLastActiveTime.bind(n(r)), r.getLastIdleTime = r.getLastIdleTime.bind(n(r)), r.getTotalIdleTime = r.getTotalIdleTime.bind(n(r)), r.getTotalActiveTime = r.getTotalActiveTime.bind(n(r)), r;\n  }\n\n  return t(o, [{\n    key: \"componentDidMount\",\n    value: function () {\n      var e = this.props,\n          t = e.startOnMount,\n          n = e.startManually;\n      this._setupTabManager(), n || (t ? this.start() : this._bindEvents());\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function (e) {\n      e.debounce !== this.props.debounce && this.props.debounce > 0 ? (this._onAction.cancel && this._onAction.cancel(), this._onAction = b(this.props.onAction, this.props.debounce)) : e.throttle !== this.props.throttle && this.props.throttle > 0 ? (this._onAction.cancel && this._onAction.cancel(), this._onAction = T(this.props.onAction, this.props.throttle)) : (e.throttle && 0 === this.props.throttle || e.debounce && 0 === this.props.debounce) && (this._onAction.cancel && this._onAction.cancel(), this._onAction = this.props.onAction), e.eventsThrottle !== this.props.eventsThrottle && (this._unbindEvents(), this.handleEvent = T(this._handleEvent.bind(this), this.props.eventsThrottle), this._bindEvents()), e.timeout !== this.props.timeout && this.state.idle && this.reset(), e.onActive !== this.props.onActive && (this.callbackRefs.onActive = this.props.onActive), e.onIdle !== this.props.onIdle && (this.callbackRefs.onIdle = this.props.onIdle);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function () {\n      clearTimeout(this.tId), this._unbindEvents(!0), this._onAction.cancel && this._onAction.cancel(), this.manager && this.manager.close().catch(console.error);\n    }\n  }, {\n    key: \"render\",\n    value: function () {\n      return this.props.children || null;\n    }\n  }, {\n    key: \"_setupTabManager\",\n    value: function () {\n      var e = this.props,\n          t = e.crossTab,\n          n = e.onIdle,\n          r = e.onActive;\n\n      if (this.callbackRefs = {\n        onIdle: n,\n        onActive: r\n      }, t) {\n        var i = Object.assign({\n          channelName: \"idle-timer\",\n          fallbackInterval: 2e3,\n          responseTime: 100,\n          removeTimeout: 6e4,\n          emitOnAllTabs: !1\n        }, !0 === t ? {} : t),\n            s = i.type,\n            a = i.channelName,\n            o = i.fallbackInterval,\n            u = i.responseTime,\n            c = i.emitOnAllTabs;\n        this.manager = J({\n          type: s,\n          channelName: a,\n          fallbackInterval: o,\n          responseTime: u,\n          emitOnAllTabs: c,\n          callbacks: this.callbackRefs,\n          start: this.start,\n          reset: this.reset,\n          pause: this.pause,\n          resume: this.resume\n        });\n      }\n    }\n  }, {\n    key: \"_bindEvents\",\n    value: function () {\n      var e = this;\n\n      if (f) {\n        var t = this.props,\n            n = t.element,\n            r = t.events,\n            i = t.passive,\n            s = t.capture;\n        this.eventsBound || (r.forEach(function (t) {\n          n.addEventListener(t, e.handleEvent, {\n            capture: s,\n            passive: i\n          });\n        }), this.eventsBound = !0);\n      }\n    }\n  }, {\n    key: \"_unbindEvents\",\n    value: function () {\n      var e = this,\n          t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n\n      if (f) {\n        var n = this.props,\n            r = n.element,\n            i = n.events,\n            s = n.passive,\n            a = n.capture;\n        (this.eventsBound || t) && (i.forEach(function (t) {\n          r.removeEventListener(t, e.handleEvent, {\n            capture: a,\n            passive: s\n          });\n        }), this.eventsBound = !1);\n      }\n    }\n  }, {\n    key: \"_toggleIdleState\",\n    value: function (e) {\n      var t = this;\n      this.setState(function (e) {\n        return {\n          idle: !e.idle,\n          lastIdle: e.idle ? e.lastIdle : +new Date() - t.props.timeout,\n          idleTime: e.idle ? e.idleTime + +new Date() - e.lastIdle : e.idleTime\n        };\n      }, function () {\n        var n = t.props,\n            r = n.onActive,\n            i = n.onIdle,\n            s = n.stopOnIdle;\n        t.state.idle ? (s && (clearTimeout(t.tId), t.tId = null, t._unbindEvents()), t.manager ? t.manager.idle() : i(e)) : (t._bindEvents(), t.manager ? t.manager.active() : r(e));\n      });\n    }\n  }, {\n    key: \"_handleEvent\",\n    value: function (e) {\n      var t = this.state,\n          n = t.remaining,\n          r = t.pageX,\n          i = t.pageY,\n          s = t.idle,\n          a = this.props,\n          o = a.timeout,\n          u = a.stopOnIdle;\n\n      if (this._onAction(e), !n) {\n        if (\"mousemove\" === e.type) {\n          if (e.pageX === r && e.pageY === i) return;\n          if (void 0 === e.pageX && void 0 === e.pageY) return;\n          if (this.getElapsedTime() < 200) return;\n        }\n\n        clearTimeout(this.tId), this.tId = null;\n        var c = +new Date() - this.getLastActiveTime();\n        (s && !u || !s && c > o) && this._toggleIdleState(e), this.setState({\n          lastActive: +new Date(),\n          pageX: e.pageX,\n          pageY: e.pageY\n        }), s && u || (this.tId = setTimeout(this._toggleIdleState, o));\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n      clearTimeout(this.tId), this.tId = null, this._bindEvents(), this.setState({\n        idle: !1,\n        oldDate: +new Date(),\n        lastActive: +new Date(),\n        remaining: null\n      }), this.manager && (this.manager.setAllIdle(!1), !e && this.props.crossTab.emitOnAllTabs && this.manager.send(\"start\"));\n      var t = this.props.timeout;\n      this.tId = setTimeout(this._toggleIdleState, t);\n    }\n  }, {\n    key: \"reset\",\n    value: function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      clearTimeout(this.tId), this.tId = null, this._bindEvents(), this.state.idle && (this.manager ? this.manager.active() : this.props.onActive()), this.manager && (this.manager.setAllIdle(!1), !e && this.props.crossTab.emitOnAllTabs && this.manager.send(\"reset\")), this.setState({\n        idle: !1,\n        oldDate: +new Date(),\n        lastActive: +new Date(),\n        remaining: null\n      });\n      var t = this.props.timeout;\n      this.tId = setTimeout(this._toggleIdleState, t);\n    }\n  }, {\n    key: \"pause\",\n    value: function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n          t = this.state.remaining;\n      null === t && (this._unbindEvents(), clearTimeout(this.tId), this.tId = null, this.manager && !e && this.props.crossTab.emitOnAllTabs && this.manager.send(\"pause\"), this.setState({\n        remaining: this.getRemainingTime()\n      }));\n    }\n  }, {\n    key: \"resume\",\n    value: function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n          t = this.state,\n          n = t.remaining,\n          r = t.idle;\n      null !== n && (this._bindEvents(), this.manager && !e && this.props.crossTab.emitOnAllTabs && this.manager.send(\"resume\"), r || (this.tId = setTimeout(this._toggleIdleState, n), this.setState({\n        remaining: null,\n        lastActive: +new Date()\n      })));\n    }\n  }, {\n    key: \"getRemainingTime\",\n    value: function () {\n      var e = this.state,\n          t = e.remaining,\n          n = e.lastActive,\n          r = this.props.timeout;\n      if (null !== t) return t < 0 ? 0 : t;\n      var i = r - (+new Date() - n);\n      return i < 0 ? 0 : i;\n    }\n  }, {\n    key: \"getElapsedTime\",\n    value: function () {\n      var e = this.state.oldDate;\n      return +new Date() - e;\n    }\n  }, {\n    key: \"getLastIdleTime\",\n    value: function () {\n      return this.state.lastIdle;\n    }\n  }, {\n    key: \"getTotalIdleTime\",\n    value: function () {\n      var e = this.state,\n          t = e.idle,\n          n = e.lastIdle,\n          r = e.idleTime;\n      return t ? +new Date() - n + r : r;\n    }\n  }, {\n    key: \"getLastActiveTime\",\n    value: function () {\n      return this.state.lastActive;\n    }\n  }, {\n    key: \"getTotalActiveTime\",\n    value: function () {\n      return this.getElapsedTime() - this.getTotalIdleTime();\n    }\n  }, {\n    key: \"isIdle\",\n    value: function () {\n      return this.state.idle;\n    }\n  }, {\n    key: \"isLeader\",\n    value: function () {\n      return !this.manager || this.manager.isLeader();\n    }\n  }]), o;\n}();\n\nfunction W() {\n  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n      t = e.timeout,\n      n = void 0 === t ? 12e5 : t,\n      r = e.element,\n      i = void 0 === r ? v : r,\n      s = e.events,\n      a = void 0 === s ? g : s,\n      l = e.onIdle,\n      h = void 0 === l ? function () {} : l,\n      p = e.onActive,\n      _ = void 0 === p ? function () {} : p,\n      y = e.onAction,\n      w = void 0 === y ? function () {} : y,\n      k = e.debounce,\n      A = void 0 === k ? 0 : k,\n      I = e.throttle,\n      E = void 0 === I ? 0 : I,\n      L = e.eventsThrottle,\n      O = void 0 === L ? 200 : L,\n      M = e.startOnMount,\n      D = void 0 === M || M,\n      S = e.startManually,\n      P = void 0 !== S && S,\n      C = e.stopOnIdle,\n      x = void 0 !== C && C,\n      B = e.capture,\n      R = void 0 === B || B,\n      N = e.passive,\n      j = void 0 === N || N,\n      X = e.crossTab,\n      Y = void 0 !== X && X,\n      U = o(!1),\n      F = o(!0),\n      V = o(+new Date()),\n      z = o(null),\n      G = o(null),\n      W = o(null),\n      q = o(null),\n      H = o(null),\n      K = o(null),\n      Q = o(0),\n      Z = o(!0),\n      $ = o(n),\n      ee = o(null);\n\n  Y && (!0 === Y && (Y = {}), Y = Object.assign({\n    channelName: \"idle-timer\",\n    fallbackInterval: 2e3,\n    responseTime: 100,\n    removeTimeout: 6e4,\n    emitOnAllTabs: !1\n  }, Y));\n  var te = o(h),\n      ne = o(_),\n      re = o(w);\n  u(function () {\n    te.current = h;\n  }, [h]), u(function () {\n    ne.current = _;\n  }, [_]), u(function () {\n    re.current = w;\n  }, [w]);\n\n  var ie = c(function () {\n    function e(e) {\n      re.current(e);\n    }\n\n    return e.cancel && e.cancel(), A > 0 ? b(e, A) : E > 0 ? T(e, E) : e;\n  }, [E, A]),\n      se = function (e) {\n    var t = !F.current;\n    F.current = t, t ? (x && (clearTimeout(q.current), q.current = null, ce()), K.current = +new Date() - $.current, ee.current ? ee.current.idle() : te.current(e)) : (Q.current += +new Date() - K.current, ue(), ee.current ? ee.current.active() : ne.current(e));\n  },\n      ae = function (e) {\n    if (ie(e), !z.current) {\n      if (\"mousemove\" === e.type) {\n        if (e.pageX === G && e.pageY === W) return;\n        if (void 0 === e.pageX && void 0 === e.pageY) return;\n        if (de() < 200) return;\n      }\n\n      clearTimeout(q.current), q.current = null;\n      var t = +new Date() - pe();\n      (F.current && !x || !F.current && t > $.current) && se(e), H.current = +new Date(), G.current = e.pageX, W.current = e.pageY, F.current || (q.current = setTimeout(se, $.current));\n    }\n  },\n      oe = o(ae),\n      ue = function () {\n    f && (U.current || (a.forEach(function (e) {\n      i.addEventListener(e, oe.current, {\n        capture: R,\n        passive: j\n      });\n    }), U.current = !0));\n  },\n      ce = function () {\n    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n    f && (U.current || e) && (a.forEach(function (e) {\n      i.removeEventListener(e, oe.current, {\n        capture: R,\n        passive: j\n      });\n    }), U.current = !1);\n  },\n      le = function () {\n    if (null !== z.current) return z.current < 0 ? 0 : z.current;\n    var e = $.current - (+new Date() - H.current);\n    return e < 0 ? 0 : e;\n  },\n      de = function () {\n    return +new Date() - V.current;\n  },\n      he = function () {\n    return K.current;\n  },\n      me = function () {\n    return F.current ? +new Date() - K.current + Q.current : Q.current;\n  },\n      pe = function () {\n    return H.current;\n  },\n      fe = function () {\n    return de() - me();\n  },\n      ve = function () {\n    return F.current;\n  },\n      ge = function () {\n    return !ee.current || ee.current.isLeader();\n  },\n      be = function () {\n    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n    clearTimeout(q.current), q.current = null, ue(), F.current = !1, V.current = +new Date(), H.current = +new Date(), z.current = null, ee.current && (ee.current.setAllIdle(!1), !e && Y.emitOnAllTabs && ee.current.send(\"start\")), q.current = setTimeout(se, $.current);\n  },\n      Te = function () {\n    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n    clearTimeout(q.current), q.current = null, ue(), F.current && (ee.current ? ee.current.active() : ne.current()), F.current = !1, V.current = +new Date(), H.current = +new Date(), z.current = null, ee.current && (ee.current.setAllIdle(!1), !e && Y.emitOnAllTabs && ee.current.send(\"reset\")), q.current = setTimeout(se, $.current);\n  },\n      _e = function () {\n    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n    null === z.current && (ce(), clearTimeout(q.current), q.current = null, z.current = le(), ee.current && !e && Y.emitOnAllTabs && ee.current.send(\"pause\"));\n  },\n      ye = function () {\n    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n    null !== z.current && (ue(), F.current || (q.current = setTimeout(se, z.current), z.current = null, H.current = +new Date()), ee.current && !e && Y.emitOnAllTabs && ee.current.send(\"resume\"));\n  };\n\n  return u(function () {\n    if (A > 0 && E > 0) throw new Error(\"onAction can either be throttled or debounced (not both)\");\n    return Y && (ee.current = J({\n      type: Y.type,\n      channelName: Y.channelName,\n      fallbackInterval: Y.fallbackInterval,\n      responseTime: Y.responseTime,\n      emitOnAllTabs: Y.emitOnAllTabs,\n      callbacks: {\n        onIdle: te.current,\n        onActive: ne.current\n      },\n      start: be,\n      reset: Te,\n      pause: _e,\n      resume: ye\n    })), P ? d(m.mark(function e() {\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n            if (clearTimeout(q.current), ce(!0), !Y) {\n              e.next = 5;\n              break;\n            }\n\n            return e.next = 5, ee.current.close();\n\n          case 5:\n          case \"end\":\n            return e.stop();\n        }\n      }, e);\n    })) : (D ? be() : ue(), d(m.mark(function e() {\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n            if (clearTimeout(q.current), ce(!0), ie.cancel && ie.cancel(), !Y) {\n              e.next = 6;\n              break;\n            }\n\n            return e.next = 6, ee.current.close();\n\n          case 6:\n          case \"end\":\n            return e.stop();\n        }\n      }, e);\n    })));\n  }, []), u(function () {\n    var e = U.current;\n    e && ce(), oe.current = O > 0 ? T(ae, O) : ae, e && ue();\n  }, [O]), u(function () {\n    $.current = n, !Z.current && F.current && Te(), Z.current = !1;\n  }, [n]), {\n    isIdle: ve,\n    isLeader: ge,\n    start: be,\n    pause: _e,\n    reset: Te,\n    resume: ye,\n    getLastIdleTime: he,\n    getTotalIdleTime: me,\n    getLastActiveTime: pe,\n    getTotalActiveTime: fe,\n    getElapsedTime: de,\n    getRemainingTime: le\n  };\n}\n\nG.propTypes = {\n  timeout: l.number,\n  events: l.arrayOf(l.string),\n  onIdle: l.func,\n  onActive: l.func,\n  onAction: l.func,\n  debounce: l.number,\n  throttle: l.number,\n  eventsThrottle: l.number,\n  element: l.oneOfType([l.object, l.element]),\n  startOnMount: l.bool,\n  startManually: l.bool,\n  stopOnIdle: l.bool,\n  passive: l.bool,\n  capture: l.bool,\n  crossTab: l.oneOfType([l.bool, l.shape({\n    type: l.oneOf([\"broadcastChannel\", \"localStorage\", \"simulate\"]),\n    channelName: l.string,\n    fallbackInterval: l.number,\n    responseTime: l.number,\n    removeTimeout: l.number,\n    emitOnAllTabs: l.bool\n  })])\n}, G.defaultProps = {\n  timeout: 12e5,\n  element: v,\n  events: g,\n  onIdle: function () {},\n  onActive: function () {},\n  onAction: function () {},\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: !0,\n  startManually: !1,\n  stopOnIdle: !1,\n  capture: !0,\n  passive: !0,\n  crossTab: !1\n}, W.propTypes = {\n  timeout: l.number,\n  events: l.arrayOf(l.string),\n  onIdle: l.func,\n  onActive: l.func,\n  onAction: l.func,\n  debounce: l.number,\n  throttle: l.number,\n  eventsThrottle: l.number,\n  element: l.oneOfType([l.object, l.element]),\n  startOnMount: l.bool,\n  startManually: l.bool,\n  stopOnIdle: l.bool,\n  passive: l.bool,\n  capture: l.bool,\n  crossTab: l.oneOfType([l.bool, l.shape({\n    type: l.oneOf([\"broadcastChannel\", \"localStorage\", \"simulate\"]),\n    channelName: l.string,\n    fallbackInterval: l.number,\n    responseTime: l.number,\n    removeTimeout: l.number,\n    emitOnAllTabs: l.bool\n  })])\n}, W.defaultProps = {\n  timeout: 12e5,\n  element: v,\n  events: g,\n  onIdle: function () {},\n  onActive: function () {},\n  onAction: function () {},\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: !0,\n  startManually: !1,\n  stopOnIdle: !1,\n  capture: !0,\n  passive: !0,\n  crossTab: !1\n};\nexport default G;\nexport { W as useIdleTimer }; //# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module"}