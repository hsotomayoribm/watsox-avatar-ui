{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nimport { InstrumentType } from '../InstrumentDescriptor';\n\nfunction createNewEmptyCheckpoint(boundaries) {\n  var counts = boundaries.map(function () {\n    return 0;\n  });\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries: boundaries,\n      counts: counts\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity\n  };\n}\n\nvar HistogramAccumulation =\n/** @class */\nfunction () {\n  function HistogramAccumulation(startTime, _boundaries, _recordMinMax, _current) {\n    if (_recordMinMax === void 0) {\n      _recordMinMax = true;\n    }\n\n    if (_current === void 0) {\n      _current = createNewEmptyCheckpoint(_boundaries);\n    }\n\n    this.startTime = startTime;\n    this._boundaries = _boundaries;\n    this._recordMinMax = _recordMinMax;\n    this._current = _current;\n  }\n\n  HistogramAccumulation.prototype.record = function (value) {\n    this._current.count += 1;\n    this._current.sum += value;\n\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n\n    for (var i = 0; i < this._boundaries.length; i++) {\n      if (value < this._boundaries[i]) {\n        this._current.buckets.counts[i] += 1;\n        return;\n      }\n    } // value is above all observed boundaries\n\n\n    this._current.buckets.counts[this._boundaries.length] += 1;\n  };\n\n  HistogramAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n\n  HistogramAccumulation.prototype.toPointValue = function () {\n    return this._current;\n  };\n\n  return HistogramAccumulation;\n}();\n\nexport { HistogramAccumulation };\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\n\nvar HistogramAggregator =\n/** @class */\nfunction () {\n  /**\n   * @param _boundaries upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  function HistogramAggregator(_boundaries, _recordMinMax) {\n    this._boundaries = _boundaries;\n    this._recordMinMax = _recordMinMax;\n    this.kind = AggregatorKind.HISTOGRAM;\n  }\n\n  HistogramAggregator.prototype.createAccumulation = function (startTime) {\n    return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);\n  };\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n\n\n  HistogramAggregator.prototype.merge = function (previous, delta) {\n    var previousValue = previous.toPointValue();\n    var deltaValue = delta.toPointValue();\n    var previousCounts = previousValue.buckets.counts;\n    var deltaCounts = deltaValue.buckets.counts;\n    var mergedCounts = new Array(previousCounts.length);\n\n    for (var idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n\n    var min = Infinity;\n    var max = -Infinity;\n\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n\n    return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: mergedCounts\n      },\n      count: previousValue.count + deltaValue.count,\n      sum: previousValue.sum + deltaValue.sum,\n      hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),\n      min: min,\n      max: max\n    });\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n\n\n  HistogramAggregator.prototype.diff = function (previous, current) {\n    var previousValue = previous.toPointValue();\n    var currentValue = current.toPointValue();\n    var previousCounts = previousValue.buckets.counts;\n    var currentCounts = currentValue.buckets.counts;\n    var diffedCounts = new Array(previousCounts.length);\n\n    for (var idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n\n    return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: diffedCounts\n      },\n      count: currentValue.count - previousValue.count,\n      sum: currentValue.sum - previousValue.sum,\n      hasMinMax: false,\n      min: Infinity,\n      max: -Infinity\n    });\n  };\n\n  HistogramAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n            attributes = _b[0],\n            accumulation = _b[1];\n\n        var pointValue = accumulation.toPointValue(); // determine if instrument allows negative values.\n\n        var allowsNegativeValues = descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count\n          }\n        };\n      })\n    };\n  };\n\n  return HistogramAggregator;\n}();\n\nexport { HistogramAggregator }; //# sourceMappingURL=Histogram.js.map","map":null,"metadata":{},"sourceType":"module"}