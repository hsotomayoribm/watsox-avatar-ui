{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { context, diag, TraceFlags } from '@opentelemetry/api';\nimport { BindOnceFuture, ExportResultCode, getEnv, globalErrorHandler, suppressTracing, unrefTimer } from '@opentelemetry/core';\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\n\nvar BatchSpanProcessorBase =\n/** @class */\nfunction () {\n  function BatchSpanProcessorBase(_exporter, config) {\n    this._exporter = _exporter;\n    this._finishedSpans = [];\n    this._droppedSpansCount = 0;\n    var env = getEnv();\n    this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number' ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number' ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number' ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number' ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  BatchSpanProcessorBase.prototype.forceFlush = function () {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n\n    return this._flushAll();\n  }; // does nothing.\n\n\n  BatchSpanProcessorBase.prototype.onStart = function (_span, _parentContext) {};\n\n  BatchSpanProcessorBase.prototype.onEnd = function (span) {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    this._addToBuffer(span);\n  };\n\n  BatchSpanProcessorBase.prototype.shutdown = function () {\n    return this._shutdownOnce.call();\n  };\n\n  BatchSpanProcessorBase.prototype._shutdown = function () {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      return _this.onShutdown();\n    }).then(function () {\n      return _this._flushAll();\n    }).then(function () {\n      return _this._exporter.shutdown();\n    });\n  };\n  /** Add a span in the buffer. */\n\n\n  BatchSpanProcessorBase.prototype._addToBuffer = function (span) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n\n      this._droppedSpansCount++;\n      return;\n    }\n\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\"Dropped \" + this._droppedSpansCount + \" spans because maxQueueSize reached\");\n      this._droppedSpansCount = 0;\n    }\n\n    this._finishedSpans.push(span);\n\n    this._maybeStartTimer();\n  };\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n\n\n  BatchSpanProcessorBase.prototype._flushAll = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var promises = []; // calculate number of batches\n\n      var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);\n\n      for (var i = 0, j = count; i < j; i++) {\n        promises.push(_this._flushOneBatch());\n      }\n\n      Promise.all(promises).then(function () {\n        resolve();\n      }).catch(reject);\n    });\n  };\n\n  BatchSpanProcessorBase.prototype._flushOneBatch = function () {\n    var _this = this;\n\n    this._clearTimer();\n\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n\n    return new Promise(function (resolve, reject) {\n      var timer = setTimeout(function () {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, _this._exportTimeoutMillis); // prevent downstream exporter calls from generating spans\n\n      context.with(suppressTracing(context.active()), function () {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        var spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);\n\n        var doExport = function () {\n          return _this._exporter.export(spans, function (result) {\n            var _a;\n\n            clearTimeout(timer);\n\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));\n            }\n          });\n        };\n\n        var pendingResources = spans.map(function (span) {\n          return span.resource;\n        }).filter(function (resource) {\n          return resource.asyncAttributesPending;\n        }); // Avoid scheduling a promise to make the behavior more predictable and easier to test\n\n        if (pendingResources.length === 0) {\n          doExport();\n        } else {\n          Promise.all(pendingResources.map(function (resource) {\n            var _a;\n\n            return (_a = resource.waitForAsyncAttributes) === null || _a === void 0 ? void 0 : _a.call(resource);\n          })).then(doExport, function (err) {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  };\n\n  BatchSpanProcessorBase.prototype._maybeStartTimer = function () {\n    var _this = this;\n\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(function () {\n      _this._flushOneBatch().then(function () {\n        if (_this._finishedSpans.length > 0) {\n          _this._clearTimer();\n\n          _this._maybeStartTimer();\n        }\n      }).catch(function (e) {\n        globalErrorHandler(e);\n      });\n    }, this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  };\n\n  BatchSpanProcessorBase.prototype._clearTimer = function () {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  };\n\n  return BatchSpanProcessorBase;\n}();\n\nexport { BatchSpanProcessorBase }; //# sourceMappingURL=BatchSpanProcessorBase.js.map","map":null,"metadata":{},"sourceType":"module"}