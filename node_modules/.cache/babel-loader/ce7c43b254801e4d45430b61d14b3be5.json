{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as api from '@opentelemetry/api';\nimport { SumAggregator, DropAggregator, LastValueAggregator, HistogramAggregator } from '../aggregator';\nimport { InstrumentType } from '../InstrumentDescriptor';\n/**\n * Configures how measurements are combined into metrics for views.\n *\n * Aggregation provides a set of built-in aggregations via static methods.\n */\n\nvar Aggregation =\n/** @class */\nfunction () {\n  function Aggregation() {}\n\n  Aggregation.Drop = function () {\n    return DROP_AGGREGATION;\n  };\n\n  Aggregation.Sum = function () {\n    return SUM_AGGREGATION;\n  };\n\n  Aggregation.LastValue = function () {\n    return LAST_VALUE_AGGREGATION;\n  };\n\n  Aggregation.Histogram = function () {\n    return HISTOGRAM_AGGREGATION;\n  };\n\n  Aggregation.Default = function () {\n    return DEFAULT_AGGREGATION;\n  };\n\n  return Aggregation;\n}();\n\nexport { Aggregation };\n/**\n * The default drop aggregation.\n */\n\nvar DropAggregation =\n/** @class */\nfunction (_super) {\n  __extends(DropAggregation, _super);\n\n  function DropAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DropAggregation.prototype.createAggregator = function (_instrument) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  };\n\n  DropAggregation.DEFAULT_INSTANCE = new DropAggregator();\n  return DropAggregation;\n}(Aggregation);\n\nexport { DropAggregation };\n/**\n * The default sum aggregation.\n */\n\nvar SumAggregation =\n/** @class */\nfunction (_super) {\n  __extends(SumAggregation, _super);\n\n  function SumAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SumAggregation.prototype.createAggregator = function (instrument) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM:\n        {\n          return SumAggregation.MONOTONIC_INSTANCE;\n        }\n\n      default:\n        {\n          return SumAggregation.NON_MONOTONIC_INSTANCE;\n        }\n    }\n  };\n\n  SumAggregation.MONOTONIC_INSTANCE = new SumAggregator(true);\n  SumAggregation.NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  return SumAggregation;\n}(Aggregation);\n\nexport { SumAggregation };\n/**\n * The default last value aggregation.\n */\n\nvar LastValueAggregation =\n/** @class */\nfunction (_super) {\n  __extends(LastValueAggregation, _super);\n\n  function LastValueAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  LastValueAggregation.prototype.createAggregator = function (_instrument) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  };\n\n  LastValueAggregation.DEFAULT_INSTANCE = new LastValueAggregator();\n  return LastValueAggregation;\n}(Aggregation);\n\nexport { LastValueAggregation };\n/**\n * The default histogram aggregation.\n */\n\nvar HistogramAggregation =\n/** @class */\nfunction (_super) {\n  __extends(HistogramAggregation, _super);\n\n  function HistogramAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  HistogramAggregation.prototype.createAggregator = function (_instrument) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  };\n\n  HistogramAggregation.DEFAULT_INSTANCE = new HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 1000], true);\n  return HistogramAggregation;\n}(Aggregation);\n\nexport { HistogramAggregation };\n/**\n * The explicit bucket histogram aggregation.\n */\n\nvar ExplicitBucketHistogramAggregation =\n/** @class */\nfunction (_super) {\n  __extends(ExplicitBucketHistogramAggregation, _super);\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n\n\n  function ExplicitBucketHistogramAggregation(boundaries, _recordMinMax) {\n    if (_recordMinMax === void 0) {\n      _recordMinMax = true;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this._recordMinMax = _recordMinMax;\n\n    if (boundaries === undefined || boundaries.length === 0) {\n      throw new Error('HistogramAggregator should be created with boundaries.');\n    } // Copy the boundaries array for modification.\n\n\n    boundaries = boundaries.concat(); // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n\n    boundaries = boundaries.sort(function (a, b) {\n      return a - b;\n    }); // Remove all Infinity from the boundaries.\n\n    var minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    var infinityIndex = boundaries.indexOf(Infinity);\n\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n\n    _this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n    return _this;\n  }\n\n  ExplicitBucketHistogramAggregation.prototype.createAggregator = function (_instrument) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  };\n\n  return ExplicitBucketHistogramAggregation;\n}(Aggregation);\n\nexport { ExplicitBucketHistogramAggregation };\n/**\n * The default aggregation.\n */\n\nvar DefaultAggregation =\n/** @class */\nfunction (_super) {\n  __extends(DefaultAggregation, _super);\n\n  function DefaultAggregation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DefaultAggregation.prototype._resolve = function (instrument) {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:\n        {\n          return SUM_AGGREGATION;\n        }\n\n      case InstrumentType.OBSERVABLE_GAUGE:\n        {\n          return LAST_VALUE_AGGREGATION;\n        }\n\n      case InstrumentType.HISTOGRAM:\n        {\n          return HISTOGRAM_AGGREGATION;\n        }\n    }\n\n    api.diag.warn(\"Unable to recognize instrument type: \" + instrument.type);\n    return DROP_AGGREGATION;\n  };\n\n  DefaultAggregation.prototype.createAggregator = function (instrument) {\n    return this._resolve(instrument).createAggregator(instrument);\n  };\n\n  return DefaultAggregation;\n}(Aggregation);\n\nexport { DefaultAggregation };\nvar DROP_AGGREGATION = new DropAggregation();\nvar SUM_AGGREGATION = new SumAggregation();\nvar LAST_VALUE_AGGREGATION = new LastValueAggregation();\nvar HISTOGRAM_AGGREGATION = new HistogramAggregation();\nvar DEFAULT_AGGREGATION = new DefaultAggregation(); //# sourceMappingURL=Aggregation.js.map","map":null,"metadata":{},"sourceType":"module"}