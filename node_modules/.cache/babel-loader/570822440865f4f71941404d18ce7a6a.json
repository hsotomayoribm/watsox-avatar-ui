{"ast":null,"code":"/**\n * @module smwebsdk\n */\nimport { __awaiter, __generator } from \"tslib\";\n/*\n * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.\n */\n\nimport { Deferred } from './Deferred';\nimport { Features } from './Features';\nimport { Logger } from './utils/Logger';\nimport { makeError } from './utils/make-error';\n/**\n *  LocalSession class\n */\n\nvar LocalSession =\n/** @class */\nfunction () {\n  function LocalSession(videoElement, logger) {\n    if (logger === void 0) {\n      logger = new Logger();\n    }\n\n    var _this = this;\n\n    this.logger = logger;\n    this._isMicrophoneConnected = false;\n    this._isCameraConnected = false;\n\n    this._onConnectedStorage = function (resumeRequested, isResumedSession, server, sessionId // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) {};\n\n    this._closed = false;\n    this._outgoingQueue = []; // Duration that microphone mute is maintained by the web sdk after the persona has\n    // finished speaking.  Set to -1 to disable.  Default value is -1 (disabled).\n\n    this._microphoneMuteDelay = -1;\n    this._offsetX = 0;\n    this._offsetY = 0;\n\n    if (videoElement) {\n      this._viewport_element = videoElement;\n    }\n\n    window.SmRuntimeHostReceiveMessage = this.receiveMessage.bind(this);\n\n    if (typeof window.SmRuntimeHostStyleViewportElement === 'function') {\n      window.SmRuntimeHostStyleViewportElement(this._viewport_element);\n    } // owner specifies custom close method\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    this._onClose = function (reason) {}; // owner specifies custom message handler\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    this._onMessage = function (message) {}; // owner specifies custom rtc user text message handler\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    this._onUserText = function (text) {};\n\n    this.sendVideoBounds(0, 0); // The initial positioning can take a while. Would be nice to make this more deterministic.\n\n    setTimeout(function () {\n      _this.sendVideoBounds(0, 0);\n    }, 3000);\n    this._features = new Features();\n    this.log('Local session created!');\n  }\n\n  LocalSession.prototype.receiveMessage = function (raw_text) {\n    var _a, _b;\n\n    var message = JSON.parse(raw_text);\n    this.log(\"message received: \".concat(raw_text));\n\n    this._onMessage(message);\n\n    if (message.name === 'state' && message.category === 'scene' && ((_b = (_a = message.body) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.state) === 'idle') {\n      this.log('Local session ending - conversationEnded');\n      this.close(true, 'conversationEnded');\n    }\n  };\n\n  Object.defineProperty(LocalSession.prototype, \"onConnected\", {\n    set: function (sessionFunction) {\n      this._onConnectedStorage = sessionFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"onClose\", {\n    set: function (closeFunction) {\n      this._onClose = closeFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"onMessage\", {\n    set: function (messageFunction) {\n      this._onMessage = messageFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"onUserText\", {\n    set: function (userTextFunction) {\n      this._onUserText = userTextFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"loggingEnabled\", {\n    get: function () {\n      return this.logger.isEnabled;\n    },\n\n    /**\n     * @deprecated use setLogging(boolean).\n     */\n    set: function (enable) {\n      this.logger.log('warn', 'loggingEnabled is deprecated and will be removed in a future version. Please use setLogging(boolean)');\n      this.logger.enableLogging(enable);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  LocalSession.prototype.setMinLogLevel = function (level) {\n    this.logger.setMinLogLevel(level);\n  };\n\n  LocalSession.prototype.setLogging = function (enable) {\n    this.logger.enableLogging(enable);\n  };\n\n  LocalSession.prototype.log = function (text) {\n    this.logger.log('log', text);\n  };\n\n  LocalSession.prototype.sendVideoBounds = function (widthIgnored, heightIgnored) {\n    var _this = this; // We need to defer the update very slightly to give the browser time to reflow,\n    // otherwise we get out of date values for width, height etc:\n\n\n    setTimeout(function () {\n      // Brute-force method for getting pos and dimensions, as\n      // getBoundingClientRect seems to be unreliable (sometimes\n      // returning zeroes for left and right):\n      var el = _this._viewport_element;\n\n      if (el) {\n        var view = document.defaultView || window;\n        var width = parseInt(view.getComputedStyle(el).width, 10);\n        var height = parseInt(view.getComputedStyle(el).height, 10);\n        _this._offsetX = 0;\n        _this._offsetY = 0;\n\n        while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {\n          _this._offsetX += el.offsetLeft - el.scrollLeft;\n          _this._offsetY += el.offsetTop - el.scrollTop;\n          el = el.offsetParent;\n        }\n\n        if (document.documentElement) {\n          var x_off = document.documentElement.scrollLeft;\n          var y_off = document.documentElement.scrollTop;\n          _this._offsetX -= x_off;\n          _this._offsetY -= y_off;\n        }\n\n        _this.log(\"Updating bounds: x =  \".concat(_this._offsetX, \" , y = \").concat(_this._offsetY, \"', w = \").concat(width, \", h = \").concat(height)); // update bounds\n\n\n        var top_1 = _this._offsetY;\n        var left = _this._offsetX;\n        var bottom = _this._offsetY + height;\n        var right = _this._offsetX + width;\n        var payload = {\n          name: 'videoBounds',\n          body: {\n            top: top_1,\n            left: left,\n            bottom: bottom,\n            right: right\n          },\n          category: 'local',\n          kind: 'event'\n        };\n\n        _this.sendMessage(payload);\n      }\n    }, 0);\n  };\n\n  LocalSession.prototype.hideVideo = function () {\n    var top = 0;\n    var left = 0;\n    var bottom = 0;\n    var right = 0;\n    var payload = {\n      name: 'videoBounds',\n      body: {\n        top: top,\n        left: left,\n        bottom: bottom,\n        right: right\n      },\n      category: 'local',\n      kind: 'event'\n    };\n    this.sendMessage(payload);\n  };\n\n  LocalSession.prototype.sendRtcEvent = function (name, body) {// NOOP: Stuff for compatibility with Session in Scene\n  };\n\n  LocalSession.prototype.connect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var deferred, result, payload;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            deferred = new Deferred();\n            this.log('Local session connecting!');\n            this._closed = false;\n            return [4\n            /*yield*/\n            , this._features.detectWebRTCFeatures()];\n\n          case 1:\n            result = _a.sent();\n            this._closed = false;\n            this._sessionId = undefined;\n            this._isMicrophoneConnected = result.hasMicrophone;\n            this._isCameraConnected = result.hasCamera;\n\n            if (typeof window.local_websocket_port === 'number') {\n              this._serverConnection = new WebSocket('ws://localhost:' + window.local_websocket_port);\n              this.log('websocket open');\n\n              this._serverConnection.onmessage = function (msg) {\n                _this.gotMessageFromServer(msg);\n              };\n\n              this._serverConnection.onerror = function (event) {\n                if (deferred.isPending()) {\n                  deferred.reject(makeError('websocket failed', 'serverConnectionFailed'));\n                }\n              };\n\n              this._serverConnection.onopen = function (event) {\n                // disable SmRuntimeHostReceiveMessage\n                // eslint-disable-next-line @typescript-eslint/no-empty-function\n                window.SmRuntimeHostReceiveMessage = function () {};\n\n                _this.log('Local session connected!'); // send out messages in queue\n\n\n                for (var i = 0; i < _this._outgoingQueue.length; i++) {\n                  _this._serverConnection.send(JSON.stringify(_this._outgoingQueue[i]));\n\n                  _this.logger.log('log', 'SmLocalSession.prototype.sendMessage, forwarding message to Web Socket: ' + _this._outgoingQueue[i]);\n                }\n\n                _this._outgoingQueue = [];\n\n                if (deferred.isPending()) {\n                  deferred.resolve();\n                }\n              };\n\n              this._serverConnection.onclose = function (event) {\n                _this.logger.log('log', \"websocket closed: code(\".concat(event.code, \"), reason(\").concat(event.reason, \"), clean(\").concat(event.wasClean, \")\"));\n\n                if (!deferred.isRejected) {\n                  _this.close(false, 'normal');\n                }\n              };\n            } else {\n              this.log('local_websocket_port not found! Failed to create WebSocket');\n\n              if (deferred.isPending()) {\n                deferred.reject(makeError('websocket failed', 'local_websocket_port not found'));\n              }\n            }\n\n            payload = {\n              name: 'startSession',\n              body: {},\n              category: 'scene',\n              kind: 'request'\n            };\n            this.sendMessage(payload);\n            return [2\n            /*return*/\n            , deferred.promise];\n        }\n      });\n    });\n  };\n\n  LocalSession.prototype.gotMessageFromServer = function (websocket_message) {\n    var raw_text = websocket_message.data;\n    var message = JSON.parse(raw_text);\n    var category = message.category;\n    var name = message.name;\n    var body = message.body;\n\n    if (category !== 'webrtc') {\n      // forward on non-webrtc messages (e.g. scene)\n      this._onMessage(message);\n    } else if (name === 'close') {\n      this.close(false, body.reason);\n    }\n\n    if (name === 'state' && category === 'scene' && body.session !== null && body.session !== undefined && body.session.state === 'idle') {\n      this.log('Local session ending due to server idle message');\n      this.close(true, 'conversationEnded');\n    }\n  };\n\n  LocalSession.prototype.sendMessage = function (message) {\n    var msg = JSON.stringify(message);\n\n    if (this._serverConnection && this._serverConnection.readyState === WebSocket.OPEN) {\n      this._serverConnection.send(msg);\n\n      this.log(\"SmLocalSession.prototype.sendMessage, forwarding message to Web Socket: \".concat(msg));\n    } else {\n      this._outgoingQueue.push(message);\n    }\n  };\n\n  LocalSession.prototype.sendUserText = function (text) {\n    this.logger.log('log', 'SmLocalSession.prototype.sendUserText, discarding text: ' + text);\n  };\n\n  LocalSession.prototype.close = function (sendRtcClose, reason) {\n    if (sendRtcClose === void 0) {\n      sendRtcClose = true;\n    }\n\n    if (reason === void 0) {\n      reason = 'normal';\n    }\n\n    if (this._closed) {\n      return;\n    }\n\n    this._closed = true;\n\n    this._onClose(reason);\n\n    this._isMicrophoneConnected = false;\n    this._isCameraConnected = false;\n    this.hideVideo();\n\n    if (this._serverConnection) {\n      this.log('closing server connection');\n      var normalClosureCode = 1000;\n\n      this._serverConnection.close(normalClosureCode, reason);\n    }\n  };\n\n  Object.defineProperty(LocalSession.prototype, \"peerConnection\", {\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"userMediaStream\", {\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"serverConnection\", {\n    get: function () {\n      return this._serverConnection;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"sessionId\", {\n    get: function () {\n      return this._sessionId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"isMicrophoneConnected\", {\n    get: function () {\n      return this._isMicrophoneConnected;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"isCameraConnected\", {\n    get: function () {\n      return this._isCameraConnected;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"features\", {\n    get: function () {\n      return this._features;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"microphoneMuteDelay\", {\n    get: function () {\n      return this._microphoneMuteDelay;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"microphoneMuted\", {\n    get: function () {\n      // todo - RuntimeHost does not yet support this,\n      //        currently only needed in webrtc sessions and tests\n      if (typeof window.SmRuntimeHostIsMicrophoneMuted === 'function') {\n        return window.SmRuntimeHostIsMicrophoneMuted();\n      }\n\n      return false;\n    },\n    set: function (mute) {\n      // todo - RuntimeHost does not yet support this,\n      //        currently only needed in webrtc sessions and tests\n      if (typeof window.SmRuntimeHostMuteMicrophone === 'function') {\n        window.SmRuntimeHostMuteMicrophone(mute);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"offsetX\", {\n    get: function () {\n      return this._offsetX;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LocalSession.prototype, \"offsetY\", {\n    get: function () {\n      return this._offsetY;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  LocalSession.prototype.isMicrophoneActive = function () {\n    return this.isMicrophoneConnected && !this.microphoneMuted;\n  };\n\n  LocalSession.prototype.isCameraActive = function () {\n    return this.isCameraConnected;\n  };\n\n  LocalSession.prototype.setMediaDeviceActive = function (_a) {\n    var microphone = _a.microphone,\n        camera = _a.camera;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        throw makeError('setMediaDeviceActive not supported on LocalSession', 'notSupported');\n      });\n    });\n  };\n\n  return LocalSession;\n}();\n\nexport { LocalSession }; //# sourceMappingURL=LocalSession.js.map","map":null,"metadata":{},"sourceType":"module"}