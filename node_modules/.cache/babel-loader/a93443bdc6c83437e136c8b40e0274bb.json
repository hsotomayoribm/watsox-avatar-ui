{"ast":null,"code":"/*\n * Copyright 2021 Soul Machines Ltd. All Rights Reserved.\n */\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport allImagesLoaded from './utils/allImagesLoaded';\nimport { debouncedFunction } from './utils/debounce';\nimport { Logger } from './utils/Logger';\n/**\n * ContentAwareness class\n *\n * An instance of this class is used to enable CUE behaviors in the digital human.\n * This is achived by measuring tagged HTML elements and sending their coordinates back to the server\n *\n * See documentation on GitHub for further reference on how to use this API\n * https://github.com/soulmachines/smwebsdk/blob/cue-content-awareness-api/guide/content-awareness.md\n *\n * @public\n */\n\nvar ContentAwareness =\n/** @class */\nfunction () {\n  function ContentAwareness(scene, debounceTime, logger) {\n    if (debounceTime === void 0) {\n      debounceTime = 300;\n    }\n\n    if (logger === void 0) {\n      logger = new Logger();\n    }\n\n    var _this = this;\n\n    this.scene = scene;\n    this.debounceTime = debounceTime;\n    this.logger = logger; // Data Attribute Strings\n\n    this.VIDEO_FRAME_STR = 'data-sm-video';\n    this.VIDEO_FRAME_STR_BRACKETED = \"[\".concat(this.VIDEO_FRAME_STR, \"]\");\n    this.CONTENT_STR = 'data-sm-content';\n    this.CONTENT_STR_BRACKETED = \"[\".concat(this.CONTENT_STR, \"]\");\n    this.CUE_ATTRIBUTES = [this.VIDEO_FRAME_STR, this.CONTENT_STR];\n    this.CUE_ATTRIBUTES_BRACKETED = [this.VIDEO_FRAME_STR_BRACKETED, this.CONTENT_STR_BRACKETED].join();\n    this.RESIZE_OBSERVER_BOX_OPTIONS = 'border-box';\n    this.callMeasure = false;\n    this.contentCollection = {};\n    this.videoFrame = null;\n    this.debouncedMeasure = debouncedFunction(function () {\n      return _this.measureInternal();\n    }, debounceTime);\n    this.resizeObserver = new ResizeObserver(function () {\n      return _this.measureDebounced();\n    });\n    this.getInitialElements();\n    this.mutationObserver = new MutationObserver(function (mutations) {\n      return _this.mutationCallback(mutations);\n    });\n    this.setupEventListeners();\n    this.observeMutations();\n    this.measureInternal();\n  }\n  /**\n   * Check if the content awareness logging is enabled.\n   *\n   * @returns Returns true if the content awareness logging is enabled otherwise false.\n   */\n\n\n  ContentAwareness.prototype.isLoggingEnabled = function () {\n    return this.logger.isEnabled;\n  };\n  /**\n   * Enable/disable content awareness logging\n   * @param enable - set true to enable content awareness log, false to disable\n   */\n\n\n  ContentAwareness.prototype.setLogging = function (enable) {\n    this.logger.enableLogging(enable);\n  };\n  /**\n   * Check minimal log level of content awareness.\n   *\n   * @returns Returns minimal log setting of content awareness, type is LogLevel.\n   */\n\n\n  ContentAwareness.prototype.getMinLogLevel = function () {\n    return this.logger.getMinLogLevel();\n  };\n  /**\n   * Set minimal log level of  content awareness logging.\n   * @param level - use LogLevel type to set minimal log level of  content awareness logging\n   */\n\n\n  ContentAwareness.prototype.setMinLogLevel = function (level) {\n    this.logger.setMinLogLevel(level);\n  };\n\n  ContentAwareness.prototype.setupEventListeners = function () {\n    var _this = this;\n\n    window.addEventListener('resize', function () {\n      return _this.measureDebounced();\n    });\n  };\n  /**\n   * Get initial elements, future elements will be added via mutation observer\n   */\n\n\n  ContentAwareness.prototype.getInitialElements = function () {\n    var _this = this;\n\n    var videoEl = document.querySelector(this.VIDEO_FRAME_STR_BRACKETED);\n    var contentElements = document.querySelectorAll(this.CONTENT_STR_BRACKETED);\n    this.trackVideoElement(videoEl);\n    Array.from(contentElements).map(function (element) {\n      return _this.trackContentElement(element);\n    });\n  };\n  /**\n   * Start watching for changes in the DOM that are relevant to\n   * ContentAwareness object tracking.\n   * @returns The ContentAwareness MutationObserver used for all content\n   */\n\n\n  ContentAwareness.prototype.observeMutations = function () {\n    var watchNode = document.documentElement || document.body; // Target node of DOM to watch\n\n    this.mutationObserver.observe(watchNode, {\n      attributeFilter: this.CUE_ATTRIBUTES,\n      attributeOldValue: true,\n      childList: true,\n      subtree: true // Monitor elements in child directories\n\n    });\n  };\n  /**\n   * Publicly accessible function to disconnect observers and event listeners\n   */\n\n\n  ContentAwareness.prototype.disconnect = function () {\n    var _this = this; // Disconnect observers\n\n\n    this.mutationObserver.disconnect();\n    this.resizeObserver.disconnect(); // Remove event listeners\n\n    window.removeEventListener('resize', function () {\n      return _this.measureDebounced();\n    }); // Reset scene\n\n    this.scene.contentAwareness = undefined;\n  };\n  /**\n   * Publicly accessible function to reconnect observers and event listeners\n   */\n\n\n  ContentAwareness.prototype.reconnect = function () {\n    // Restore the link between scene and ca\n    this.scene.contentAwareness = this;\n    this.observeMutations();\n    this.setupEventListeners();\n    this.measure();\n  };\n  /**\n   * Publicly accessible function to trigger measurement of CUE-relevant elements in the DOM\n   * and send an updateContentAwareness message\n   */\n\n\n  ContentAwareness.prototype.measure = function () {\n    this.measureInternal();\n  };\n\n  ContentAwareness.prototype.measureDebounced = function () {\n    this.debouncedMeasure();\n  };\n  /**\n   * measures data-sm-video and data-sm-content HTML Elements\n   *\n   * This is automatically called in simple scenarios but can be manually called\n   * if the dev knows an important element has changed\n   *\n   * See documentation on GitHub for further reference on how to use this API\n   * https://github.com/soulmachines/smwebsdk/blob/cue-content-awareness-api/guide/content-awareness.md\n   *\n   * Console logs the sent message on success or an error on failure\n   */\n\n\n  ContentAwareness.prototype.measureInternal = function () {\n    if (!this.scene.isConnected()) {\n      this.logger.log('error', 'ContentAwareness: Scene does not exist or is not connected yet');\n      return;\n    }\n\n    var windowSize = this.measureWindow();\n    var videoFrame = this.measureVideoFrame();\n    var contentCollection = this.measureContent();\n\n    if (windowSize && videoFrame && contentCollection) {\n      var contentAwarenessMessage = this.buildUpdateContentAwarenessRequest(windowSize.innerWidth, windowSize.innerHeight, videoFrame, contentCollection);\n      this.scene.sendRequest('updateContentAwareness', contentAwarenessMessage);\n    }\n  };\n  /**\n   * measure elements tagged with data-videoFrame\n   * @returns a ContentAwarenessObjectModel filled with\n   * videoFrame coordinates on success. returns null on failure\n   */\n\n\n  ContentAwareness.prototype.measureVideoFrame = function () {\n    if (!this.videoFrame) {\n      this.logger.log('warn', 'ContentAwareness: Unable to find a video element');\n      return null;\n    }\n\n    var videoRect = this.videoFrame.getBoundingClientRect();\n\n    if (this.invalidDimensions(videoRect)) {\n      this.logger.log('warn', 'ContentAwareness: Video has a zero width and height');\n      return null;\n    }\n\n    return {\n      x1: Math.round(videoRect.left),\n      x2: Math.round(videoRect.right),\n      y1: Math.round(videoRect.top),\n      y2: Math.round(videoRect.bottom)\n    };\n  };\n  /**\n   * measure elements tagged with data-content\n   * @returns a ContentAwarenessObjectModel array filled with the coordinates and\n   * ids of content tagged with the data-sm-content attribute\n   */\n\n\n  ContentAwareness.prototype.measureContent = function () {\n    var _this = this;\n\n    var validContent = [];\n    Object.keys(this.contentCollection).map(function (key) {\n      var contentElement = _this.contentCollection[key];\n      var contentRect = contentElement.getBoundingClientRect();\n\n      if (_this.invalidDimensions(contentRect)) {\n        _this.logger.log('warn', \"ContentAwareness: Element '\".concat(key, \"' has a zero width and height\"));\n      }\n\n      if (_this.invalidContent(contentRect)) {\n        _this.logger.log('warn', \"ContentAwareness: Element '\".concat(key, \"' is not being tracked\")); // Remove id from content collection but keep observers incase it changes\n\n\n        delete _this.contentCollection[key];\n        return;\n      }\n\n      validContent.push({\n        id: key,\n        x1: Math.round(contentRect.left),\n        x2: Math.round(contentRect.right),\n        y1: Math.round(contentRect.top),\n        y2: Math.round(contentRect.bottom)\n      });\n    });\n    return validContent;\n  };\n  /**\n   * Preliminary indication of if content dimensions are valid or not.\n   * Checks if the length and height are zero\n   * @param contentRect - the DOMRect to check\n   * @returns a bool indicating validity\n   */\n\n\n  ContentAwareness.prototype.invalidDimensions = function (contentRect) {\n    return contentRect.width === 0 && contentRect.height === 0;\n  };\n  /**\n   * Preliminary indication of if content is valid or not.\n   * Checks if the coordinates are non zero\n   * @param contentRect - the DOMRect to check\n   * @returns a bool indicating validity\n   */\n\n\n  ContentAwareness.prototype.invalidContent = function (contentRect) {\n    return contentRect.top === 0 && contentRect.bottom === 0 && contentRect.right === 0 && contentRect.left === 0;\n  };\n  /**\n   * measure the browser window\n   * @returns an object containing the window height (innerHeight) and window width (innerWidth)\n   */\n\n\n  ContentAwareness.prototype.measureWindow = function () {\n    return {\n      innerHeight: Math.round(window.innerHeight),\n      innerWidth: Math.round(window.innerWidth)\n    };\n  };\n  /**\n   * Builds the required UpdateContentAwareness message that gets sent to the server\n   *\n   * @param viewWidth - the width of the browser window\n   * @param viewHeight - the height of the browser window\n   * @param videoFrame - an object containing the coordinates of the video element in which the persona exists\n   * @param content - an array of objects containing the coordinates of the content elements the persona should be aware of\n   * @returns - UpdateContentAwarenessRequestBody the message body to send\n   *\n   * The return value from this function should be passed to\n   * scene.sendRequest('updateContentAwareness', body)\n   */\n\n\n  ContentAwareness.prototype.buildUpdateContentAwarenessRequest = function (viewWidth, viewHeight, videoFrame, content) {\n    return {\n      viewWidth: viewWidth,\n      viewHeight: viewHeight,\n      videoFrame: videoFrame,\n      content: content\n    };\n  };\n\n  ContentAwareness.prototype.trackVideoElement = function (element) {\n    if (!element) {\n      return;\n    }\n\n    if (this.videoFrame) {\n      this.logger.log('warn', 'ContentAwareness: Already observing a video element, switching to new video element');\n      this.untrackVideoElement(this.videoFrame);\n    }\n\n    this.videoFrame = element;\n    this.resizeObserver.observe(this.videoFrame, {\n      box: this.RESIZE_OBSERVER_BOX_OPTIONS\n    });\n  };\n\n  ContentAwareness.prototype.trackContentElement = function (element) {\n    var id = element.getAttribute(this.CONTENT_STR);\n\n    if (id) {\n      this.contentCollection[id] = element;\n      this.resizeObserver.observe(element, {\n        box: this.RESIZE_OBSERVER_BOX_OPTIONS\n      });\n      return true;\n    }\n\n    return false;\n  };\n\n  ContentAwareness.prototype.untrackContentElement = function (element) {\n    var id = element.getAttribute(this.CONTENT_STR);\n    var trackedElement = this.contentCollection[id]; // only untrack the element if the element we have stored\n    // against that id is the same one being requested for removal.\n    // this allows for showing/hiding of elements that use the same id.\n\n    if (element === trackedElement) {\n      delete this.contentCollection[id];\n      this.resizeObserver.unobserve(element);\n    }\n  };\n\n  ContentAwareness.prototype.untrackVideoElement = function (element) {\n    // Only clear the videoFrame element if its the same as the currently track video element.\n    // A mismatch can occur when adding/removing different video elements. If a new video element appears we'll switch and track that.\n    // If the remove event occurs after the switch we'll ignore it, as we don't want to untrack the newly added element\n    if (element === this.videoFrame) {\n      this.videoFrame = null;\n    } // Always unobserve the removed element\n\n\n    this.resizeObserver.unobserve(element);\n  };\n  /**\n   * Takes an array of MutationRecords and measures the ones marked with content awareness attributes\n   * @param mutations - an array of MutationRecords to check and measure\n   */\n\n\n  ContentAwareness.prototype.mutationCallback = function (mutations) {\n    var _this = this;\n\n    var imagesAdded = false;\n    this.callMeasure = false; // reset callMeasure\n\n    for (var i = 0; i < mutations.length; ++i) {\n      switch (mutations[i].type) {\n        case 'childList':\n          {\n            if (mutations[i].target.nodeType !== Node.ELEMENT_NODE) {\n              break;\n            }\n\n            this.untrackRemovedNodeWithCUE(mutations[i].removedNodes); // Unobserve and stop tracking removed elements\n\n            this.trackAddedNodeWithCUE(mutations[i].addedNodes); // Start tracking elements added elements\n\n            for (var j = 0; j < mutations[i].addedNodes.length; j++) {\n              try {\n                var element = mutations[i].addedNodes[j];\n\n                if (!element.hasAttribute) {\n                  // node is not an element, do not continue processing it\n                  continue;\n                }\n\n                var isImage = element.tagName === 'IMG';\n                var containsImages = !!element.querySelector('img');\n                imagesAdded = isImage || containsImages;\n\n                if (imagesAdded) {\n                  break;\n                }\n              } catch (err) {\n                this.logger.log('warn', 'ContentAwareness: Failed to track non-element node', mutations[i].addedNodes[j]);\n              }\n            }\n\n            break;\n          }\n\n        case 'attributes':\n          {\n            if (mutations[i].target.nodeType !== Node.ELEMENT_NODE) {\n              break;\n            }\n\n            try {\n              var element = mutations[i].target;\n              var attr = mutations[i].attributeName;\n\n              if (attr === this.VIDEO_FRAME_STR) {\n                if (element.hasAttribute(attr)) {\n                  this.trackVideoElement(element);\n                  this.callMeasure = true;\n                } else if (this.videoFrame) {\n                  this.untrackVideoElement(element);\n                }\n              } else if (attr === this.CONTENT_STR) {\n                var newValue = element.getAttribute(attr);\n                var oldValue = mutations[i].oldValue;\n\n                if (oldValue) {\n                  // data-sm-content attribute was changed and must be removed\n                  this.resizeObserver.unobserve(this.contentCollection[oldValue]);\n                  delete this.contentCollection[oldValue];\n                }\n\n                if (newValue) {\n                  // data-sm-content attribute value was changed/added and now must be added to the list\n                  this.contentCollection[newValue] = element;\n                  this.resizeObserver.observe(element, {\n                    box: this.RESIZE_OBSERVER_BOX_OPTIONS\n                  });\n                }\n\n                this.callMeasure = true;\n              }\n\n              break;\n            } catch (err) {\n              this.logger.log('warn', 'ContentAwareness: Failed to track non-element node', mutations[i].target);\n            }\n          }\n      }\n    }\n\n    if (this.callMeasure) {\n      if (imagesAdded) {\n        // Wait for all images to be loaded then remeasure\n        allImagesLoaded().then(function () {\n          _this.measureDebounced();\n        });\n      } else {\n        this.measureDebounced();\n      }\n    }\n  };\n\n  ContentAwareness.prototype.trackAddedNodeWithCUE = function (mutations) {\n    var _this = this;\n\n    mutations.forEach(function (node) {\n      try {\n        var element = node;\n\n        if (!element.hasAttribute) {\n          // node is not an element, do not continue processing it\n          return;\n        } // check top level node for cue attributes\n\n\n        if (element.hasAttribute(_this.VIDEO_FRAME_STR)) {\n          _this.trackVideoElement(element);\n\n          _this.callMeasure = true;\n        } else if (element.hasAttribute(_this.CONTENT_STR)) {\n          _this.callMeasure = _this.trackContentElement(element);\n        } // check child nodes for cue attributes\n\n\n        if (element.querySelector(_this.CUE_ATTRIBUTES_BRACKETED) !== null) {\n          element.querySelectorAll(_this.CUE_ATTRIBUTES_BRACKETED).forEach(function (childElement) {\n            if (childElement.hasAttribute(_this.VIDEO_FRAME_STR)) {\n              _this.trackVideoElement(childElement);\n\n              _this.callMeasure = true;\n            } else if (childElement.hasAttribute(_this.CONTENT_STR)) {\n              _this.callMeasure = _this.trackContentElement(childElement);\n            }\n          });\n        }\n      } catch (err) {\n        _this.logger.log('warn', 'ContentAwareness: Failed to track non-element node', node);\n      }\n    });\n  };\n\n  ContentAwareness.prototype.untrackRemovedNodeWithCUE = function (mutations) {\n    var _this = this;\n\n    mutations.forEach(function (node) {\n      try {\n        var element = node;\n\n        if (!element.hasAttribute) {\n          // node is not an element, do not continue processing it\n          return;\n        }\n\n        if (element.hasAttribute(_this.VIDEO_FRAME_STR)) {\n          _this.untrackVideoElement(element);\n        } else if (element.hasAttribute(_this.CONTENT_STR)) {\n          _this.untrackContentElement(element);\n\n          _this.callMeasure = true;\n        } // check child nodes for cue attributes\n\n\n        if (element.querySelector(_this.CUE_ATTRIBUTES_BRACKETED) !== null) {\n          element.querySelectorAll(_this.CUE_ATTRIBUTES_BRACKETED).forEach(function (childElement) {\n            if (childElement.hasAttribute(_this.VIDEO_FRAME_STR)) {\n              _this.untrackVideoElement(childElement);\n            } else if (childElement.hasAttribute(_this.CONTENT_STR)) {\n              _this.untrackContentElement(childElement);\n\n              _this.callMeasure = true;\n            }\n          });\n        }\n      } catch (err) {\n        _this.logger.log('warn', 'ContentAwareness: Failed to track non-element node', node);\n      }\n    });\n  };\n\n  return ContentAwareness;\n}();\n\nexport { ContentAwareness }; //# sourceMappingURL=ContentAwareness.js.map","map":null,"metadata":{},"sourceType":"module"}