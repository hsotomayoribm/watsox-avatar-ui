{"ast":null,"code":"// this file enables us to pass webRTC/mediaStream data outside of the redux store,\n// which we can't do because they're instances of classes, which are not serializeable\nimport { createAction } from '@reduxjs/toolkit';\nconst proxyVideo = document.createElement('video');\nexport default proxyVideo; // we need to create a copy of the action here, otherwise\n// it would create a dependency cycle and a seperate file doesn't seem worth it\n\nconst setCameraState = createAction('sm/setCameraState'); // ### handles webcam stream ###\n\nclass UserMediaStream {\n  constructor() {\n    var _this = this;\n\n    this.passDispatch = dispatch => {\n      this.dispatch = dispatch;\n    };\n\n    this.setUserMediaStream = function (stream) {\n      let audioOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      _this.videoOff = !audioOnly; // call passDispatch before this so we have access to store\n\n      if (_this.dispatch === null) throw new Error('call passDispatch() before setUserMediaStream()!'); // store stream data so we can access it later\n\n      if (stream !== null) _this.userMediaStream = stream; // try to get video stream dimensions, if it doesn't work, then we can presume\n      // that we don't have access to the webcam.\n\n      try {\n        // send webcam stream dimensions to store\n        const track = stream.getVideoTracks()[0];\n        const {\n          width: cameraWidth,\n          height: cameraHeight\n        } = track.getSettings();\n\n        _this.dispatch(setCameraState({\n          cameraOn: true,\n          cameraWidth,\n          cameraHeight\n        }));\n      } catch {\n        _this.dispatch(setCameraState({\n          cameraOn: false\n        }));\n      }\n    };\n\n    this.getUserMediaStream = () => this.userMediaStream;\n\n    this.enableToggle = scene => {\n      this.scene = scene;\n    };\n\n    this.toggleVideo = async () => {\n      if (this.scene !== null) {\n        const {\n          videoOff,\n          userMediaStream\n        } = this;\n        const track = userMediaStream.getVideoTracks()[0];\n\n        if (videoOff === false) {\n          track.stop();\n          this.videoOff = true;\n          this.dispatch(setCameraState({\n            cameraOn: false\n          }));\n        } else {\n          // we need to re-request the stream from the webcam after it's been stopped\n          const newVideoStreamGrab = await navigator.mediaDevices.getUserMedia({\n            video: true\n          }); // delete old track\n\n          this.userMediaStream.removeTrack(track); // add new track to media stream\n\n          this.userMediaStream.addTrack(newVideoStreamGrab.getVideoTracks()[0]); // ### THIS IS WHERE WE WOULD PROVIDE SCENE W/ THE NEW STREAM ###\n          // this.scene.session().userMediaStream = this.userMediaStream;\n\n          this.videoOff = false;\n          this.dispatch(setCameraState({\n            cameraOn: true\n          }));\n        }\n      }\n    };\n\n    this.userMediaStream = null;\n    this.videoOff = false;\n    this.dispatch = null;\n    this.scene = null;\n  } // use dispatch to tell redux state what camera state is\n  // should be called before setUserMediaStream so we can tell the store the stream's dimensions\n\n\n}\n\nexport const mediaStreamProxy = new UserMediaStream();","map":{"version":3,"names":["createAction","proxyVideo","document","createElement","setCameraState","UserMediaStream","constructor","passDispatch","dispatch","setUserMediaStream","stream","audioOnly","videoOff","Error","userMediaStream","track","getVideoTracks","width","cameraWidth","height","cameraHeight","getSettings","cameraOn","getUserMediaStream","enableToggle","scene","toggleVideo","stop","newVideoStreamGrab","navigator","mediaDevices","getUserMedia","video","removeTrack","addTrack","mediaStreamProxy"],"sources":["/Users/sofiaweinzierl/Desktop/sm-neuralseek-ibm/react-ui/src/proxyVideo.js"],"sourcesContent":["// this file enables us to pass webRTC/mediaStream data outside of the redux store,\n// which we can't do because they're instances of classes, which are not serializeable\nimport { createAction } from '@reduxjs/toolkit';\n\nconst proxyVideo = document.createElement('video');\n\nexport default proxyVideo;\n\n// we need to create a copy of the action here, otherwise\n// it would create a dependency cycle and a seperate file doesn't seem worth it\nconst setCameraState = createAction('sm/setCameraState');\n// ### handles webcam stream ###\nclass UserMediaStream {\n  constructor() {\n    this.userMediaStream = null;\n    this.videoOff = false;\n    this.dispatch = null;\n    this.scene = null;\n  }\n\n  // use dispatch to tell redux state what camera state is\n  // should be called before setUserMediaStream so we can tell the store the stream's dimensions\n  passDispatch = (dispatch) => {\n    this.dispatch = dispatch;\n  }\n\n  setUserMediaStream = (stream, audioOnly = false) => {\n    this.videoOff = !audioOnly;\n    // call passDispatch before this so we have access to store\n    if (this.dispatch === null) throw new Error('call passDispatch() before setUserMediaStream()!');\n    // store stream data so we can access it later\n    if (stream !== null) this.userMediaStream = stream;\n    // try to get video stream dimensions, if it doesn't work, then we can presume\n    // that we don't have access to the webcam.\n    try {\n      // send webcam stream dimensions to store\n      const track = stream.getVideoTracks()[0];\n      const { width: cameraWidth, height: cameraHeight } = track.getSettings();\n      this.dispatch(setCameraState({ cameraOn: true, cameraWidth, cameraHeight }));\n    } catch {\n      this.dispatch(setCameraState({ cameraOn: false }));\n    }\n  }\n\n  getUserMediaStream = () => this.userMediaStream;\n\n  // NOTE: renders emotional recognition nonfunctional, not recommended for use as of 7/14/21\n  // if we toggle video, we need to provide scene w/ the new feed\n  enableToggle = (scene) => {\n    this.scene = scene;\n  }\n\n  // NOTE: renders emotional recognition nonfunctional, not recommended for use as of 7/14/21\n  toggleVideo = async () => {\n    if (this.scene !== null) {\n      const { videoOff, userMediaStream } = this;\n      const track = userMediaStream.getVideoTracks()[0];\n\n      if (videoOff === false) {\n        track.stop();\n        this.videoOff = true;\n        this.dispatch(setCameraState({ cameraOn: false }));\n      } else {\n      // we need to re-request the stream from the webcam after it's been stopped\n        const newVideoStreamGrab = await navigator.mediaDevices.getUserMedia({\n          video: true,\n        });\n        // delete old track\n        this.userMediaStream.removeTrack(track);\n        // add new track to media stream\n        this.userMediaStream.addTrack(newVideoStreamGrab.getVideoTracks()[0]);\n        // ### THIS IS WHERE WE WOULD PROVIDE SCENE W/ THE NEW STREAM ###\n        // this.scene.session().userMediaStream = this.userMediaStream;\n        this.videoOff = false;\n        this.dispatch(setCameraState({ cameraOn: true }));\n      }\n    }\n  }\n}\n\nexport const mediaStreamProxy = new UserMediaStream();\n"],"mappings":"AAAA;AACA;AACA,SAASA,YAAT,QAA6B,kBAA7B;AAEA,MAAMC,UAAU,GAAGC,QAAQ,CAACC,aAAT,CAAuB,OAAvB,CAAnB;AAEA,eAAeF,UAAf,C,CAEA;AACA;;AACA,MAAMG,cAAc,GAAGJ,YAAY,CAAC,mBAAD,CAAnC,C,CACA;;AACA,MAAMK,eAAN,CAAsB;EACpBC,WAAW,GAAG;IAAA;;IAAA,KASdC,YATc,GASEC,QAAD,IAAc;MAC3B,KAAKA,QAAL,GAAgBA,QAAhB;IACD,CAXa;;IAAA,KAadC,kBAbc,GAaO,UAACC,MAAD,EAA+B;MAAA,IAAtBC,SAAsB,uEAAV,KAAU;MAClD,KAAI,CAACC,QAAL,GAAgB,CAACD,SAAjB,CADkD,CAElD;;MACA,IAAI,KAAI,CAACH,QAAL,KAAkB,IAAtB,EAA4B,MAAM,IAAIK,KAAJ,CAAU,kDAAV,CAAN,CAHsB,CAIlD;;MACA,IAAIH,MAAM,KAAK,IAAf,EAAqB,KAAI,CAACI,eAAL,GAAuBJ,MAAvB,CAL6B,CAMlD;MACA;;MACA,IAAI;QACF;QACA,MAAMK,KAAK,GAAGL,MAAM,CAACM,cAAP,GAAwB,CAAxB,CAAd;QACA,MAAM;UAAEC,KAAK,EAAEC,WAAT;UAAsBC,MAAM,EAAEC;QAA9B,IAA+CL,KAAK,CAACM,WAAN,EAArD;;QACA,KAAI,CAACb,QAAL,CAAcJ,cAAc,CAAC;UAAEkB,QAAQ,EAAE,IAAZ;UAAkBJ,WAAlB;UAA+BE;QAA/B,CAAD,CAA5B;MACD,CALD,CAKE,MAAM;QACN,KAAI,CAACZ,QAAL,CAAcJ,cAAc,CAAC;UAAEkB,QAAQ,EAAE;QAAZ,CAAD,CAA5B;MACD;IACF,CA7Ba;;IAAA,KA+BdC,kBA/Bc,GA+BO,MAAM,KAAKT,eA/BlB;;IAAA,KAmCdU,YAnCc,GAmCEC,KAAD,IAAW;MACxB,KAAKA,KAAL,GAAaA,KAAb;IACD,CArCa;;IAAA,KAwCdC,WAxCc,GAwCA,YAAY;MACxB,IAAI,KAAKD,KAAL,KAAe,IAAnB,EAAyB;QACvB,MAAM;UAAEb,QAAF;UAAYE;QAAZ,IAAgC,IAAtC;QACA,MAAMC,KAAK,GAAGD,eAAe,CAACE,cAAhB,GAAiC,CAAjC,CAAd;;QAEA,IAAIJ,QAAQ,KAAK,KAAjB,EAAwB;UACtBG,KAAK,CAACY,IAAN;UACA,KAAKf,QAAL,GAAgB,IAAhB;UACA,KAAKJ,QAAL,CAAcJ,cAAc,CAAC;YAAEkB,QAAQ,EAAE;UAAZ,CAAD,CAA5B;QACD,CAJD,MAIO;UACP;UACE,MAAMM,kBAAkB,GAAG,MAAMC,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC;YACnEC,KAAK,EAAE;UAD4D,CAApC,CAAjC,CAFK,CAKL;;UACA,KAAKlB,eAAL,CAAqBmB,WAArB,CAAiClB,KAAjC,EANK,CAOL;;UACA,KAAKD,eAAL,CAAqBoB,QAArB,CAA8BN,kBAAkB,CAACZ,cAAnB,GAAoC,CAApC,CAA9B,EARK,CASL;UACA;;UACA,KAAKJ,QAAL,GAAgB,KAAhB;UACA,KAAKJ,QAAL,CAAcJ,cAAc,CAAC;YAAEkB,QAAQ,EAAE;UAAZ,CAAD,CAA5B;QACD;MACF;IACF,CAhEa;;IACZ,KAAKR,eAAL,GAAuB,IAAvB;IACA,KAAKF,QAAL,GAAgB,KAAhB;IACA,KAAKJ,QAAL,GAAgB,IAAhB;IACA,KAAKiB,KAAL,GAAa,IAAb;EACD,CANmB,CAQpB;EACA;;;AAToB;;AAoEtB,OAAO,MAAMU,gBAAgB,GAAG,IAAI9B,eAAJ,EAAzB"},"metadata":{},"sourceType":"module"}