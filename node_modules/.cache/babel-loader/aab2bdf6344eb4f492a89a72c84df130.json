{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport * as metrics from '@opentelemetry/api-metrics';\nimport { AttributeHashMap } from './state/HashMap';\nimport { isObservableInstrument } from './Instruments';\n/**\n * The class implements {@link metrics.ObservableResult} interface.\n */\n\nvar ObservableResultImpl =\n/** @class */\nfunction () {\n  function ObservableResultImpl(_descriptor) {\n    this._descriptor = _descriptor;\n    /**\n     * @internal\n     */\n\n    this._buffer = new AttributeHashMap();\n  }\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n\n\n  ObservableResultImpl.prototype.observe = function (value, attributes) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n\n    if (this._descriptor.valueType === metrics.ValueType.INT && !Number.isInteger(value)) {\n      api.diag.warn(\"INT value type cannot accept a floating-point value for \" + this._descriptor.name + \", ignoring the fractional digits.\");\n      value = Math.trunc(value);\n    }\n\n    this._buffer.set(attributes, value);\n  };\n\n  return ObservableResultImpl;\n}();\n\nexport { ObservableResultImpl };\n/**\n * The class implements {@link metrics.BatchObservableCallback} interface.\n */\n\nvar BatchObservableResultImpl =\n/** @class */\nfunction () {\n  function BatchObservableResultImpl() {\n    /**\n     * @internal\n     */\n    this._buffer = new Map();\n  }\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n\n\n  BatchObservableResultImpl.prototype.observe = function (metric, value, attributes) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n\n    if (!isObservableInstrument(metric)) {\n      return;\n    }\n\n    var map = this._buffer.get(metric);\n\n    if (map == null) {\n      map = new AttributeHashMap();\n\n      this._buffer.set(metric, map);\n    }\n\n    if (metric._descriptor.valueType === metrics.ValueType.INT && !Number.isInteger(value)) {\n      api.diag.warn(\"INT value type cannot accept a floating-point value for \" + metric._descriptor.name + \", ignoring the fractional digits.\");\n      value = Math.trunc(value);\n    }\n\n    map.set(attributes, value);\n  };\n\n  return BatchObservableResultImpl;\n}();\n\nexport { BatchObservableResultImpl }; //# sourceMappingURL=ObservableResult.js.map","map":null,"metadata":{},"sourceType":"module"}