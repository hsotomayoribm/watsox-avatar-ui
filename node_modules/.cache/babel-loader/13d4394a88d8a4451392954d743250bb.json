{"ast":null,"code":"/**\n * @module smwebsdk\n */\nimport { __assign, __awaiter, __generator, __values } from \"tslib\";\n/*\n * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.\n */\n\nimport { Deferred } from './Deferred';\nimport { Features } from './Features';\nimport { UserMedia } from './types/scene';\nimport { makeError } from './utils/make-error';\nimport { ConnectionStateTypes } from './enums/ConnectionStateTypes'; // Reexporting here to keep backwards compatibility\n\nexport { UserMedia } from './types/scene';\n/**\n *  Session class\n */\n\nvar Session =\n/** @class */\nfunction () {\n  function Session(videoElement, serverUri, connectUserText, accessToken, audioOnly, requestedUserMedia, requiredUserMedia, echoCancellationEnabled, logger, connectionState) {\n    var _this = this; // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n    this._connectPendingRemoteStream = null;\n    this._resumeRequested = false;\n    this._isResumedSession = false;\n    this._outgoingQueue = [];\n    this._controlOpen = false;\n    this._controlQueue = [];\n    this._requestedUserMedia = UserMedia.None;\n    this._requiredUserMedia = UserMedia.None;\n\n    this._onConnected = function (resumeRequested, isResumedSession, server, sessionId // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) {};\n\n    this._pendingLog = [];\n    this._closed = false;\n    this._shouldLogToServer = false; // Duration that microphone mute is maintained by the web sdk after the persona has\n    // finished speaking.  Set to -1 to disable.  Default value is -1 (disabled) if not specified\n    // by server in 'established' message.\n\n    this._microphoneMuteDelay = -1;\n    this._changeUserMediaQueue = new Array();\n    this._removeListeners = new Array();\n    this._videoOptions = {\n      frameRate: 10.0,\n      width: 640.0,\n      height: 480.0,\n      facingMode: 'user'\n    }; // TypeScript support to MediaTrackConstraints is not complete, thus using any here\n\n    this._audioOptions = {\n      noiseSuppression: false,\n      autoGainControl: false,\n      channelCount: 1,\n      sampleRate: 16000,\n      sampleSize: 16,\n      echoCancellation: true\n    };\n    this._videoElement = videoElement;\n    this._serverUri = serverUri;\n    this._connectUserText = connectUserText || '';\n    this._accessToken = accessToken;\n    this._audioOnly = audioOnly;\n    this._audioOptions.echoCancellation = echoCancellationEnabled;\n    this._requiredUserMedia = requiredUserMedia;\n    this._requestedUserMedia = requestedUserMedia;\n    this._logger = logger; // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n    this._onClose = function (reason) {}; // owner specifies custom close method\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    this._onMessage = function (message) {}; // owner specifies custom message handler\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    this._onUserText = function (text) {}; // owner specifies custom rtc user text message handler\n\n\n    this._sessionError = function (error) {\n      // owner can specify custom session error handler\n      _this.log(\"session error: \".concat(error), 'error');\n    };\n\n    this._features = new Features();\n    this._connectionState = connectionState;\n  }\n\n  Object.defineProperty(Session.prototype, \"onConnected\", {\n    set: function (sessionFunction) {\n      this._onConnected = sessionFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"onClose\", {\n    set: function (closeFunction) {\n      this._onClose = closeFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"onMessage\", {\n    set: function (messageFunction) {\n      this._onMessage = messageFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"onUserText\", {\n    set: function (userTextFunction) {\n      this._onUserText = userTextFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"loggingEnabled\", {\n    /**\n     * @deprecated use Scene method\n     */\n    get: function () {\n      return this._logger.isEnabled;\n    },\n\n    /**\n     * @deprecated use Scene\n     */\n    set: function (enable) {\n      this.log('loggingEnabled is deprecated and will be removed in a future version. Please use setLogging(boolean)', 'warn');\n\n      this._logger.enableLogging(enable);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @deprecated use Scene method\n   */\n\n  Session.prototype.setMinLogLevel = function (level) {\n    this._logger.setMinLogLevel(level);\n  };\n  /**\n   * @deprecated use Scene method\n   */\n\n\n  Session.prototype.setLogging = function (enable) {\n    this._logger.enableLogging(enable);\n  };\n\n  Session.prototype.log = function (text, level) {\n    if (level === void 0) {\n      level = 'debug';\n    }\n\n    if (this._logger.isEnabled) {\n      var now = new Date();\n      var msg = \"smsdk: \".concat(now.toISOString(), \": \").concat(text);\n\n      if (this._shouldLogToServer) {\n        this.logToServer(msg);\n      }\n\n      this._logger.log(level, msg);\n    }\n  };\n\n  Session.prototype.logToServer = function (msg) {\n    if (this.sessionId) {\n      this.sendlogMessage([msg]);\n    } else {\n      this._pendingLog.push(msg);\n    }\n  };\n\n  Session.prototype.sendlogMessage = function (textArray) {\n    if (this._sessionId && textArray && textArray.length > 0) {\n      var payload = {\n        category: 'diagnostics',\n        kind: 'event',\n        name: 'log',\n        body: {\n          name: 'browser',\n          text: textArray\n        }\n      };\n      this.sendMessage(payload);\n    }\n  };\n\n  Session.prototype.connect = function (userText) {\n    return __awaiter(this, void 0, void 0, function () {\n      var deferred, xhr;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        deferred = new Deferred();\n        this._closed = false;\n\n        if (userText) {\n          this._connectUserText = userText;\n        }\n\n        if (this._serverUri && (this._serverUri.startsWith('ws:') || this._serverUri.startsWith('wss:'))) {\n          // A server uri has been specified, continue with the connection\n          // by acquiring user media (microphone/camera) as needed\n          this.selectUserMedia(this._requestedUserMedia, this._requiredUserMedia, deferred, this.getUserMediaSuccess.bind(this));\n          return [2\n          /*return*/\n          , deferred.promise];\n        }\n\n        xhr = new XMLHttpRequest();\n        xhr.open('GET', '/api/jwt' + window.location.search);\n\n        xhr.onreadystatechange = function (ev) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var response;\n            return __generator(this, function (_a) {\n              if (xhr.readyState === XMLHttpRequest.DONE) {\n                if (xhr.status === 200) {\n                  this.log(\"JWT request returned: \".concat(xhr.responseText));\n                  response = JSON.parse(xhr.responseText);\n                  this._serverUri = response.url;\n                  this._accessToken = response.jwt;\n                  this.selectUserMedia(this._requestedUserMedia, this._requiredUserMedia, deferred, this.getUserMediaSuccess.bind(this));\n                } else {\n                  this.log(\"JWT Request failed, status: \".concat(xhr.statusText), 'error');\n                  deferred.reject(makeError('Failed to acquire jwt at /api/jwt', 'noServer'));\n                }\n              }\n\n              return [2\n              /*return*/\n              ];\n            });\n          });\n        };\n\n        xhr.send();\n        return [2\n        /*return*/\n        , deferred.promise];\n      });\n    });\n  };\n\n  Session.prototype.webcamRequested = function (requestedMedia, requiredMedia) {\n    return !this._audioOnly && [UserMedia.MicrophoneAndCamera, UserMedia.Camera].some(function (r) {\n      return [requestedMedia, requiredMedia].includes(r);\n    });\n  };\n\n  Session.prototype.micRequested = function (requestedMedia, requiredMedia) {\n    return [UserMedia.Microphone, UserMedia.MicrophoneAndCamera].some(function (r) {\n      return [requestedMedia, requiredMedia].includes(r);\n    });\n  };\n\n  Session.prototype.getMediaConstraints = function (requestedMedia, requiredMedia) {\n    // checking supported constraints only for debugging purpose, no need to use it when applying constraints\n    // as providing specific values for constraints, means they are a 'best effort' rather than required\n    // https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API/Constraints#requesting_a_specific_value_for_a_setting\n    var supports = navigator.mediaDevices.getSupportedConstraints();\n    this.log(\"Browser supports media constraints: \".concat(supports));\n    return {\n      audio: this.micRequested(requestedMedia, requiredMedia) ? this.buildAudioOptions() : false,\n      video: this.webcamRequested(requestedMedia, requiredMedia) ? this._videoOptions : false\n    };\n  };\n\n  Session.prototype.buildAudioOptions = function () {\n    var supportedConstraints = navigator.mediaDevices.getSupportedConstraints();\n\n    var constraints = __assign({}, this._audioOptions); // Remove unknown and unsupported constraints, as these were causing errors in the latest version on Safari\n\n\n    Object.keys(constraints).forEach(function (constraint) {\n      if (!supportedConstraints[constraint]) {\n        delete constraints[constraint];\n      }\n    });\n    return constraints;\n  };\n\n  Session.prototype.selectUserMedia = function (requestedMedia, requiredMedia, deferred, completion) {\n    var _this = this;\n\n    if (requestedMedia === UserMedia.None && requiredMedia === UserMedia.None) {\n      // no microphone or camera is required or requested\n      completion(null, deferred);\n      return;\n    }\n\n    if (navigator.mediaDevices.getUserMedia) {\n      var constraints = this.getMediaConstraints(requestedMedia, requiredMedia);\n      this.log(\"Best video constraints: \".concat(constraints));\n      navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n        completion(stream, deferred);\n      }).catch(function (error) {\n        //fail when required media wasn't obtained\n        if (requiredMedia === requestedMedia) {\n          _this.log(\"getUserMedia could not get required media, error given: \".concat(error), 'error');\n\n          deferred.reject(_this.MakeErrorForUserMedia(error));\n        } //re-try required media fallback\n        else if (requiredMedia !== UserMedia.None) {\n          _this.getUserMediaRequiredOnlyFallback(requiredMedia, deferred, completion);\n        } //re-try mic only fallback\n        else if (requestedMedia === UserMedia.MicrophoneAndCamera) {\n          _this.getUserMediaAudioOnlyFallback(deferred, completion);\n        } //complete without a stream\n        else {\n          completion(null, deferred);\n        }\n      });\n    } else {\n      deferred.reject(makeError('Your browser does not support getUserMedia API', 'notSupported'));\n    }\n  };\n\n  Session.prototype.getUserMediaRequiredOnlyFallback = function (requiredMedia, deferred, completion) {\n    var _this = this;\n\n    this.log('Retrying with required media only');\n    var constraints = this.getMediaConstraints(UserMedia.None, requiredMedia);\n    this.log(\"Attempt constraints: \".concat(constraints));\n    return navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n      completion(stream, deferred);\n    }).catch(function (error) {\n      _this.log(\"getUserMedia could not get required media, error given: \".concat(error), 'error'); //fail when required media wasn't obtained\n\n\n      deferred.reject(_this.MakeErrorForUserMedia(error));\n    });\n  };\n\n  Session.prototype.getUserMediaAudioOnlyFallback = function (deferred, completion) {\n    var _this = this;\n\n    this.log('Retrying with microphone only');\n    var constraints = {\n      video: false,\n      audio: this.buildAudioOptions()\n    };\n    this.log(\"Attempt constraints: \".concat(constraints));\n    return navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n      completion(stream, deferred);\n    }).catch(function (error) {\n      _this.log(\"getUserMedia could not get microphone audio, error given: \".concat(error), 'error'); // still succeed as fallback is only tried if media was required, not requested\n\n\n      completion(null, deferred);\n    });\n  };\n\n  Session.prototype.MakeErrorForUserMedia = function (error) {\n    var name = 'noUserMedia'; // Returning more specific errors below is considered a breaking change which we\n    // cannot accommodate currently. This will be reinstated in the future, likely for v15\n    // At that time, the error codes in Scene.connect() and scene.setMediaDeviceActive() need re-documenting -\n    // see https://github.com/soulmachines/smwebsdk/blob/dfe3e1dc8d57aac17cb0be38fa2527190cd78ef4/src/Scene.ts#L916-L918\n    // if (error.name === 'NotAllowedError' || error.name === 'SecurityError') {\n    //   name = 'userMediaNotAllowed';\n    // } else if (\n    //   error.name === 'AbortError' ||\n    //   error.name === 'NotReadableError'\n    // ) {\n    //   name = 'userMediaFailed';\n    // }\n\n    return makeError(error.message, name);\n  };\n\n  Session.prototype.getUserMediaSuccess = function (stream, deferred) {\n    var _this = this;\n\n    this.log('Got user media');\n    this._localStream = stream;\n    this.microphoneMuted = true; // mute the local microphone until the DP is visible\n    // Connect to the session server\n    // To pass the Json Web Token (jwt) to the server when opening the websocket\n    // we basically have three options with the available javascript api:\n    // 1) pass as a 'access_token' query parameter similar to auth2 bearer tokens when not auth header\n    // 2) pass as basic auth user/pass embedded in the url\n    // 3) pass as a custom protocol which is translated into the 'Sec-WebSocket-Protocol' request header\n    //    more info here: https://stackoverflow.com/questions/4361173/http-headers-in-websockets-client-api\n    // We've gone with using a query parameter with ssl.\n    // create and connect the websocket\n    // Note that javscript websockets do not allow most request headers to be set.  The two exceptions\n    // are the Authorization header (via basic auth) and the protocol header - neither of which\n    // are ideal for our jwt token.  Hence instead we pass the jwt as a query parameter.\n\n    this.log(\"connecting to: \".concat(this._serverUri));\n\n    if (!this._accessToken) {\n      this._serverConnection = new WebSocket(this._serverUri);\n    } else {\n      this._serverConnection = new WebSocket(this._serverUri + '?access_token=' + this._accessToken);\n    }\n\n    this._serverConnection.onmessage = function (msg) {\n      try {\n        _this.gotMessageFromServer(msg, deferred);\n      } catch (e) {\n        _this.log(\"unexpected exception processing received message: \".concat(e), 'error');\n      }\n    };\n\n    this._serverConnection.onerror = function (event) {\n      if (deferred.isPending()) {\n        deferred.reject(makeError('websocket failed', 'serverConnectionFailed'));\n      }\n    }; // wait for the websocket to open, then continue with setup\n\n\n    this._serverConnection.onopen = function (event) {\n      _this.log('Websocket open'); // wait for the welcome 'established' message to receive the ice servers, hence nothing more to do here\n      // websocket open - searching for an available DP scene, may require queuing\n\n\n      _this._connectionState.setConnectionState(ConnectionStateTypes.SearchingForDigitalPerson);\n    }; // setup a close handler\n\n\n    this._serverConnection.onclose = function (event) {\n      _this.log(\"websocket closed: code(\".concat(event.code, \"), reason(\").concat(event.reason, \"), clean(\").concat(event.wasClean, \")\"));\n\n      if (!deferred.isRejected) {\n        _this.close(false, 'normal', deferred);\n      }\n    };\n  };\n\n  Session.prototype.hasTurnServer = function (iceServers) {\n    var e_1, _a, e_2, _b; // Check for at least one turn server by url in the array of ice servers\n\n\n    if (!iceServers) {\n      return false;\n    }\n\n    try {\n      for (var iceServers_1 = __values(iceServers), iceServers_1_1 = iceServers_1.next(); !iceServers_1_1.done; iceServers_1_1 = iceServers_1.next()) {\n        var server = iceServers_1_1.value;\n\n        if (!server || !server.urls) {\n          continue;\n        }\n\n        try {\n          for (var _c = (e_2 = void 0, __values(server.urls)), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var url = _d.value;\n\n            if (url.indexOf('turn:') === 0) {\n              return true;\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iceServers_1_1 && !iceServers_1_1.done && (_a = iceServers_1.return)) _a.call(iceServers_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return false;\n  };\n\n  Session.prototype.gotMessageFromServer = function (websocket_message, deferred) {\n    var _this = this;\n\n    var _a, _b;\n\n    var raw_text = websocket_message.data;\n    this.log(\"message received: \".concat(raw_text));\n    var message = JSON.parse(raw_text);\n    var category = message.category;\n    var name = message.name;\n    var body = message.body;\n\n    if (category !== 'webrtc') {\n      // If there is a control connection then forward 'scene' messages to that\n      if (this._controlConnection !== null && category === 'scene') {\n        if (this._controlOpen && this._serverConnection.readyState === WebSocket.OPEN) {\n          this._controlConnection.send(raw_text);\n        } else {\n          this._controlQueue.push(raw_text);\n        }\n      } // forward on non-webrtc messages (e.g. scene)\n\n\n      this._onMessage(message);\n\n      return;\n    }\n\n    if (message.kind !== 'event') {\n      // currently ignore requests and responses\n      return;\n    }\n\n    if (name === 'established') {\n      // established - scene is available/found, downloading/preparing DP assets on the server\n      this._connectionState.setConnectionState(ConnectionStateTypes.DownloadingAssets); // Create the peer connection configuration from the established body\n      // which includes the ice servers we should use\n\n\n      var config = {\n        iceServers: []\n      };\n\n      if (body.iceServers) {\n        config.iceServers = body.iceServers; // If at least one ice server is a turn server then force\n        // our traffic to route over turn (relay)\n\n        if (this.hasTurnServer(body.iceServers)) {\n          this.log('Detected turn server, forcing relay mode');\n          config.iceTransportPolicy = 'relay';\n        }\n      }\n\n      this.log(\"selected ice servers: \".concat(config.iceServers));\n\n      if (body.settings && typeof body.settings.microphoneMuteDelay === 'number') {\n        this._microphoneMuteDelay = body.settings.microphoneMuteDelay;\n      }\n\n      this.log(\"microphone mute delay after persona speech: \".concat(this._microphoneMuteDelay)); // Send logging to server if requested by the server\n\n      this._shouldLogToServer = (_b = (_a = body.settings) === null || _a === void 0 ? void 0 : _a.logToServer) !== null && _b !== void 0 ? _b : false; // Setup the WebRTC peer connection\n\n      this._peerConnection = new RTCPeerConnection(config); // ref: Ice candidate will only trigger when media video is enabled in Safari\n      // https://stackoverflow.com/a/53914556\n\n      this._peerConnection.onicecandidate = this.gotIceCandidate.bind(this);\n\n      if ('ontrack' in this._peerConnection && !this._features.isEdge) {\n        // todo update when angular 7\n        // This doesnt work with angular yet because of old definitions\n        // this._peerConnection.ontrack = (event:RTCTrackEvent)=>{\n        this._peerConnection.ontrack = function (event) {\n          if (event.track.kind === 'video' || event.track.kind === 'audio') {\n            if (!_this._remoteStream || !_this._audioOnly && event.track.kind === 'video') {\n              _this.onRemoteStream(event.streams[0]);\n            }\n          }\n        }; // Attach a video loaded event so the server can be notified when the video is\n        // ready to start playing\n\n\n        this._videoElement.addEventListener('loadeddata', this.onVideoLoaded.bind(this));\n\n        this._removeListeners.push({\n          target: this._videoElement,\n          name: 'loadeddata',\n          callback: this.onVideoLoaded\n        });\n      } else {\n        // fallback to stream (for IE/Safari plugin)\n        // onaddstream is deprecated\n        // This feature has been removed from the Web standards.\n        // Though some browsers may still support it, it is in the process of being dropped.\n        // Writing like this to pass type checking as this isnt in current spec and therefore\n        // neither the type definitions\n        this._peerConnection.onaddstream = function ( // as any because MediaStreamEvent has been removed from lib.dom.d.ts\n        streamEvent) {\n          _this.onRemoteStream(streamEvent.stream);\n        };\n      }\n\n      this._peerConnection.oniceconnectionstatechange = function (e) {\n        // `this._peerConnection.iceConnectionState === 'disconnected'` is quite handy\n        _this.log(\"ICE connection state: \".concat(_this._peerConnection.iceConnectionState));\n\n        if (_this._peerConnection.iceConnectionState === 'failed') {\n          makeError('ice connection failed', 'mediaStreamFailed');\n\n          if (deferred && deferred.isPending()) {\n            // Close the connection and reject the connect()\n            _this._serverConnection.close();\n\n            if (_this._controlConnection && (_this._controlConnection.readyState === WebSocket.OPEN || _this._controlConnection.readyState === WebSocket.CONNECTING)) {\n              _this._controlConnection.close();\n            }\n\n            deferred.reject(makeError('ice connection failed', 'mediaStreamFailed'));\n          }\n        }\n      };\n\n      this.log('adding local media stream if any');\n\n      if (this._localStream) {\n        if (!this._peerConnection.addTrack) {\n          this._peerConnection.addStream(this._localStream);\n\n          this.log('adding local media stream by stream');\n        } else {\n          try {\n            this.log('adding local media stream by track');\n\n            this._localStream.getTracks().forEach(function (track) {\n              _this._peerConnection.addTrack(track, _this._localStream);\n            });\n          } catch (e) {\n            this.log(\"error: \".concat(e), 'error');\n          }\n        }\n      } // Add an audio and video transceiver that are send and receive,\n      // regardless of whether the user microphone / camera is currently\n      // available.\n\n\n      this._peerConnection.addTransceiver('audio', {\n        direction: 'sendrecv'\n      });\n\n      this._peerConnection.addTransceiver('video', {\n        direction: 'sendrecv'\n      }); // create updateOffer if resumeSessionId exists\n\n\n      if (body.resumeSessionId) {\n        var offerOptions = {\n          voiceActivityDetection: false,\n          iceRestart: true\n        };\n        this._sessionId = body.resumeSessionId;\n        this._isResumedSession = true;\n        this.log(\"established, trying to resume session with session_id = \".concat(body.resumeSessionId));\n        this.createOffer(this._peerConnection, offerOptions).then(function (sessionDescription) {\n          _this.createdDescription.bind(_this);\n\n          _this.createdDescription(sessionDescription, 'updateOffer');\n        }).catch(this._sessionError.bind(this));\n      } else {\n        // Create a webrtc offer\n        var offerOptions = {\n          voiceActivityDetection: false,\n          iceRestart: false\n        };\n        this._isResumedSession = false;\n        this.createOffer(this._peerConnection, offerOptions).then(this.createdDescription.bind(this)).catch(this._sessionError.bind(this));\n      }\n    } else if (name === 'accepted') {\n      // accepted - DP is starting / forming webrtc connection\n      this._connectionState.setConnectionState(ConnectionStateTypes.ConnectingToDigitalPerson);\n\n      this.log(\"accepted, session_id = \".concat(body.sessionId));\n      this._sessionId = body.sessionId;\n      this._resumeRequested = body.resumeRequested;\n      this._server = body.server;\n      this._sceneId = body.sceneId; // The session has been accepted, send any outgoing queued messages\n\n      for (var i = 0; i < this._outgoingQueue.length; i++) {\n        this._outgoingQueue[i].body.sessionId = this._sessionId;\n        this.sendMessage(this._outgoingQueue[i]);\n      }\n\n      this._outgoingQueue = []; // Monitor for orientation change events to update the camera rotation\n\n      var callback = function () {\n        if (_this) {\n          _this.sendCameraRotation();\n        }\n      };\n\n      window.addEventListener('orientationchange', callback);\n\n      this._removeListeners.push({\n        target: window,\n        name: 'orientationchange',\n        callback: callback\n      });\n\n      this.sendCameraRotation();\n      var view = document.defaultView || window;\n      var style = view.getComputedStyle(this._videoElement);\n      var video_width = parseInt(\"\".concat(style.width), 10); // cs check changed frm this.videoElement\n\n      var video_height = parseInt(\"\".concat(style.height), 10);\n      this.log(\"accepted, sending video width/height: \".concat(video_width, \" / \").concat(video_height));\n      this.sendVideoBounds(video_width, video_height); // Send all pending log messages\n\n      this.sendlogMessage(this._pendingLog);\n      this._pendingLog = []; // Check whether the the server needs us to route control messages to the\n      // orchestration server.\n\n      if (body.controlUrl) {\n        this._controlUrl = body.controlUrl;\n        this._controlQueue = [];\n        this._controlOpen = false;\n        this._controlConnection = new WebSocket(body.controlUrl + '?access_token=' + this._accessToken);\n\n        this._controlConnection.onmessage = function (msg) {\n          var raw_text = msg.data;\n\n          if (raw_text) {\n            // forward this message to the session server\n            if (_this._serverConnection.readyState === WebSocket.OPEN) {\n              _this._serverConnection.send(raw_text);\n            }\n          }\n        };\n\n        this._controlConnection.onerror = function () {\n          _this.close(true, 'controlFailed', deferred);\n        }; // wait for the websocket to open, then continue with setup\n\n\n        this._controlConnection.onopen = function (event) {\n          _this.log('control websocket open');\n\n          if (!_this._controlOpen) {\n            _this._controlOpen = true; // send any pending orchestration/control messages in the order they were received\n\n            for (var i = 0; i < _this._controlQueue.length; i++) {\n              _this.log(\"control websocket now open, forwarding queued message: \".concat(_this._controlQueue[i]));\n\n              _this._controlConnection.send(_this._controlQueue[i]);\n            }\n\n            _this._controlQueue = [];\n          }\n        }; // setup a close handler\n\n\n        this._controlConnection.onclose = function (event) {\n          _this.log(\"control closed: code(\".concat(event.code, \"), reason(\").concat(event.reason, \"), clean(\").concat(event.wasClean, \")\"));\n\n          _this.close(true, 'controlDisconnected', deferred);\n        };\n      }\n    } else if (name === 'answer') {\n      this.log('set remote description');\n      this.log(JSON.stringify(body));\n      var sessionDescription = {\n        sdp: body.sdp,\n        type: 'answer'\n      };\n      this.setRemoteDescription(this._peerConnection, sessionDescription).then(function () {// Currently there's nothing to do\n      }).catch(this._sessionError.bind(this));\n    } else if (name === 'connected') {\n      if (this._remoteStream) {\n        // connected - DP is started and ready the webrtc session has connected\n        this._connectionState.setConnectionState(ConnectionStateTypes.Connected);\n\n        this.onConnectedSuccess();\n\n        if (deferred) {\n          deferred.resolve(body.sessionId);\n        }\n      } else {\n        this.log('Connected but no remote media stream available'); // The remote stream has not connected yet, give it more time to connect\n\n        this._connectPendingRemoteStream = function () {\n          _this.onConnectedSuccess();\n\n          if (deferred) {\n            deferred.resolve(body.sessionId);\n          }\n        };\n      }\n    } else if (name === 'ice') {\n      this.log('add ice candidate');\n      var addCandidate = void 0;\n\n      if (body.complete) {\n        if (this._features.isEdge) {\n          addCandidate = this._peerConnection.addIceCandidate(new RTCIceCandidate({\n            candidate: '',\n            sdpMid: '',\n            sdpMLineIndex: 0\n          }));\n        }\n      } else {\n        var iceCandidate = new RTCIceCandidate({\n          candidate: body.candidate,\n          sdpMid: body.sdpMid,\n          sdpMLineIndex: body.sdpMLineIndex\n        });\n        addCandidate = this._peerConnection.addIceCandidate(iceCandidate);\n      }\n\n      if (addCandidate) {\n        addCandidate.catch(this._sessionError.bind(this));\n      }\n    } else if (name === 'offer') {\n      // NB: For calls inbound to browser, currently not used\n      //     Perhaps we might use this for queueing to talk to an avatar?\n      this._sessionId = body.sessionId;\n      var sessionDescription = {\n        sdp: body.sdp,\n        type: 'offer'\n      };\n      this.setRemoteDescription(this._peerConnection, sessionDescription) // Create an answer in response to the offer\n      .then(function () {\n        return _this.createAnswer(_this._peerConnection);\n      }).then(this.createdDescription.bind(this)).catch(this._sessionError.bind(this));\n    } else if (name === 'userText') {\n      this.log(\"rtc - user text message received: \".concat(body.userText));\n\n      this._onUserText(body.userText);\n    } else if (name === 'close') {\n      this.close(false, body.reason, deferred);\n    }\n  };\n\n  Session.prototype.gotIceCandidate = function (event) {\n    if (event.candidate) {\n      this.log('got local ice candidate'); // Note we name each ice field as the IE/Safari plugin doesn't reflect these for json serialization\n\n      this.sendRtcEvent('ice', {\n        complete: false,\n        candidate: event.candidate.candidate,\n        sdpMid: event.candidate.sdpMid,\n        sdpMLineIndex: event.candidate.sdpMLineIndex\n      });\n    } else {\n      this.log('end ice candidate'); // all ice candidates have been gathered, send an end of ice notification\n\n      this.sendRtcEvent('ice', {\n        complete: true,\n        candidate: '',\n        sdpMid: '',\n        sdpMLineIndex: 0\n      });\n    }\n  };\n\n  Session.prototype.createdDescription = function (description, messageName) {\n    var _this = this;\n\n    if (messageName === void 0) {\n      messageName = 'offer';\n    }\n\n    this.log('got description'); // Note we name each ice field as the IE/Safari plugin doesn't  reflect these for json serialization\n\n    var descriptionObj = {\n      sdp: description.sdp,\n      type: description.type\n    };\n    this.log(JSON.stringify({\n      sdp: descriptionObj\n    }));\n    this.setLocalDescription(this._peerConnection, description).then(function () {\n      // Note with the sdp offer information we also send the\n      // current video element width/height to remote end when\n      // setting up webrtc session so that it can send the best\n      // width/height\n      _this.log('send sdp offer to server'); // Note we name each sdp field as the IE/Safari plugin doesn't  reflect these for json serialization\n\n\n      _this.sendRtcEvent(messageName, {\n        sdp: _this._peerConnection.localDescription ? _this._peerConnection.localDescription.sdp : null,\n        type: _this._peerConnection.localDescription ? _this._peerConnection.localDescription.type : null,\n        user_text: _this._connectUserText,\n        features: {\n          videoStartedEvent: true\n        }\n      });\n    }).catch(this._sessionError.bind(this));\n  };\n\n  Session.prototype.onRemoteStream = function (stream) {\n    this.log('got remote stream');\n    this._remoteStream = stream;\n    this.log(\"ICE connection state: \".concat(this._peerConnection.iceConnectionState));\n\n    if (this._connectPendingRemoteStream) {\n      // A connect has been received however it has been paused while\n      // we waited for the remote stream - continue it now\n      this._connectPendingRemoteStream();\n\n      this._connectPendingRemoteStream = null;\n    }\n  };\n\n  Session.prototype.onConnectedSuccess = function () {\n    var _this = this;\n\n    var _a, _b;\n\n    this._onConnected(this._resumeRequested, this._isResumedSession, this._server, this.sessionId);\n\n    this._videoElement.hidden = false; // remote video stream\n\n    this._videoElement.srcObject = this._remoteStream;\n\n    var callback = function (event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          if (this._remoteStream) {\n            this._remoteStream.addTrack(event.track);\n          }\n\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    };\n\n    this._peerConnection.addEventListener('track', callback);\n\n    this._removeListeners.push({\n      target: this._peerConnection,\n      name: 'track',\n      callback: callback\n    });\n\n    this.log('video enabled'); // Update the server of the current camera active state\n\n    this.sendUserCamera(); // Update the application of the current microphone & camera state\n\n    (_a = this._onMicrophoneActive) === null || _a === void 0 ? void 0 : _a.call(this.isMicrophoneActive());\n    (_b = this._onCameraActive) === null || _b === void 0 ? void 0 : _b.call(this.isCameraActive());\n  };\n\n  Session.prototype.onVideoLoaded = function (e) {\n    var _this = this;\n\n    this.log('video has loaded');\n\n    var videoStarted = function () {\n      _this.log('video has started playing');\n\n      _this.sendRtcEvent('videoStarted', {});\n\n      _this.microphoneMuted = false; // allow the user to speak now that the DP is visible\n    }; // If the video element isn't muted the videoStarted event can be sent immediately\n\n\n    if (!this._videoElement.muted) {\n      videoStarted();\n      return;\n    } // The video element is muted, wait for it to be unmuted before declaring the video fully started\n    // there isn't an event for unmuted however volumechange apparently provides a\n    // fair alternative: https://stackoverflow.com/questions/25105414/html5-video-onmuted-and-onloop-event\n\n\n    var unmuteCallback = function () {\n      videoStarted();\n\n      _this._videoElement.removeEventListener('volumechange', unmuteCallback);\n    };\n\n    this._videoElement.addEventListener('volumechange', unmuteCallback, false);\n  };\n\n  Session.prototype.sendRtcEvent = function (name, body) {\n    if (this._serverConnection === null) {\n      return;\n    }\n\n    if (this._sessionId) {\n      body.sessionId = this._sessionId;\n    }\n\n    var payload = {\n      category: 'webrtc',\n      kind: 'event',\n      name: name,\n      body: body\n    };\n\n    if (this._sessionId || name === 'offer') {\n      this.sendMessage(payload);\n    } else {\n      // The session has not yet been accepted, queue the message until it is\n      this._outgoingQueue.push(payload);\n    }\n  };\n\n  Session.prototype.sendVideoBounds = function (width, height) {\n    this.sendRtcEvent('videoBounds', {\n      width: width,\n      height: height\n    });\n  };\n  /**\n   * Sends updated user camera rotation to server\n   * this gives the app the chance to choose the required rotation of the user camera\n   * such that it matches the devices orientation.  Values can be 0, 90, 180, 270.\n   * @param rotation - The clockwise rotation in degrees of the user video feed (0, 90, 180 or 270)\n   * @internal\n   */\n\n\n  Session.prototype.sendUserCamera = function (rotation) {\n    var body = {\n      active: this.isCameraActive()\n    };\n\n    if (rotation !== undefined) {\n      body.rotation = rotation;\n    }\n\n    this.sendRtcEvent('userCamera', body);\n  };\n\n  Session.prototype.sendCameraRotation = function () {\n    if (this._features.isIos) {\n      var orientation_1 = window.orientation;\n      this.log(\"send updated camera rotation, device orientation: \".concat(orientation_1)); // Compute the camera orientation for iOS, degrees to rotate the image to the right\n      // to give it a correct orientation relative to how the iOS device is held\n\n      var rotateCamera = 0; // NB: iOS safari fixedCameraOrientation = -90; - iOS front camera orientation in terms of window orientation positions\n\n      if (orientation_1 === 0) {\n        rotateCamera = 90;\n      } else if (orientation_1 === 90) {\n        rotateCamera = 180;\n      } else if (orientation_1 === 180) {\n        rotateCamera = 270;\n      } else if (orientation_1 === -90) {\n        rotateCamera = 0;\n      }\n\n      this.sendUserCamera(rotateCamera);\n    }\n  };\n\n  Session.prototype.sendMessage = function (message) {\n    if (!this._serverConnection) {\n      return;\n    }\n\n    if (this._serverConnection.readyState === WebSocket.OPEN) {\n      // connected\n      this._serverConnection.send(JSON.stringify(message));\n    } else {\n      this.log(\"server connection not ready, discarding message: \".concat(message));\n    }\n  };\n\n  Session.prototype.sendUserText = function (text) {\n    this.sendRtcEvent('userText', {\n      userText: text\n    });\n  };\n\n  Session.prototype.hasCamera = function (userMedia) {\n    return userMedia === UserMedia.Camera || userMedia === UserMedia.MicrophoneAndCamera;\n  };\n\n  Session.prototype.hasMicrophone = function (userMedia) {\n    return userMedia === UserMedia.Microphone || userMedia === UserMedia.MicrophoneAndCamera;\n  };\n\n  Session.prototype.makeUserMedia = function (microphone, webcam) {\n    if (microphone && webcam) {\n      return UserMedia.MicrophoneAndCamera;\n    } else if (microphone) {\n      return UserMedia.Microphone;\n    } else if (webcam) {\n      return UserMedia.Camera;\n    }\n\n    return UserMedia.None;\n  };\n\n  Session.prototype.findSenderTrackByKind = function (kind) {\n    var e_3, _a;\n\n    var _b;\n\n    if (!this._peerConnection) {\n      return null;\n    }\n\n    var senders = this._peerConnection.getSenders();\n\n    try {\n      for (var senders_1 = __values(senders), senders_1_1 = senders_1.next(); !senders_1_1.done; senders_1_1 = senders_1.next()) {\n        var sender = senders_1_1.value;\n\n        if (sender.track && ((_b = sender.track) === null || _b === void 0 ? void 0 : _b.kind) === kind) {\n          return sender.track;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (senders_1_1 && !senders_1_1.done && (_a = senders_1.return)) _a.call(senders_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return null;\n  };\n\n  Session.prototype.findSenderByKind = function (kind) {\n    var e_4, _a, e_5, _b;\n\n    var _c, _d;\n\n    if (!this._peerConnection) {\n      return null;\n    }\n\n    try {\n      for (var _e = __values(this._peerConnection.getTransceivers()), _f = _e.next(); !_f.done; _f = _e.next()) {\n        var transceiver = _f.value;\n\n        if (transceiver.direction === 'sendrecv' && ((_d = (_c = transceiver.receiver) === null || _c === void 0 ? void 0 : _c.track) === null || _d === void 0 ? void 0 : _d.kind) === kind) {\n          return transceiver.sender;\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    try {\n      for (var _g = __values(this._peerConnection.getSenders()), _h = _g.next(); !_h.done; _h = _g.next()) {\n        var sender = _h.value;\n\n        if (sender.track === null || sender.track.kind === kind) {\n          return sender;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return null;\n  };\n\n  Session.prototype.processChangeUserMediaQueue = function () {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var operation, lastMicrophoneActive, lastCameraActive, e_6;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            operation = this._changeUserMediaQueue.length > 0 ? this._changeUserMediaQueue[0] : undefined;\n            if (!operation) return [3\n            /*break*/\n            , 5];\n            _e.label = 1;\n\n          case 1:\n            _e.trys.push([1, 3,, 4]);\n\n            lastMicrophoneActive = this.isMicrophoneActive();\n            lastCameraActive = this.isCameraActive(); // Change the media to that requested by the operation\n\n            return [4\n            /*yield*/\n            , this.changeUserMediaInternal(this.makeUserMedia((_a = operation.microphone) !== null && _a !== void 0 ? _a : lastMicrophoneActive, (_b = operation.camera) !== null && _b !== void 0 ? _b : lastCameraActive))];\n\n          case 2:\n            // Change the media to that requested by the operation\n            _e.sent(); // Notify of any change of microphone state\n\n\n            if (operation.microphone !== undefined && operation.microphone !== lastMicrophoneActive) {\n              (_c = this._onMicrophoneActive) === null || _c === void 0 ? void 0 : _c.call(this.isMicrophoneActive());\n            } // Notify of any change of camera state\n\n\n            if (operation.camera !== undefined && operation.camera !== lastCameraActive) {\n              (_d = this._onCameraActive) === null || _d === void 0 ? void 0 : _d.call(this.isCameraActive());\n            } // The operation has completed successfully\n\n\n            operation.deferred.resolve();\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_6 = _e.sent();\n            operation.deferred.reject(e_6);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            // Remove the operation as it's now finished\n            this._changeUserMediaQueue.shift();\n\n            _e.label = 5;\n\n          case 5:\n            if (operation) return [3\n            /*break*/\n            , 0];\n            _e.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Session.prototype.changeUserMediaInternal = function (newUserMedia) {\n    return __awaiter(this, void 0, void 0, function () {\n      var microphoneTrack, cameraTrack, needMicrophoneUpgrade, needCameraUpgrade, newMediaStream, requiredMedia, mediaDeferred;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            microphoneTrack = this.findSenderTrackByKind('audio');\n            cameraTrack = this.findSenderTrackByKind('video');\n            needMicrophoneUpgrade = this.hasMicrophone(newUserMedia) && (!microphoneTrack || microphoneTrack.readyState === 'ended');\n            needCameraUpgrade = this.hasCamera(newUserMedia) && (!cameraTrack || cameraTrack.readyState === 'ended');\n            newMediaStream = null;\n            if (!(needMicrophoneUpgrade || needCameraUpgrade)) return [3\n            /*break*/\n            , 2];\n            requiredMedia = this.makeUserMedia(needMicrophoneUpgrade, needCameraUpgrade);\n            mediaDeferred = new Deferred();\n            this.selectUserMedia(requiredMedia, requiredMedia, mediaDeferred, function (stream, deferred) {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  newMediaStream = stream;\n                  deferred.resolve();\n                  return [2\n                  /*return*/\n                  ];\n                });\n              });\n            });\n            return [4\n            /*yield*/\n            , mediaDeferred.promise];\n\n          case 1:\n            _a.sent();\n\n            if (!this._localStream) {\n              this._localStream = new MediaStream();\n            }\n\n            _a.label = 2;\n\n          case 2:\n            // Update the microphone track\n            return [4\n            /*yield*/\n            , this.updateSenderTrack('audio', this.hasMicrophone(newUserMedia), newMediaStream)];\n\n          case 3:\n            // Update the microphone track\n            _a.sent(); // Update the camera track\n\n\n            return [4\n            /*yield*/\n            , this.updateSenderTrack('video', this.hasCamera(newUserMedia), newMediaStream)];\n\n          case 4:\n            // Update the camera track\n            _a.sent(); // Update the server of the current camera active state\n\n\n            this.sendUserCamera();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // Update the RTP sender / track to the given active state. If active then the newMediaStream must\n  // contain a track for the requested 'kind'\n\n\n  Session.prototype.updateSenderTrack = function (kind, active, newMediaStream) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var sender, track, newTrack, e_7;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            sender = this.findSenderByKind(kind);\n            track = sender === null || sender === void 0 ? void 0 : sender.track;\n            if (!(!!sender && (!track || active !== track.enabled))) return [3\n            /*break*/\n            , 7];\n            this.log('new user ' + kind + ' active state = ' + active);\n            if (!active) return [3\n            /*break*/\n            , 6];\n            _c.label = 1;\n\n          case 1:\n            _c.trys.push([1, 4,, 5]);\n\n            if (track) {\n              (_a = this._localStream) === null || _a === void 0 ? void 0 : _a.removeTrack(track);\n            }\n\n            if (!newMediaStream) return [3\n            /*break*/\n            , 3];\n            newTrack = this.getTrackByKind(newMediaStream, kind);\n            if (!newTrack) return [3\n            /*break*/\n            , 3];\n            (_b = this._localStream) === null || _b === void 0 ? void 0 : _b.addTrack(newTrack);\n            if (!(sender.track !== newTrack)) return [3\n            /*break*/\n            , 3];\n            this.log('replacing user ' + kind + ' track');\n            return [4\n            /*yield*/\n            , sender.replaceTrack(newTrack)];\n\n          case 2:\n            _c.sent();\n\n            _c.label = 3;\n\n          case 3:\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_7 = _c.sent();\n            this.log(\"failed to get user \".concat(kind, \" track, error: \").concat(e_7), 'error');\n            throw makeError('failed to get user ' + kind + ': ' + e_7, 'failedUpgrade');\n\n          case 5:\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            if (track) {\n              track.enabled = false;\n              track.stop();\n            }\n\n            _c.label = 7;\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Session.prototype.getTrackByKind = function (stream, kind) {\n    var e_8, _a;\n\n    if (stream) {\n      try {\n        for (var _b = __values(stream.getTracks()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var track = _c.value;\n\n          if (track.kind === kind) {\n            return track;\n          }\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  Session.prototype.isSenderTrackEnabled = function (kind) {\n    var track = this.findSenderTrackByKind(kind);\n    return Boolean(track === null || track === void 0 ? void 0 : track.enabled);\n  };\n\n  Session.prototype.isMicrophoneActive = function () {\n    return this.isSenderTrackEnabled('audio');\n  };\n\n  Session.prototype.isCameraActive = function () {\n    return this.isSenderTrackEnabled('video');\n  };\n\n  Session.prototype.setMediaDeviceActive = function (_a) {\n    var microphone = _a.microphone,\n        camera = _a.camera;\n    return __awaiter(this, void 0, void 0, function () {\n      var deferred;\n      return __generator(this, function (_b) {\n        deferred = new Deferred();\n\n        this._changeUserMediaQueue.push({\n          microphone: microphone,\n          camera: camera,\n          deferred: deferred\n        });\n\n        if (this._changeUserMediaQueue.length === 1) {\n          this.processChangeUserMediaQueue();\n        }\n\n        return [2\n        /*return*/\n        , deferred.promise];\n      });\n    });\n  };\n\n  Session.prototype.close = function (sendRtcClose, reason, deferred) {\n    var e_9, _a;\n\n    if (sendRtcClose === void 0) {\n      sendRtcClose = true;\n    }\n\n    if (reason === void 0) {\n      reason = 'normal';\n    }\n\n    if (this._closed) {\n      return;\n    }\n\n    this._closed = true;\n\n    if (this._peerConnection) {\n      try {\n        this._peerConnection.close();\n      } catch (e) {\n        this.log(\"error: \".concat(e), 'error');\n      }\n    }\n\n    if (this._localStream) {\n      try {\n        var tracks = this._localStream.getTracks();\n\n        for (var i in tracks) {\n          tracks[i].stop();\n        }\n      } catch (e) {\n        this.log(\"error: \".concat(e), 'error');\n      }\n    }\n\n    if (sendRtcClose) {\n      this.sendRtcEvent('close', {\n        reason: 'normal'\n      });\n    }\n\n    if (deferred) {\n      if (deferred.isResolved()) {\n        this._onClose(reason);\n      } else {\n        deferred.reject(makeError('websocket closed: ' + reason, reason));\n      }\n    }\n\n    if (this._serverConnection) {\n      this.log('closing server connection');\n\n      this._serverConnection.close();\n    }\n\n    if (this._controlConnection) {\n      this._controlConnection.close();\n    }\n\n    try {\n      // Deregister event listeners\n      for (var _b = __values(this._removeListeners), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var listener = _c.value;\n        listener.target.removeEventListener(listener.name, listener.callback);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n  };\n\n  Session.prototype.createOffer = function (peerConnection, options) {\n    return peerConnection.createOffer(options);\n  };\n\n  Session.prototype.setRemoteDescription = function (peerConnection, sessionDescription) {\n    return peerConnection.setRemoteDescription(sessionDescription);\n  };\n\n  Session.prototype.setLocalDescription = function (peerConnection, description) {\n    return peerConnection.setLocalDescription(description);\n  };\n\n  Session.prototype.createAnswer = function (peerConnection) {\n    return peerConnection.createAnswer();\n  };\n\n  Object.defineProperty(Session.prototype, \"peerConnection\", {\n    get: function () {\n      return this._peerConnection;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"serverConnection\", {\n    get: function () {\n      return this._serverConnection;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"sessionId\", {\n    get: function () {\n      return this._sessionId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"server\", {\n    get: function () {\n      return this._server;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"sceneId\", {\n    get: function () {\n      return this._sceneId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"isMicrophoneConnected\", {\n    get: function () {\n      return !!this.findSenderTrackByKind('audio');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"isCameraConnected\", {\n    get: function () {\n      return !!this.findSenderTrackByKind('video');\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"features\", {\n    get: function () {\n      return this._features;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"microphoneMuteDelay\", {\n    get: function () {\n      return this._microphoneMuteDelay;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"userMediaStream\", {\n    get: function () {\n      return this._localStream;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"microphoneMuted\", {\n    get: function () {\n      if (!this._localStream) {\n        return true;\n      }\n\n      var audioTracks = this._localStream.getAudioTracks();\n\n      if (!audioTracks || audioTracks.length < 1) {\n        return true;\n      }\n\n      return !audioTracks[0].enabled;\n    },\n    set: function (mute) {\n      var _a, _b;\n\n      if (!this._localStream) {\n        return;\n      }\n\n      var audioTracks = this._localStream.getAudioTracks();\n\n      if (!audioTracks || audioTracks.length < 1) {\n        return;\n      }\n\n      var audioSender = this.findSenderByKind('audio');\n\n      if (((_a = audioSender === null || audioSender === void 0 ? void 0 : audioSender.track) === null || _a === void 0 ? void 0 : _a.readyState) === 'live' && audioSender.track === audioTracks[0]) {\n        var enable = !mute;\n        audioTracks[0].enabled = enable;\n        this.log(\"microphone muted active notification: \".concat(enable));\n        (_b = this._onMicrophoneActive) === null || _b === void 0 ? void 0 : _b.call(enable);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"webcamMuted\", {\n    get: function () {\n      if (!this._localStream) {\n        return true;\n      }\n\n      var videoTracks = this._localStream.getVideoTracks();\n\n      if (!videoTracks || videoTracks.length < 1) {\n        return true;\n      }\n\n      return !videoTracks[0].enabled;\n    },\n    set: function (mute) {\n      var _a, _b;\n\n      if (!this._localStream) {\n        return;\n      }\n\n      var videoTracks = this._localStream.getVideoTracks();\n\n      if (!videoTracks || videoTracks.length < 1) {\n        return;\n      }\n\n      var videoSender = this.findSenderByKind('video');\n\n      if (((_a = videoSender === null || videoSender === void 0 ? void 0 : videoSender.track) === null || _a === void 0 ? void 0 : _a.readyState) === 'live' && videoSender.track === videoTracks[0]) {\n        var enable = !mute;\n        videoTracks[0].enabled = enable;\n        (_b = this._onCameraActive) === null || _b === void 0 ? void 0 : _b.call(enable);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"offsetX\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"offsetY\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"microphoneActiveCallbacks\", {\n    set: function (callbacks) {\n      this._onMicrophoneActive = callbacks;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Session.prototype, \"cameraActiveCallbacks\", {\n    set: function (callbacks) {\n      this._onCameraActive = callbacks;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Session;\n}();\n\nexport { Session }; //# sourceMappingURL=Session.js.map","map":null,"metadata":{},"sourceType":"module"}