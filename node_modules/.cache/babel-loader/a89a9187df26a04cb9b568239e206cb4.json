{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { validateKey, validateValue } from '../internal/validators';\nvar MAX_TRACE_STATE_ITEMS = 32;\nvar MAX_TRACE_STATE_LEN = 512;\nvar LIST_MEMBERS_SEPARATOR = ',';\nvar LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\n\nvar TraceState =\n/** @class */\nfunction () {\n  function TraceState(rawTraceState) {\n    this._internalState = new Map();\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  TraceState.prototype.set = function (key, value) {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    var traceState = this._clone();\n\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n\n    traceState._internalState.set(key, value);\n\n    return traceState;\n  };\n\n  TraceState.prototype.unset = function (key) {\n    var traceState = this._clone();\n\n    traceState._internalState.delete(key);\n\n    return traceState;\n  };\n\n  TraceState.prototype.get = function (key) {\n    return this._internalState.get(key);\n  };\n\n  TraceState.prototype.serialize = function () {\n    var _this = this;\n\n    return this._keys().reduce(function (agg, key) {\n      agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));\n      return agg;\n    }, []).join(LIST_MEMBERS_SEPARATOR);\n  };\n\n  TraceState.prototype._parse = function (rawTraceState) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n    .reduce(function (agg, part) {\n      var listMember = part.trim(); // Optional Whitespace (OWS) handling\n\n      var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n\n      if (i !== -1) {\n        var key = listMember.slice(0, i);\n        var value = listMember.slice(i + 1, part.length);\n\n        if (validateKey(key) && validateValue(value)) {\n          agg.set(key, value);\n        } else {// TODO: Consider to add warning log\n        }\n      }\n\n      return agg;\n    }, new Map()); // Because of the reverse() requirement, trunc must be done after map is created\n\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain\n      .slice(0, MAX_TRACE_STATE_ITEMS));\n    }\n  };\n\n  TraceState.prototype._keys = function () {\n    return Array.from(this._internalState.keys()).reverse();\n  };\n\n  TraceState.prototype._clone = function () {\n    var traceState = new TraceState();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  };\n\n  return TraceState;\n}();\n\nexport { TraceState }; //# sourceMappingURL=TraceState.js.map","map":null,"metadata":{},"sourceType":"module"}