{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType } from '@opentelemetry/api-metrics';\nimport { hrTimeToNanoseconds } from '@opentelemetry/core';\nimport { AggregationTemporality, DataPointType } from '@opentelemetry/sdk-metrics';\nimport { toAttributes } from '../common/internal';\nexport function toResourceMetrics(resourceMetrics) {\n  return {\n    resource: {\n      attributes: toAttributes(resourceMetrics.resource.attributes),\n      droppedAttributesCount: 0\n    },\n    schemaUrl: undefined,\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics)\n  };\n}\nexport function toScopeMetrics(scopeMetrics) {\n  return Array.from(scopeMetrics.map(function (metrics) {\n    var scopeMetrics = {\n      scope: {\n        name: metrics.scope.name,\n        version: metrics.scope.version\n      },\n      metrics: metrics.metrics.map(function (metricData) {\n        return toMetric(metricData);\n      }),\n      schemaUrl: metrics.scope.schemaUrl\n    };\n    return scopeMetrics;\n  }));\n}\nexport function toMetric(metricData) {\n  var out = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit\n  };\n  var aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);\n\n  if (metricData.dataPointType === DataPointType.SUM) {\n    out.sum = {\n      aggregationTemporality: aggregationTemporality,\n      isMonotonic: metricData.isMonotonic,\n      dataPoints: toSingularDataPoints(metricData)\n    };\n  } else if (metricData.dataPointType === DataPointType.GAUGE) {\n    // Instrument is a gauge.\n    out.gauge = {\n      dataPoints: toSingularDataPoints(metricData)\n    };\n  } else if (metricData.dataPointType === DataPointType.HISTOGRAM) {\n    out.histogram = {\n      aggregationTemporality: aggregationTemporality,\n      dataPoints: toHistogramDataPoints(metricData)\n    };\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoint(dataPoint, valueType) {\n  var out = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: hrTimeToNanoseconds(dataPoint.startTime),\n    timeUnixNano: hrTimeToNanoseconds(dataPoint.endTime)\n  };\n\n  if (valueType === ValueType.INT) {\n    out.asInt = dataPoint.value;\n  } else if (valueType === ValueType.DOUBLE) {\n    out.asDouble = dataPoint.value;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoints(metricData) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    return toSingularDataPoint(dataPoint, metricData.descriptor.valueType);\n  });\n}\n\nfunction toHistogramDataPoints(metricData) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    var histogram = dataPoint.value;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: hrTimeToNanoseconds(dataPoint.startTime),\n      timeUnixNano: hrTimeToNanoseconds(dataPoint.endTime)\n    };\n  });\n}\n\nfunction toAggregationTemporality(temporality) {\n  if (temporality === AggregationTemporality.DELTA) {\n    return 1\n    /* AGGREGATION_TEMPORALITY_DELTA */\n    ;\n  }\n\n  if (temporality === AggregationTemporality.CUMULATIVE) {\n    return 2\n    /* AGGREGATION_TEMPORALITY_CUMULATIVE */\n    ;\n  }\n\n  return 0\n  /* AGGREGATION_TEMPORALITY_UNSPECIFIED */\n  ;\n} //# sourceMappingURL=internal.js.map","map":null,"metadata":{},"sourceType":"module"}