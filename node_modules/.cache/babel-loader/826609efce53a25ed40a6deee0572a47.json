{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { context, diag, propagation, trace } from '@opentelemetry/api';\nimport { CompositePropagator, W3CBaggagePropagator, W3CTraceContextPropagator, getEnv, merge } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { Tracer } from '.';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { NoopSpanProcessor } from './export/NoopSpanProcessor';\nimport { BatchSpanProcessor } from './platform';\nimport { reconfigureLimits } from './utility';\nexport var ForceFlushState;\n\n(function (ForceFlushState) {\n  ForceFlushState[ForceFlushState[\"resolved\"] = 0] = \"resolved\";\n  ForceFlushState[ForceFlushState[\"timeout\"] = 1] = \"timeout\";\n  ForceFlushState[ForceFlushState[\"error\"] = 2] = \"error\";\n  ForceFlushState[ForceFlushState[\"unresolved\"] = 3] = \"unresolved\";\n})(ForceFlushState || (ForceFlushState = {}));\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\n\n\nvar BasicTracerProvider =\n/** @class */\nfunction () {\n  function BasicTracerProvider(config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    var _a;\n\n    this._registeredSpanProcessors = [];\n    this._tracers = new Map();\n    var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));\n    this.resource = (_a = mergedConfig.resource) !== null && _a !== void 0 ? _a : Resource.empty();\n    this.resource = Resource.default().merge(this.resource);\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this.resource\n    });\n\n    var defaultExporter = this._buildExporterFromEnv();\n\n    if (defaultExporter !== undefined) {\n      var batchProcessor = new BatchSpanProcessor(defaultExporter);\n      this.activeSpanProcessor = batchProcessor;\n    } else {\n      this.activeSpanProcessor = new NoopSpanProcessor();\n    }\n  }\n\n  BasicTracerProvider.prototype.getTracer = function (name, version, options) {\n    var key = name + \"@\" + (version || '') + \":\" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || '');\n\n    if (!this._tracers.has(key)) {\n      this._tracers.set(key, new Tracer({\n        name: name,\n        version: version,\n        schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl\n      }, this._config, this));\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    return this._tracers.get(key);\n  };\n  /**\n   * Adds a new {@link SpanProcessor} to this tracer.\n   * @param spanProcessor the new SpanProcessor to be added.\n   */\n\n\n  BasicTracerProvider.prototype.addSpanProcessor = function (spanProcessor) {\n    if (this._registeredSpanProcessors.length === 0) {\n      // since we might have enabled by default a batchProcessor, we disable it\n      // before adding the new one\n      this.activeSpanProcessor.shutdown().catch(function (err) {\n        return diag.error('Error while trying to shutdown current span processor', err);\n      });\n    }\n\n    this._registeredSpanProcessors.push(spanProcessor);\n\n    this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);\n  };\n\n  BasicTracerProvider.prototype.getActiveSpanProcessor = function () {\n    return this.activeSpanProcessor;\n  };\n  /**\n   * Register this TracerProvider for use with the OpenTelemetry API.\n   * Undefined values may be replaced with defaults, and\n   * null values will be skipped.\n   *\n   * @param config Configuration object for SDK registration\n   */\n\n\n  BasicTracerProvider.prototype.register = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    trace.setGlobalTracerProvider(this);\n\n    if (config.propagator === undefined) {\n      config.propagator = this._buildPropagatorFromEnv();\n    }\n\n    if (config.contextManager) {\n      context.setGlobalContextManager(config.contextManager);\n    }\n\n    if (config.propagator) {\n      propagation.setGlobalPropagator(config.propagator);\n    }\n  };\n\n  BasicTracerProvider.prototype.forceFlush = function () {\n    var timeout = this._config.forceFlushTimeoutMillis;\n\n    var promises = this._registeredSpanProcessors.map(function (spanProcessor) {\n      return new Promise(function (resolve) {\n        var state;\n        var timeoutInterval = setTimeout(function () {\n          resolve(new Error(\"Span processor did not completed within timeout period of \" + timeout + \" ms\"));\n          state = ForceFlushState.timeout;\n        }, timeout);\n        spanProcessor.forceFlush().then(function () {\n          clearTimeout(timeoutInterval);\n\n          if (state !== ForceFlushState.timeout) {\n            state = ForceFlushState.resolved;\n            resolve(state);\n          }\n        }).catch(function (error) {\n          clearTimeout(timeoutInterval);\n          state = ForceFlushState.error;\n          resolve(error);\n        });\n      });\n    });\n\n    return new Promise(function (resolve, reject) {\n      Promise.all(promises).then(function (results) {\n        var errors = results.filter(function (result) {\n          return result !== ForceFlushState.resolved;\n        });\n\n        if (errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      }).catch(function (error) {\n        return reject([error]);\n      });\n    });\n  };\n\n  BasicTracerProvider.prototype.shutdown = function () {\n    return this.activeSpanProcessor.shutdown();\n  };\n  /**\n   * TS cannot yet infer the type of this.constructor:\n   * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146\n   * There is no need to override either of the getters in your child class.\n   * The type of the registered component maps should be the same across all\n   * classes in the inheritance tree.\n   */\n\n\n  BasicTracerProvider.prototype._getPropagator = function (name) {\n    var _a;\n\n    return (_a = this.constructor._registeredPropagators.get(name)) === null || _a === void 0 ? void 0 : _a();\n  };\n\n  BasicTracerProvider.prototype._getSpanExporter = function (name) {\n    var _a;\n\n    return (_a = this.constructor._registeredExporters.get(name)) === null || _a === void 0 ? void 0 : _a();\n  };\n\n  BasicTracerProvider.prototype._buildPropagatorFromEnv = function () {\n    var _this = this; // per spec, propagators from env must be deduplicated\n\n\n    var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));\n    var propagators = uniquePropagatorNames.map(function (name) {\n      var propagator = _this._getPropagator(name);\n\n      if (!propagator) {\n        diag.warn(\"Propagator \\\"\" + name + \"\\\" requested through environment variable is unavailable.\");\n      }\n\n      return propagator;\n    });\n    var validPropagators = propagators.reduce(function (list, item) {\n      if (item) {\n        list.push(item);\n      }\n\n      return list;\n    }, []);\n\n    if (validPropagators.length === 0) {\n      return;\n    } else if (uniquePropagatorNames.length === 1) {\n      return validPropagators[0];\n    } else {\n      return new CompositePropagator({\n        propagators: validPropagators\n      });\n    }\n  };\n\n  BasicTracerProvider.prototype._buildExporterFromEnv = function () {\n    var exporterName = getEnv().OTEL_TRACES_EXPORTER;\n    if (exporterName === 'none' || exporterName === '') return;\n\n    var exporter = this._getSpanExporter(exporterName);\n\n    if (!exporter) {\n      diag.error(\"Exporter \\\"\" + exporterName + \"\\\" requested through environment variable is unavailable.\");\n    }\n\n    return exporter;\n  };\n\n  BasicTracerProvider._registeredPropagators = new Map([['tracecontext', function () {\n    return new W3CTraceContextPropagator();\n  }], ['baggage', function () {\n    return new W3CBaggagePropagator();\n  }]]);\n  BasicTracerProvider._registeredExporters = new Map();\n  return BasicTracerProvider;\n}();\n\nexport { BasicTracerProvider }; //# sourceMappingURL=BasicTracerProvider.js.map","map":null,"metadata":{},"sourceType":"module"}