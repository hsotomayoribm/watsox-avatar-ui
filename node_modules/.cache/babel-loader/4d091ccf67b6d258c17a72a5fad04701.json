{"ast":null,"code":"var __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport { ExportResultCode } from '@opentelemetry/core';\nimport { AggregationTemporality } from './AggregationTemporality';\n/* eslint-disable no-console */\n\nvar ConsoleMetricExporter =\n/** @class */\nfunction () {\n  function ConsoleMetricExporter() {\n    this._shutdown = false;\n  }\n\n  ConsoleMetricExporter.prototype.export = function (metrics, resultCallback) {\n    if (this._shutdown) {\n      // If the exporter is shutting down, by spec, we need to return FAILED as export result\n      setImmediate(resultCallback, {\n        code: ExportResultCode.FAILED\n      });\n      return;\n    }\n\n    return ConsoleMetricExporter._sendMetrics(metrics, resultCallback);\n  };\n\n  ConsoleMetricExporter.prototype.forceFlush = function () {\n    return Promise.resolve();\n  };\n\n  ConsoleMetricExporter.prototype.selectAggregationTemporality = function (_instrumentType) {\n    return AggregationTemporality.CUMULATIVE;\n  };\n\n  ConsoleMetricExporter.prototype.shutdown = function () {\n    this._shutdown = true;\n    return Promise.resolve();\n  };\n\n  ConsoleMetricExporter._sendMetrics = function (metrics, done) {\n    var e_1, _a, e_2, _b;\n\n    try {\n      for (var _c = __values(metrics.scopeMetrics), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var scopeMetrics = _d.value;\n\n        try {\n          for (var _e = (e_2 = void 0, __values(scopeMetrics.metrics)), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var metric = _f.value;\n            console.dir({\n              descriptor: metric.descriptor,\n              dataPointType: metric.dataPointType,\n              dataPoints: metric.dataPoints\n            });\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    done({\n      code: ExportResultCode.SUCCESS\n    });\n  };\n\n  return ConsoleMetricExporter;\n}();\n\nexport { ConsoleMetricExporter }; //# sourceMappingURL=ConsoleMetricExporter.js.map","map":null,"metadata":{},"sourceType":"module"}