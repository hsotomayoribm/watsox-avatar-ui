{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\n\nvar SumAccumulation =\n/** @class */\nfunction () {\n  function SumAccumulation(startTime, monotonic, _current, reset) {\n    if (_current === void 0) {\n      _current = 0;\n    }\n\n    if (reset === void 0) {\n      reset = false;\n    }\n\n    this.startTime = startTime;\n    this.monotonic = monotonic;\n    this._current = _current;\n    this.reset = reset;\n  }\n\n  SumAccumulation.prototype.record = function (value) {\n    if (this.monotonic && value < 0) {\n      return;\n    }\n\n    this._current += value;\n  };\n\n  SumAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n\n  SumAccumulation.prototype.toPointValue = function () {\n    return this._current;\n  };\n\n  return SumAccumulation;\n}();\n\nexport { SumAccumulation };\n/** Basic aggregator which calculates a Sum from individual measurements. */\n\nvar SumAggregator =\n/** @class */\nfunction () {\n  function SumAggregator(monotonic) {\n    this.monotonic = monotonic;\n    this.kind = AggregatorKind.SUM;\n  }\n\n  SumAggregator.prototype.createAccumulation = function (startTime) {\n    return new SumAccumulation(startTime, this.monotonic);\n  };\n  /**\n   * Returns the result of the merge of the given accumulations.\n   */\n\n\n  SumAggregator.prototype.merge = function (previous, delta) {\n    var prevPv = previous.toPointValue();\n    var deltaPv = delta.toPointValue();\n\n    if (delta.reset) {\n      return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);\n    }\n\n    return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n\n\n  SumAggregator.prototype.diff = function (previous, current) {\n    var prevPv = previous.toPointValue();\n    var currPv = current.toPointValue();\n    /**\n     * If the SumAggregator is a monotonic one and the previous point value is\n     * greater than the current one, a reset is deemed to be happened.\n     * Return the current point value to prevent the value from been reset.\n     */\n\n    if (this.monotonic && prevPv > currPv) {\n      return new SumAccumulation(current.startTime, this.monotonic, currPv, true);\n    }\n\n    return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);\n  };\n\n  SumAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.SUM,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n            attributes = _b[0],\n            accumulation = _b[1];\n\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: accumulation.toPointValue()\n        };\n      }),\n      isMonotonic: this.monotonic\n    };\n  };\n\n  return SumAggregator;\n}();\n\nexport { SumAggregator }; //# sourceMappingURL=Sum.js.map","map":null,"metadata":{},"sourceType":"module"}