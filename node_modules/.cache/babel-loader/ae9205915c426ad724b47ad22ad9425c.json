{"ast":null,"code":"/**\n * @module smwebsdk\n */\nimport { __awaiter, __generator } from \"tslib\";\n/*\n * Copyright 2020 Soul Machines Ltd. All Rights Reserved.\n */\n\nimport { Deferred } from './Deferred';\nimport { Features } from './Features';\nimport { Logger } from './utils/Logger';\nimport { makeError } from './utils/make-error';\n/**\n *  WebSocketSession class\n */\n\nvar WebSocketSession =\n/** @class */\nfunction () {\n  function WebSocketSession(serverUri, accessToken, logger) {\n    if (logger === void 0) {\n      logger = new Logger();\n    }\n\n    var _this = this;\n\n    this.logger = logger;\n    this._outgoingQueue = [];\n\n    this._onConnectedStorage = function (resumeRequested, isResumedSession, server, sessionId // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) {};\n\n    this._pendingLog = [];\n    this._closed = false;\n    this._shouldLogToServer = false;\n    this._serverUri = serverUri;\n    this._accessToken = accessToken; // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n    this._onClose = function (reason) {}; // owner specifies custom close method\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    this._onMessage = function (message) {}; // owner specifies custom message handler\n\n\n    this._sessionError = function (error) {\n      // owner can specify custom session error handler\n      _this.logger.log('error', \"session error: \".concat(error));\n    };\n\n    this._features = new Features();\n  }\n\n  Object.defineProperty(WebSocketSession.prototype, \"onConnected\", {\n    set: function (sessionFunction) {\n      this._onConnectedStorage = sessionFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"onClose\", {\n    set: function (closeFunction) {\n      this._onClose = closeFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"onMessage\", {\n    set: function (messageFunction) {\n      this._onMessage = messageFunction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"loggingEnabled\", {\n    get: function () {\n      return this.logger.isEnabled;\n    },\n\n    /**\n     * @deprecated use setLogging(boolean).\n     */\n    set: function (enable) {\n      this.logger.log('warn', 'loggingEnabled is deprecated and will be removed in a future version. Please use setLogging(boolean)');\n      this.logger.enableLogging(enable);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebSocketSession.prototype.setMinLogLevel = function (level) {\n    this.logger.setMinLogLevel(level);\n  };\n\n  WebSocketSession.prototype.setLogging = function (enable) {\n    this.logger.enableLogging(enable);\n  };\n\n  WebSocketSession.prototype.log = function (text) {\n    if (this.loggingEnabled) {\n      if (this._shouldLogToServer) {\n        this.logToServer(text);\n      } else {\n        this.logger.log('log', text);\n      }\n    }\n  };\n\n  WebSocketSession.prototype.logToServer = function (text) {\n    if (this.sessionId) {\n      this.sendlogMessage([text]);\n    } else {\n      this._pendingLog.push(text);\n    }\n  };\n\n  WebSocketSession.prototype.sendlogMessage = function (textArray) {\n    if (this._sessionId && textArray && textArray.length > 0) {\n      var payload = {\n        category: 'diagnostics',\n        kind: 'event',\n        name: 'log',\n        body: {\n          name: 'browser',\n          text: textArray\n        }\n      };\n      this.sendMessage(payload);\n    }\n  };\n\n  WebSocketSession.prototype.connect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var deferred;\n      return __generator(this, function (_a) {\n        deferred = new Deferred();\n        this._closed = false;\n\n        if (this._serverUri && (this._serverUri.startsWith('ws:') || this._serverUri.startsWith('wss:'))) {\n          // A server uri has been specified, continue with the connection\n          this.connectByWebSocket(deferred);\n        }\n\n        return [2\n        /*return*/\n        , deferred.promise];\n      });\n    });\n  };\n\n  WebSocketSession.prototype.connectByWebSocket = function (deferred) {\n    var _this = this;\n\n    this.log(\"connecting to: \".concat(this._serverUri));\n\n    if (!this._accessToken) {\n      this._serverConnection = new WebSocket(this._serverUri);\n    } else {\n      this._serverConnection = new WebSocket(this._serverUri + '?access_token=' + this._accessToken);\n    }\n\n    this._serverConnection.onmessage = function (msg) {\n      _this.gotMessageFromServer(msg, deferred);\n    };\n\n    this._serverConnection.onerror = function (event) {\n      if (deferred.isPending()) {\n        deferred.reject(makeError('websocket failed', 'serverConnectionFailed'));\n      }\n    }; // wait for the websocket to open, then continue with setup\n\n\n    this._serverConnection.onopen = function (event) {\n      _this.log('websocket open');\n\n      deferred.resolve();\n    }; // setup a close handler\n\n\n    this._serverConnection.onclose = function (event) {\n      _this.log(\"websocket closed: code(\".concat(event.code, \"), reason(\").concat(event.reason, \"), clean(\").concat(event.wasClean, \")\"));\n\n      if (!deferred.isRejected) {\n        _this.close(false, 'normal', deferred);\n      }\n    };\n  };\n\n  WebSocketSession.prototype.gotMessageFromServer = function (websocket_message, deferred) {\n    var raw_text = websocket_message.data;\n    this.log(\"message received: \".concat(raw_text));\n    var message = JSON.parse(raw_text);\n    var category = message.category;\n    var name = message.name;\n    var body = message.body;\n\n    if (category !== 'webrtc') {\n      // forward on non-webrtc messages (e.g. scene)\n      this._onMessage(message);\n\n      return;\n    }\n\n    if (message.kind !== 'event') {\n      // currently ignore requests and responses\n      return;\n    }\n\n    if (name === 'accepted') {\n      this.log(\"accepted, session_id = \".concat(body.sessionId));\n      this._sessionId = body.sessionId; // The session has been accepted, send any outgoing queued messages\n\n      for (var i = 0; i < this._outgoingQueue.length; i++) {\n        this._outgoingQueue[i].body.sessionId = this._sessionId;\n        this.sendMessage(this._outgoingQueue[i]);\n      }\n\n      this._outgoingQueue = []; // Send all pending log messages\n\n      this.sendlogMessage(this._pendingLog);\n      this._pendingLog = [];\n    } else if (name === 'close') {\n      this.close(false, body.reason, deferred);\n    }\n  };\n\n  WebSocketSession.prototype.sendMessage = function (message) {\n    if (!this._serverConnection) {\n      return;\n    }\n\n    if (this._serverConnection.readyState === WebSocket.OPEN) {\n      // connected\n      this._serverConnection.send(JSON.stringify(message));\n    } else {\n      this.log(\"not ready, discarding message: \".concat(message));\n    }\n  };\n\n  WebSocketSession.prototype.close = function (sendRtcClose, reason, deferred) {\n    if (sendRtcClose === void 0) {\n      sendRtcClose = true;\n    }\n\n    if (reason === void 0) {\n      reason = 'normal';\n    }\n\n    if (this._closed) {\n      return;\n    }\n\n    this._closed = true;\n\n    if (deferred) {\n      if (deferred.isResolved()) {\n        this._onClose(reason);\n      } else {\n        deferred.reject(makeError('websocket closed: ' + reason, reason));\n      }\n    }\n\n    if (this._serverConnection) {\n      this.log('closing server connection');\n\n      this._serverConnection.close();\n    }\n  };\n\n  Object.defineProperty(WebSocketSession.prototype, \"serverConnection\", {\n    get: function () {\n      return this._serverConnection;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"sessionId\", {\n    get: function () {\n      return this._sessionId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"peerConnection\", {\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"features\", {\n    get: function () {\n      return this._features;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebSocketSession.prototype.sendRtcEvent = function (name, body) {// NOOP: Stuff for compatibility with Session in Scene\n  };\n\n  WebSocketSession.prototype.sendVideoBounds = function (widthIgnored, heightIgnored) {// NOOP: Stuff for compatibility with Session in Scene\n  };\n\n  WebSocketSession.prototype.sendUserText = function (text) {\n    this.logger.log('error', 'WebSocketSession discarding text: ' + text);\n  };\n\n  Object.defineProperty(WebSocketSession.prototype, \"microphoneMuteDelay\", {\n    get: function () {\n      return undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"microphoneMuted\", {\n    get: function () {\n      return null;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    set: function (mute) {},\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"onUserText\", {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    set: function (userTextFunction) {},\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"isMicrophoneConnected\", {\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"isCameraConnected\", {\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"offsetX\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebSocketSession.prototype, \"offsetY\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebSocketSession.prototype.isMicrophoneActive = function () {\n    return false;\n  };\n\n  WebSocketSession.prototype.isCameraActive = function () {\n    return false;\n  };\n\n  WebSocketSession.prototype.setMediaDeviceActive = function (_a) {\n    var microphone = _a.microphone,\n        camera = _a.camera;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        throw makeError('setMediaDeviceActive not supported on WebSocketSession', 'notSupported');\n      });\n    });\n  };\n\n  return WebSocketSession;\n}();\n\nexport { WebSocketSession }; //# sourceMappingURL=WebSocketSession.js.map","map":null,"metadata":{},"sourceType":"module"}