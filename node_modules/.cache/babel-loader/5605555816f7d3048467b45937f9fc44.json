{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { AggregatorKind } from './types';\nimport { hrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport { DataPointType } from '../export/MetricData';\n\nvar LastValueAccumulation =\n/** @class */\nfunction () {\n  function LastValueAccumulation(startTime, _current, sampleTime) {\n    if (_current === void 0) {\n      _current = 0;\n    }\n\n    if (sampleTime === void 0) {\n      sampleTime = [0, 0];\n    }\n\n    this.startTime = startTime;\n    this._current = _current;\n    this.sampleTime = sampleTime;\n  }\n\n  LastValueAccumulation.prototype.record = function (value) {\n    this._current = value;\n    this.sampleTime = hrTime();\n  };\n\n  LastValueAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n\n  LastValueAccumulation.prototype.toPointValue = function () {\n    return this._current;\n  };\n\n  return LastValueAccumulation;\n}();\n\nexport { LastValueAccumulation };\n/** Basic aggregator which calculates a LastValue from individual measurements. */\n\nvar LastValueAggregator =\n/** @class */\nfunction () {\n  function LastValueAggregator() {\n    this.kind = AggregatorKind.LAST_VALUE;\n  }\n\n  LastValueAggregator.prototype.createAccumulation = function (startTime) {\n    return new LastValueAccumulation(startTime);\n  };\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * Return the newly captured (delta) accumulation for LastValueAggregator.\n   */\n\n\n  LastValueAggregator.prototype.merge = function (previous, delta) {\n    // nanoseconds may lose precisions.\n    var latestAccumulation = hrTimeToMicroseconds(delta.sampleTime) >= hrTimeToMicroseconds(previous.sampleTime) ? delta : previous;\n    return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * A delta aggregation is not meaningful to LastValueAggregator, just return\n   * the newly captured (delta) accumulation for LastValueAggregator.\n   */\n\n\n  LastValueAggregator.prototype.diff = function (previous, current) {\n    // nanoseconds may lose precisions.\n    var latestAccumulation = hrTimeToMicroseconds(current.sampleTime) >= hrTimeToMicroseconds(previous.sampleTime) ? current : previous;\n    return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n  };\n\n  LastValueAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.GAUGE,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n            attributes = _b[0],\n            accumulation = _b[1];\n\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: accumulation.toPointValue()\n        };\n      })\n    };\n  };\n\n  return LastValueAggregator;\n}();\n\nexport { LastValueAggregator }; //# sourceMappingURL=LastValue.js.map","map":null,"metadata":{},"sourceType":"module"}