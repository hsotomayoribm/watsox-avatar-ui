{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport { DiagLogLevel } from '../diag/types';\nimport { getGlobal, registerGlobal, unregisterGlobal } from '../internal/global-utils';\nvar API_NAME = 'diag';\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\n\nvar DiagAPI =\n/** @class */\nfunction () {\n  /**\n   * Private internal constructor\n   * @private\n   */\n  function DiagAPI() {\n    function _logProxy(funcName) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var logger = getGlobal('diag'); // shortcut if logger not set\n\n        if (!logger) return;\n        return logger[funcName].apply(logger, args);\n      };\n    } // Using self local variable for minification purposes as 'this' cannot be minified\n\n\n    var self = this; // DiagAPI specific functions\n\n    self.setLogger = function (logger, logLevel) {\n      var _a, _b;\n\n      if (logLevel === void 0) {\n        logLevel = DiagLogLevel.INFO;\n      }\n\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');\n        self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);\n        return false;\n      }\n\n      var oldLogger = getGlobal('diag');\n      var newLogger = createLogLevelDiagLogger(logLevel, logger); // There already is an logger registered. We'll let it know before overwriting it.\n\n      if (oldLogger) {\n        var stack = (_b = new Error().stack) !== null && _b !== void 0 ? _b : '<failed to generate stacktrace>';\n        oldLogger.warn(\"Current logger will be overwritten from \" + stack);\n        newLogger.warn(\"Current logger will overwrite one already registered from \" + stack);\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.disable = function () {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = function (options) {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n  /** Get the singleton instance of the DiagAPI API */\n\n\n  DiagAPI.instance = function () {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  };\n\n  return DiagAPI;\n}();\n\nexport { DiagAPI }; //# sourceMappingURL=diag.js.map","map":null,"metadata":{},"sourceType":"module"}