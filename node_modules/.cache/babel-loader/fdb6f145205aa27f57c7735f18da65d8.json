{"ast":null,"code":"/* eslint-disable */\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { Persona, Scene, UserMedia } from '@soulmachines/smwebsdk';\nimport to from 'await-to-js';\nimport MicRecorder from 'mic-recorder-to-mp3';\nimport axios from 'axios';\nimport FormData from 'form-data';\nimport proxyVideo, { mediaStreamProxy } from '../../proxyVideo';\nimport roundObject from '../../utils/roundObject';\nimport { meatballString } from './meatball';\nconst ORCHESTRATION_MODE = process.env.REACT_APP_ORCHESTRATION_MODE || false;\nconst apiKey = process.env.REACT_APP_API_KEY;\nconst PERSONA_ID = '1';\nconst AUDIO_SAVE_API = process.env.REACT_APP_AUDIO_SAVE_API;\nconst AUDIO_RECORDING = process.env.REACT_APP_AUDIO_RECORDING;\nlet recorderStarted = false; // need to run through this whole thing with the setup scripts too!!!!\n// CAMERA_ID commented out because CUE manages camera\n// const CAMERA_ID = 'CloseUp';\n\nconst initialState = {\n  tosAccepted: true,\n  connected: false,\n  disconnected: false,\n  loading: false,\n  error: null,\n  isMuted: false,\n  typingOnly: false,\n  videoHeight: window.innerHeight,\n  videoWidth: window.innerWidth,\n  transcript: [],\n  activeCards: [],\n  showTermsAndConditions: false,\n  //Store browser Id\n  browserId: null,\n  convoStopped: false,\n  // lets us keep track of whether the content cards were added in this turn\n  cardsAreStale: false,\n  contentCards: {},\n  speechState: 'idle',\n  // NLP gives us results as it processes final user utterance\n  intermediateUserUtterance: '',\n  userSpeaking: false,\n  lastUserUtterance: '',\n  lastPersonaUtterance: '',\n  user: {\n    activity: {\n      isAttentive: 0,\n      isTalking: 0\n    },\n    emotion: {\n      confusion: 0,\n      negativity: 0,\n      positivity: 0,\n      confidence: 0\n    },\n    conversation: {\n      turn: '',\n      context: {\n        FacePresent: 0,\n        PersonaTurn_IsAttentive: 0,\n        PersonaTurn_IsTalking: null,\n        Persona_Turn_Confusion: null,\n        Persona_Turn_Negativity: null,\n        Persona_Turn_Positivity: null,\n        UserTurn_IsAttentive: 0,\n        UserTurn_IsTalking: null,\n        User_Turn_Confusion: null,\n        User_Turn_Negativity: null,\n        User_Turn_Positivity: null\n      }\n    }\n  },\n  callQuality: {\n    audio: {\n      bitrate: null,\n      packetsLost: null,\n      roundTripTime: null\n    },\n    video: {\n      bitrate: null,\n      packetsLost: null,\n      roundTripTime: null\n    }\n  },\n  cameraOn: false,\n  // default to 1 because these values are used to compute an aspect ratio,\n  // so if for some reason the camera is disabled, it will default to a square (1:1)\n  cameraWidth: 1,\n  cameraHeight: 1,\n  showTranscript: false\n}; // host actions object since we need the types to be available for\n// async calls later, e.g. handling messages from persona\n\nlet actions;\nlet persona = null;\nlet scene = null;\n/**\n * Animate the camera to the desired settings.\n * See utils/camera.js for help with calculating these.\n *\n * options {\n *   tiltDeg: 0,\n *   orbitDegX: 0,\n *   orbitDegY: 0,\n *   panDeg: 0,\n * }\n */\n// export const animateCamera = createAsyncThunk('sm/animateCamera', ({ options, duration }) => {\n\nexport const animateCamera = createAsyncThunk('sm/animateCamera', () => {\n  if (!scene) console.error('cannot animate camera, scene not initiated!'); // console.warn('manual camera animations are disabled while CUE implementation is in progress');\n  // scene.sendRequest('animateToNamedCamera', {\n  //   cameraName: CAMERA_ID,\n  //   personaId: PERSONA_ID,\n  //   time: duration || 1,\n  //   ...options,\n  // });\n}); // tells persona to stop listening to mic input\n\nexport const mute = createAsyncThunk('sm/mute', async (specifiedMuteState, thunk) => {\n  const {\n    isMuted\n  } = thunk.getState().sm;\n\n  if (scene) {\n    // if arg is a boolean use it, otherwise just toggle.\n    // sometimes events from button clicks are passed in, so we need to filter for that\n    const muteState = typeof specifiedMuteState === 'boolean' ? !!specifiedMuteState : !isMuted;\n    if (muteState === true) scene.stopRecognize();else scene.startRecognize();\n    thunk.dispatch(actions.setMute({\n      isMuted: muteState\n    }));\n  } else {\n    console.warn('muting not possible, no active scene!');\n  }\n}); // handles both manual disconnect or automatic timeout due to inactivity\n\nexport const disconnect = createAsyncThunk('sm/disconnect', async (args, thunk) => {\n  if (scene) scene.disconnect();\n  setTimeout(() => {\n    thunk.dispatch(actions.disconnect());\n    scene = null;\n    persona = null;\n  }, 500);\n});\nexport const createScene = createAsyncThunk('sm/createScene', async function () {\n  let typingOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  let thunk = arguments.length > 1 ? arguments[1] : undefined;\n\n  /* CREATE SCENE */\n  if (scene instanceof Scene) {\n    return console.error('warning! you attempted to create a new scene, when one already exists!');\n  } // request permissions from user and create instance of Scene and ask for webcam/mic permissions\n\n\n  const {\n    microphone,\n    microphoneAndCamera,\n    none\n  } = UserMedia;\n\n  try {\n    const sceneOpts = {\n      videoElement: proxyVideo,\n      // audio only toggle, but this is set automatically if user denies camera permissions.\n      // change value if your application needs to have an explicit audio-only mode.\n      stopSpeakingWhenNotVisible: false,\n      audioOnly: false,\n      apiKey: apiKey\n    };\n    scene = new Scene(sceneOpts);\n  } catch (e) {\n    console.error(e);\n  } // New instance of the audio recorder\n\n\n  const recorder = new MicRecorder({\n    bitRate: 128\n  });\n  /* BIND HANDLERS */\n\n  scene.onDisconnected = () => thunk.dispatch(disconnect()); // store a ref to the smwebsdk onmessage so that we can\n  // use the callback while also calling the internal version\n\n\n  const smwebsdkOnMessage = scene.onMessage.bind(scene);\n\n  scene.onMessage = message => {\n    // removing this will break smwebsdk eventing, call smwebsdk's message handler\n    smwebsdkOnMessage(message);\n\n    switch (message.name) {\n      // handles output from TTS (what user said)\n      case 'recognizeResults':\n        {\n          if (AUDIO_RECORDING && !recorderStarted) {\n            recorderStarted = true; // The user started to talk so let's record\n\n            recorder.start().then(() => {//console.log('we are recording');\n            }).catch(e => {\n              console.error(e);\n            });\n          }\n\n          const output = message.body.results[0]; // sometimes we get an empty message, catch and log\n\n          if (!output) {\n            console.warn('undefined output!', message.body);\n            return false;\n          }\n\n          const {\n            transcript: text\n          } = output.alternatives[0]; // we get multiple recognizeResults messages, so only add the final one to transcript\n          // but keep track of intermediate one to show the user what they're saying\n\n          if (output.final === false) {\n            return thunk.dispatch(actions.setIntermediateUserUtterance({\n              text\n            }));\n          }\n\n          return thunk.dispatch(actions.addConversationResult({\n            source: 'user',\n            text\n          }));\n        }\n      // handles output from NLP (what DP is saying)\n\n      case 'personaResponse':\n        {\n          const {\n            currentSpeech\n          } = message.body;\n          const {\n            cardsAreStale\n          } = thunk.getState().sm;\n          if (cardsAreStale === true) thunk.dispatch(actions.setActiveCards({}));\n          thunk.dispatch(actions.addConversationResult({\n            source: 'persona',\n            text: currentSpeech\n          }));\n          break;\n        }\n\n      case 'conversationResponse':\n        {\n          const {\n            currentSpeech\n          } = message.body;\n          const {\n            cardsAreStale\n          } = thunk.getState().sm;\n          if (cardsAreStale === true) thunk.dispatch(actions.setActiveCards({}));\n          thunk.dispatch(actions.addConversationResult({\n            source: 'persona',\n            text: currentSpeech\n          }));\n          break;\n        }\n      // handle speech markers\n\n      case 'speechMarker':\n        {\n          const {\n            name: speechMarkerName,\n            arguments: args\n          } = message.body;\n\n          switch (speechMarkerName) {\n            case 'showcards':\n              {\n                const {\n                  activeCards,\n                  contentCards,\n                  cardsAreStale\n                } = thunk.getState().sm; // if desired, multiple content cards can be displayed in one turn\n\n                const oldCards = cardsAreStale ? [] : activeCards; // this will only ever be one card\n\n                const newCards = args.map(a => ({\n                  id: a,\n                  ...contentCards[a]\n                }));\n                const newActiveCards = [...oldCards, ...newCards];\n                thunk.dispatch(actions.setActiveCards({\n                  activeCards: newActiveCards\n                })); // send card to transcript as well\n\n                thunk.dispatch(actions.addConversationResult({\n                  source: 'persona',\n                  card: newCards[0]\n                }));\n                break;\n              }\n\n            case 'hidecards':\n              {\n                thunk.dispatch(actions.setActiveCards({}));\n                break;\n              }\n\n            case 'cinematic':\n              {\n                // fired when CUE changes camera angles\n                break;\n              }\n\n            case 'amirtest':\n              {\n                console.log('HELLO WORLD ITS A TEST');\n                break;\n              }\n\n            case 'feature':\n              {\n                const {\n                  arguments: featureArgs\n                } = message.body;\n                const feature = featureArgs[0];\n                const featureState = featureArgs[1];\n\n                switch (feature) {\n                  case 'microphone':\n                    {\n                      if (featureState === 'on') thunk.dispatch(mute(false));else if (featureState === 'off') thunk.dispatch(mute(true));else console.error(`state ${featureState} not supported by @feature(microphone)!`);\n                      break;\n                    }\n\n                  case 'transcript':\n                    {\n                      if (featureState === 'on') thunk.dispatch(actions.setShowTranscript(true));else if (featureState === 'off') thunk.dispatch(actions.setShowTranscript(false));else console.error(`state ${featureState} not supported by @feature(transcript)!`);\n                      break;\n                    }\n\n                  default:\n                    {\n                      console.error(`@feature(${feature}) not recognized!`);\n                    }\n                }\n\n                break;\n              }\n\n            case 'close':\n              {\n                thunk.dispatch(disconnect());\n                break;\n              }\n\n            case 'marker':\n              {\n                // custom speech marker handler\n                const {\n                  arguments: markerArgs\n                } = message.body;\n                markerArgs.forEach(a => {\n                  switch (a) {\n                    // \"easter egg\" speech marker, prints ASCII \"summoned meatball\" to console\n                    case 'triggerMeatball':\n                      {\n                        console.log(meatballString);\n                        break;\n                      }\n\n                    default:\n                      {\n                        console.warn(`no handler for @marker(${a})!`);\n                      }\n                  }\n                });\n                break;\n              }\n\n            default:\n              {\n                console.warn(`unregonized speech marker: ${speechMarkerName}`);\n              }\n          }\n\n          break;\n        }\n\n      case 'updateContentAwareness':\n        {\n          // fired when content awareness changes\n          // eg an element w/ data-sm-content enters/exits DOM\n          break;\n        }\n\n      case 'conversationSend':\n        {\n          // fired when the user manually types in some input\n          // we handle this elsewhere so we don't need to handle this event\n          break;\n        }\n      // pull out content card data from contexts\n\n      case 'conversationResult':\n        {\n          var _message$body, _message$body$provide, _message$body$provide2, _message$body$provide3, _message$body$provide4;\n\n          // get content cards from context\n          const {\n            context\n          } = message.body.output; // filter out $cardName.original, we just want values for $cardName\n\n          const relevantKeys = Object.keys(context).filter(k => /\\.original/gm.test(k) === false);\n          let contentCards = {};\n          relevantKeys.forEach(k => {\n            // remove public- prefix from key\n            const cardKey = k.match(/public-(.*)/m)[1];\n\n            try {\n              contentCards[cardKey] = JSON.parse(context[k]);\n            } catch {\n              console.error(`invalid JSON in content card payload for ${k}!`);\n            }\n          }); // also consume DF custom payload\n\n          const fulfillmentMessages = (_message$body = message.body) === null || _message$body === void 0 ? void 0 : (_message$body$provide = _message$body.provider) === null || _message$body$provide === void 0 ? void 0 : (_message$body$provide2 = _message$body$provide.meta) === null || _message$body$provide2 === void 0 ? void 0 : (_message$body$provide3 = _message$body$provide2.dialogflow) === null || _message$body$provide3 === void 0 ? void 0 : (_message$body$provide4 = _message$body$provide3.queryResult) === null || _message$body$provide4 === void 0 ? void 0 : _message$body$provide4.fulfillmentMessages;\n\n          if (fulfillmentMessages) {\n            fulfillmentMessages.forEach(m => {\n              if ('payload' in m && 'soulmachines' in m.payload) {\n                contentCards = { ...contentCards,\n                  ...m.payload.soulmachines\n                };\n              }\n            });\n          }\n\n          thunk.dispatch(actions.addContentCards({\n            contentCards\n          }));\n\n          if (recorderStarted) {\n            recorderStarted = false; // The user is done talking so let's stop the recording and save the file\n\n            recorder.stop().getMp3().then(_ref => {\n              let [buffer, blob] = _ref;\n              // get the file data  and save to MP3\n              const file = new File(buffer, parseInt(Date.now() / 1000) + '.mp3', {\n                type: blob.type,\n                lastModified: Date.now()\n              }); // Create form data to send in the POST\n\n              const formData = new FormData();\n              formData.append('file', file); // POST request configuration\n\n              const requestConfig = {\n                method: 'post',\n                url: AUDIO_SAVE_API,\n                headers: {\n                  'Content-Type': 'multipart/form-data'\n                },\n                data: formData\n              }; // Post to backend\n\n              axios.request(requestConfig);\n            }).catch(e => {\n              //alert('Could not create get and create the audio recording');\n              console.log('recording fail error', e);\n            });\n          }\n\n          break;\n        }\n      // state messages contain a lot of things, including user emotions,\n      // call stats, and persona state\n\n      case 'state':\n        {\n          const {\n            body\n          } = message;\n\n          if ('persona' in body) {\n            const personaState = body.persona[1]; // handle changes to persona speech state ie idle, animating, speaking\n\n            if ('speechState' in personaState) {\n              const {\n                speechState\n              } = personaState;\n              const action = actions.setSpeechState({\n                speechState\n              }); // when DP starts idling ie its turn ends, set contentCardsStale to true\n\n              if (speechState === 'idle') {\n                const {\n                  activeCards\n                } = thunk.getState().sm;\n                thunk.dispatch(actions.setActiveCards({\n                  activeCards,\n                  cardsAreStale: true\n                }));\n              }\n\n              thunk.dispatch(action);\n            }\n\n            if ('users' in personaState) {\n              // handle various numeric values such as user emotion or\n              // probability that the user is talking\n              const userState = personaState.users[0];\n\n              if ('emotion' in userState) {\n                const {\n                  emotion\n                } = userState;\n                const roundedEmotion = roundObject(emotion);\n                const action = actions.setEmotionState({\n                  emotion: roundedEmotion\n                });\n                thunk.dispatch(action);\n              }\n\n              if ('activity' in userState) {\n                const {\n                  activity\n                } = userState;\n                const roundedActivity = roundObject(activity, 1000);\n                const action = actions.setEmotionState({\n                  activity: roundedActivity\n                });\n                thunk.dispatch(action);\n              }\n\n              if ('conversation' in userState) {\n                const {\n                  conversation\n                } = userState;\n                const {\n                  context\n                } = conversation;\n                const roundedContext = roundObject(context);\n                const action = actions.setConversationState({\n                  conversation: { ...conversation,\n                    context: roundedContext\n                  }\n                });\n                thunk.dispatch(action);\n              }\n            }\n          } else if ('statistics' in body) {\n            const {\n              callQuality\n            } = body.statistics;\n            thunk.dispatch(actions.setCallQuality({\n              callQuality\n            }));\n          }\n\n          break;\n        }\n      // activation events are some kind of emotional metadata\n\n      case 'activation':\n        {\n          // console.warn('activation handler not yet implemented', message);\n          break;\n        }\n      // animateToNamedCamera events are triggered whenever we change the camera angle.\n      // left unimplemented for now since there is only one named camera (closeUp)\n\n      case 'animateToNamedCamera':\n        {\n          // console.warn('animateToNamedCamera handler not yet implemented', message);\n          break;\n        }\n\n      case 'stopRecognize':\n        {\n          break;\n        }\n\n      case 'startRecognize':\n        {\n          break;\n        }\n\n      case 'stopSpeaking':\n        {\n          break;\n        }\n\n      default:\n        {\n          console.warn(`unknown message type: ${message.name}`, message);\n        }\n    }\n\n    return true;\n  }; // create instance of Persona class w/ scene instance\n\n\n  persona = new Persona(scene, PERSONA_ID);\n  /* CONNECT TO PERSONA */\n\n  try {\n    // connect to Persona server\n    const retryOptions = {\n      maxRetries: 20,\n      delayMs: 500\n    };\n    const [err, sessionID] = await to(scene.connect(retryOptions));\n\n    if (err) {\n      switch (err.name) {\n        case 'notSupported':\n        case 'noUserMedia':\n          {\n            return thunk.rejectWithValue({\n              msg: 'permissionsDenied',\n              err: { ...err\n              }\n            });\n          }\n\n        default:\n          {\n            return thunk.rejectWithValue({\n              msg: 'generic',\n              err: { ...err\n              }\n            });\n          }\n      }\n    } // we can't disable logging until after the connection is established\n    // logging is pretty crowded, not recommended to enable\n    // unless you need to debug emotional data from webcam\n\n\n    scene.session().setLogging(false); // set video dimensions\n\n    const {\n      videoWidth,\n      videoHeight\n    } = thunk.getState().sm; // calc resolution w/ device pixel ratio\n\n    const deviceWidth = Math.round(videoWidth * window.devicePixelRatio);\n    const deviceHeight = Math.round(videoHeight * window.devicePixelRatio);\n    scene.sendVideoBounds(deviceWidth, deviceHeight); // create proxy of webcam video feed if user has granted us permission\n    // since we can't store the userMediaStream in the store since it's not serializable,\n    // we use an external proxy for video streams\n\n    const {\n      userMediaStream: stream\n    } = scene.session(); // detect if we're running audio-only\n\n    const videoEnabled = typingOnly === false && stream !== undefined && stream.getVideoTracks().length > 0;\n    if (videoEnabled === false) thunk.dispatch(actions.setCameraState({\n      cameraOn: false\n    }));\n    if (typingOnly === true) thunk.dispatch(actions.setTypingOnly()); // pass dispatch before calling setUserMediaStream so proxy can send dimensions to store\n\n    mediaStreamProxy.passDispatch(thunk.dispatch);\n    mediaStreamProxy.setUserMediaStream(stream, videoEnabled);\n    mediaStreamProxy.enableToggle(scene); // fulfill promise, reducer sets state to indicate loading and connection are complete\n\n    return thunk.fulfillWithValue();\n  } catch (err) {\n    return thunk.rejectWithValue(err);\n  }\n}); // send plain text to the persona.\n// usually used for typed input or UI elems that trigger a certain phrase\n\nexport const sendTextMessage = createAsyncThunk('sm/sendTextMessage', async (_ref2, thunk) => {\n  let {\n    text\n  } = _ref2;\n  console.log(`SENDTEXTMESSAGETEXT: ${text}`);\n  if (text === '') return thunk.rejectWithValue('submitted empty string!');\n\n  if (scene !== null && persona !== null) {\n    persona.conversationSend(text);\n    return thunk.dispatch(actions.addConversationResult({\n      source: 'user',\n      text\n    }));\n  }\n\n  return thunk.rejectWithValue('not connected to persona!');\n}); // send plain text to the persona.\n// usually used for typed input or UI elems that trigger a certain phrase\n// export const sendTextMessage = createAsyncThunk('sm/sendTextMessage', async ({ text }, thunk) => {\n//   console.log(`SENDTEXTMESSAGETEXT: ${text}`);\n//   if (scene && persona) {\n//     if (ORCHESTRATION_MODE === true) scene.sendUserText(text);\n//     else persona.conversationSend(text);\n//     thunk.dispatch(\n//       actions.addConversationResult({\n//         source: 'user',\n//         text,\n//       }),\n//     );\n//   } else thunk.rejectWithValue('not connected to persona!');\n// });\n\nexport const sendEvent = createAsyncThunk('sm/sendEvent', async _ref3 => {\n  let {\n    payload,\n    eventName\n  } = _ref3;\n\n  if (scene && persona) {\n    persona.conversationSend(eventName, payload || {}, {\n      kind: 'event'\n    });\n    console.log(`dispatched ${eventName}`, payload);\n  }\n});\nexport const keepAlive = createAsyncThunk('sm/keepAlive', async () => {\n  if (scene) {\n    scene.keepAlive();\n  }\n});\nconst smSlice = createSlice({\n  name: 'sm',\n  initialState,\n  reducers: {\n    setTOS: (state, _ref4) => {\n      let {\n        payload\n      } = _ref4;\n      return { ...state,\n        tosAccepted: payload.accepted\n      };\n    },\n    setShowTermsAndConditions: (state, _ref5) => {\n      let {\n        payload\n      } = _ref5;\n      return { ...state,\n        showTermsAndConditions: !state.showTermsAndConditions\n      };\n    },\n    setShowTranscript: (state, _ref6) => {\n      let {\n        payload\n      } = _ref6;\n      return { ...state,\n        showTranscript: (payload === null || payload === void 0 ? void 0 : payload.showTranscript) || !state.showTranscript\n      };\n    },\n    setHideTranscript: (state, _ref7) => {\n      let {\n        payload\n      } = _ref7;\n      return { ...state,\n        showTranscript: (payload === null || payload === void 0 ? void 0 : payload.showTranscript) || false\n      };\n    },\n    setBrowserId: (state, _ref8) => {\n      let {\n        payload\n      } = _ref8;\n      console.log(`set id ran: ${JSON.stringify(payload, null, 2)}`);\n      return { ...state,\n        browserId: payload === null || payload === void 0 ? void 0 : payload.browserId\n      };\n    },\n    setConvoStopped: (state, _ref9) => {\n      let {\n        payload\n      } = _ref9;\n      console.log(`set convo stop ran: ${JSON.stringify(payload, null, 2)}`);\n      return { ...state,\n        convoStopped: payload === null || payload === void 0 ? void 0 : payload.convoStopped\n      };\n    },\n    setTypingOnly: state => ({ ...state,\n      typingOnly: true\n    }),\n    setCameraState: (state, _ref10) => {\n      let {\n        payload\n      } = _ref10;\n      return { ...state,\n        cameraOn: payload.cameraOn,\n        cameraWidth: payload.cameraWidth || state.cameraWidth,\n        cameraHeight: payload.cameraHeight || state.cameraHeight\n      };\n    },\n    setActiveCards: (state, _ref11) => {\n      let {\n        payload\n      } = _ref11;\n      return { ...state,\n        activeCards: payload.activeCards || [],\n        cardsAreStale: payload.cardsAreStale || false\n      };\n    },\n    // content cards with the same key may get overwritten, so when the card is called\n    // in @showCards(), we copy to transcript: [] and activeCards: []\n    addContentCards: (state, _ref12) => {\n      let {\n        payload\n      } = _ref12;\n      return { ...state,\n        contentCards: { ...state.contentCards,\n          ...payload.contentCards\n        }\n      };\n    },\n    stopSpeaking: state => {\n      if (persona) persona.stopSpeaking();\n      return { ...state\n      };\n    },\n    setMute: (state, _ref13) => {\n      let {\n        payload\n      } = _ref13;\n      return { ...state,\n        isMuted: payload.isMuted\n      };\n    },\n    setIntermediateUserUtterance: (state, _ref14) => {\n      let {\n        payload\n      } = _ref14;\n      return { ...state,\n        intermediateUserUtterance: payload.text,\n        userSpeaking: true\n      };\n    },\n    resetTranscript: state => ({ ...state,\n      transcript: [],\n      activeCards: []\n    }),\n    addConversationResult: (state, _ref15) => {\n      let {\n        payload\n      } = _ref15;\n\n      // we record both text and content cards in the transcript\n      if (payload.text !== '' || 'card' in payload !== false) {\n        const {\n          source\n        } = payload;\n        const newEntry = {\n          source,\n          timestamp: new Date().toISOString()\n        }; // handle entering either text or card into transcript array\n\n        if ('text' in payload) newEntry.text = payload.text;\n        if ('card' in payload) newEntry.card = payload.card;\n        const out = { ...state,\n          transcript: [...state.transcript, { ...newEntry\n          }],\n          intermediateUserUtterance: '',\n          userSpeaking: false\n        }; // copy any text to last___Utterance, used for captions and user confirmation of STT\n\n        if ('text' in payload) {\n          out[payload.source === 'user' ? 'lastUserUtterance' : 'lastPersonaUtterance'] = payload.text;\n        }\n\n        return out;\n      }\n\n      return console.warn('addConversationResult: ignoring empty string');\n    },\n    setSpeechState: (state, _ref16) => {\n      let {\n        payload\n      } = _ref16;\n      return { ...state,\n        speechState: payload.speechState\n      };\n    },\n    setEmotionState: (state, _ref17) => {\n      let {\n        payload\n      } = _ref17;\n      return { ...state,\n        user: { ...state.user,\n          emotion: payload.emotion\n        }\n      };\n    },\n    setConversationState: (state, _ref18) => {\n      let {\n        payload\n      } = _ref18;\n      return { ...state,\n        user: { ...state.user,\n          conversation: payload.conversation\n        }\n      };\n    },\n    setActivityState: (state, _ref19) => {\n      let {\n        payload\n      } = _ref19;\n      return { ...state,\n        user: { ...state.user,\n          activity: payload.activity\n        }\n      };\n    },\n    setCallQuality: (state, _ref20) => {\n      let {\n        payload\n      } = _ref20;\n      return { ...state,\n        callQuality: payload.callQuality\n      };\n    },\n    setVideoDimensions: (state, _ref21) => {\n      let {\n        payload\n      } = _ref21;\n      const {\n        videoWidth,\n        videoHeight\n      } = payload; // update video dimensions in persona\n      // calc resolution w/ device pixel ratio\n\n      const deviceWidth = Math.round(videoWidth * window.devicePixelRatio);\n      const deviceHeight = Math.round(videoHeight * window.devicePixelRatio);\n      scene.sendVideoBounds(deviceWidth, deviceHeight);\n      return { ...state,\n        videoWidth,\n        videoHeight\n      };\n    },\n    disconnect: state => {\n      scene = null;\n      persona = null;\n      const {\n        error\n      } = state;\n      return { // completely reset SM state on disconnect, except for errors\n        ...initialState,\n        disconnected: true,\n        error\n      };\n    }\n  },\n  extraReducers: {\n    [createScene.pending]: state => ({ ...state,\n      loading: true,\n      disconnected: false,\n      error: null\n    }),\n    [createScene.fulfilled]: state => ({ ...state,\n      loading: false,\n      connected: true,\n      error: null\n    }),\n    [createScene.rejected]: (state, _ref22) => {\n      let {\n        payload\n      } = _ref22;\n      scene.disconnect(); // if we call this immediately the disconnect call might not complete\n\n      setTimeout(() => {\n        scene = null;\n        persona = null;\n      }, 100);\n      return { ...state,\n        loading: false,\n        connected: false,\n        error: { ...payload\n        }\n      };\n    }\n  }\n}); // hoist actions to top of file so thunks can access\n\nactions = smSlice.actions;\nexport const {\n  setVideoDimensions,\n  stopSpeaking,\n  setActiveCards,\n  setCameraState,\n  setShowTranscript,\n  setHideTranscript,\n  setShowTermsAndConditions,\n  setTOS,\n  resetTranscript,\n  setBrowserId,\n  setConvoStopped\n} = smSlice.actions;\nexport default smSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","Persona","Scene","UserMedia","to","MicRecorder","axios","FormData","proxyVideo","mediaStreamProxy","roundObject","meatballString","ORCHESTRATION_MODE","process","env","REACT_APP_ORCHESTRATION_MODE","apiKey","REACT_APP_API_KEY","PERSONA_ID","AUDIO_SAVE_API","REACT_APP_AUDIO_SAVE_API","AUDIO_RECORDING","REACT_APP_AUDIO_RECORDING","recorderStarted","initialState","tosAccepted","connected","disconnected","loading","error","isMuted","typingOnly","videoHeight","window","innerHeight","videoWidth","innerWidth","transcript","activeCards","showTermsAndConditions","browserId","convoStopped","cardsAreStale","contentCards","speechState","intermediateUserUtterance","userSpeaking","lastUserUtterance","lastPersonaUtterance","user","activity","isAttentive","isTalking","emotion","confusion","negativity","positivity","confidence","conversation","turn","context","FacePresent","PersonaTurn_IsAttentive","PersonaTurn_IsTalking","Persona_Turn_Confusion","Persona_Turn_Negativity","Persona_Turn_Positivity","UserTurn_IsAttentive","UserTurn_IsTalking","User_Turn_Confusion","User_Turn_Negativity","User_Turn_Positivity","callQuality","audio","bitrate","packetsLost","roundTripTime","video","cameraOn","cameraWidth","cameraHeight","showTranscript","actions","persona","scene","animateCamera","console","mute","specifiedMuteState","thunk","getState","sm","muteState","stopRecognize","startRecognize","dispatch","setMute","warn","disconnect","args","setTimeout","createScene","microphone","microphoneAndCamera","none","sceneOpts","videoElement","stopSpeakingWhenNotVisible","audioOnly","e","recorder","bitRate","onDisconnected","smwebsdkOnMessage","onMessage","bind","message","name","start","then","catch","output","body","results","text","alternatives","final","setIntermediateUserUtterance","addConversationResult","source","currentSpeech","setActiveCards","speechMarkerName","arguments","oldCards","newCards","map","a","id","newActiveCards","card","log","featureArgs","feature","featureState","setShowTranscript","markerArgs","forEach","relevantKeys","Object","keys","filter","k","test","cardKey","match","JSON","parse","fulfillmentMessages","provider","meta","dialogflow","queryResult","m","payload","soulmachines","addContentCards","stop","getMp3","buffer","blob","file","File","parseInt","Date","now","type","lastModified","formData","append","requestConfig","method","url","headers","data","request","personaState","action","setSpeechState","userState","users","roundedEmotion","setEmotionState","roundedActivity","roundedContext","setConversationState","statistics","setCallQuality","retryOptions","maxRetries","delayMs","err","sessionID","connect","rejectWithValue","msg","session","setLogging","deviceWidth","Math","round","devicePixelRatio","deviceHeight","sendVideoBounds","userMediaStream","stream","videoEnabled","undefined","getVideoTracks","length","setCameraState","setTypingOnly","passDispatch","setUserMediaStream","enableToggle","fulfillWithValue","sendTextMessage","conversationSend","sendEvent","eventName","kind","keepAlive","smSlice","reducers","setTOS","state","accepted","setShowTermsAndConditions","setHideTranscript","setBrowserId","stringify","setConvoStopped","stopSpeaking","resetTranscript","newEntry","timestamp","toISOString","out","setActivityState","setVideoDimensions","extraReducers","pending","fulfilled","rejected","reducer"],"sources":["/Users/sofiaweinzierl/Desktop/sm-neuralseek-ibm/react-ui/src/store/sm/index.js"],"sourcesContent":["/* eslint-disable */\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { Persona, Scene, UserMedia } from '@soulmachines/smwebsdk'\nimport to from 'await-to-js';\nimport MicRecorder from 'mic-recorder-to-mp3';\nimport axios from 'axios';\nimport FormData from 'form-data';\nimport proxyVideo, { mediaStreamProxy } from '../../proxyVideo';\nimport roundObject from '../../utils/roundObject';\nimport { meatballString } from './meatball';\n\nconst ORCHESTRATION_MODE = process.env.REACT_APP_ORCHESTRATION_MODE || false;\nconst apiKey = process.env.REACT_APP_API_KEY;\nconst PERSONA_ID = '1';\n\nconst AUDIO_SAVE_API = process.env.REACT_APP_AUDIO_SAVE_API;\nconst AUDIO_RECORDING = process.env.REACT_APP_AUDIO_RECORDING;\nlet recorderStarted = false;\n\n// need to run through this whole thing with the setup scripts too!!!!\n\n// CAMERA_ID commented out because CUE manages camera\n// const CAMERA_ID = 'CloseUp';\n\nconst initialState = {\n  tosAccepted: true,\n  connected: false,\n  disconnected: false,\n  loading: false,\n  error: null,\n  isMuted: false,\n  typingOnly: false,\n  videoHeight: window.innerHeight,\n  videoWidth: window.innerWidth,\n  transcript: [],\n  activeCards: [],\n  showTermsAndConditions: false,\n  //Store browser Id\n  browserId: null,\n  convoStopped: false,\n  // lets us keep track of whether the content cards were added in this turn\n  cardsAreStale: false,\n  contentCards: {},\n  speechState: 'idle',\n  // NLP gives us results as it processes final user utterance\n  intermediateUserUtterance: '',\n  userSpeaking: false,\n  lastUserUtterance: '',\n  lastPersonaUtterance: '',\n  user: {\n    activity: {\n      isAttentive: 0,\n      isTalking: 0,\n    },\n    emotion: {\n      confusion: 0,\n      negativity: 0,\n      positivity: 0,\n      confidence: 0,\n    },\n    conversation: {\n      turn: '',\n      context: {\n        FacePresent: 0,\n        PersonaTurn_IsAttentive: 0,\n        PersonaTurn_IsTalking: null,\n        Persona_Turn_Confusion: null,\n        Persona_Turn_Negativity: null,\n        Persona_Turn_Positivity: null,\n        UserTurn_IsAttentive: 0,\n        UserTurn_IsTalking: null,\n        User_Turn_Confusion: null,\n        User_Turn_Negativity: null,\n        User_Turn_Positivity: null,\n      },\n    },\n  },\n  callQuality: {\n    audio: {\n      bitrate: null,\n      packetsLost: null,\n      roundTripTime: null,\n    },\n    video: {\n      bitrate: null,\n      packetsLost: null,\n      roundTripTime: null,\n    },\n  },\n  cameraOn: false,\n  // default to 1 because these values are used to compute an aspect ratio,\n  // so if for some reason the camera is disabled, it will default to a square (1:1)\n  cameraWidth: 1,\n  cameraHeight: 1,\n  showTranscript: false,\n};\n\n// host actions object since we need the types to be available for\n// async calls later, e.g. handling messages from persona\nlet actions;\nlet persona = null;\nlet scene = null;\n\n/**\n * Animate the camera to the desired settings.\n * See utils/camera.js for help with calculating these.\n *\n * options {\n *   tiltDeg: 0,\n *   orbitDegX: 0,\n *   orbitDegY: 0,\n *   panDeg: 0,\n * }\n */\n// export const animateCamera = createAsyncThunk('sm/animateCamera', ({ options, duration }) => {\nexport const animateCamera = createAsyncThunk('sm/animateCamera', () => {\n  if (!scene) console.error('cannot animate camera, scene not initiated!');\n\n  // console.warn('manual camera animations are disabled while CUE implementation is in progress');\n  // scene.sendRequest('animateToNamedCamera', {\n  //   cameraName: CAMERA_ID,\n  //   personaId: PERSONA_ID,\n  //   time: duration || 1,\n  //   ...options,\n  // });\n});\n\n// tells persona to stop listening to mic input\nexport const mute = createAsyncThunk('sm/mute', async (specifiedMuteState, thunk) => {\n  const { isMuted } = thunk.getState().sm;\n  if (scene) {\n    // if arg is a boolean use it, otherwise just toggle.\n    // sometimes events from button clicks are passed in, so we need to filter for that\n    const muteState = typeof specifiedMuteState === 'boolean' ? !!specifiedMuteState : !isMuted;\n    if (muteState === true) scene.stopRecognize();\n    else scene.startRecognize();\n    thunk.dispatch(actions.setMute({ isMuted: muteState }));\n  } else {\n    console.warn('muting not possible, no active scene!');\n  }\n});\n\n// handles both manual disconnect or automatic timeout due to inactivity\nexport const disconnect = createAsyncThunk('sm/disconnect', async (args, thunk) => {\n  if (scene) scene.disconnect();\n  setTimeout(() => {\n    thunk.dispatch(actions.disconnect());\n    scene = null;\n    persona = null;\n  }, 500);\n});\n\nexport const createScene = createAsyncThunk('sm/createScene', async (typingOnly = false, thunk) => {\n  /* CREATE SCENE */\n  if (scene instanceof Scene) {\n    return console.error('warning! you attempted to create a new scene, when one already exists!');\n  }\n  // request permissions from user and create instance of Scene and ask for webcam/mic permissions\n  const { microphone, microphoneAndCamera, none } = UserMedia;\n  try {\n    const sceneOpts = {\n      videoElement: proxyVideo,\n      // audio only toggle, but this is set automatically if user denies camera permissions.\n      // change value if your application needs to have an explicit audio-only mode.\n      stopSpeakingWhenNotVisible: false,\n      audioOnly: false,\n      apiKey: apiKey\n    };\n    scene = new Scene(sceneOpts);\n  } catch (e) {\n    console.error(e);\n  }\n\n  // New instance of the audio recorder\n  const recorder = new MicRecorder({\n    bitRate: 128,\n  });\n\n  /* BIND HANDLERS */\n  scene.onDisconnected = () => thunk.dispatch(disconnect());\n  // store a ref to the smwebsdk onmessage so that we can\n  // use the callback while also calling the internal version\n  const smwebsdkOnMessage = scene.onMessage.bind(scene);\n  scene.onMessage = (message) => {\n    // removing this will break smwebsdk eventing, call smwebsdk's message handler\n    smwebsdkOnMessage(message);\n    switch (message.name) {\n      // handles output from TTS (what user said)\n      case 'recognizeResults': {\n        if (AUDIO_RECORDING && !recorderStarted) {\n          recorderStarted = true;\n          // The user started to talk so let's record\n          recorder\n            .start()\n            .then(() => {\n              //console.log('we are recording');\n            })\n            .catch((e) => {\n              console.error(e);\n            });\n        }\n\n        const output = message.body.results[0];\n        // sometimes we get an empty message, catch and log\n        if (!output) {\n          console.warn('undefined output!', message.body);\n          return false;\n        }\n        const { transcript: text } = output.alternatives[0];\n        // we get multiple recognizeResults messages, so only add the final one to transcript\n        // but keep track of intermediate one to show the user what they're saying\n        if (output.final === false) {\n          return thunk.dispatch(\n            actions.setIntermediateUserUtterance({\n              text,\n            }),\n          );\n        }\n        return thunk.dispatch(\n          actions.addConversationResult({\n            source: 'user',\n            text,\n          }),\n        );\n      }\n\n      // handles output from NLP (what DP is saying)\n      case 'personaResponse': {\n        const { currentSpeech } = message.body;\n        const { cardsAreStale } = thunk.getState().sm;\n        if (cardsAreStale === true) thunk.dispatch(actions.setActiveCards({}));\n        thunk.dispatch(\n          actions.addConversationResult({\n            source: 'persona',\n            text: currentSpeech,\n          }),\n        );\n        break;\n      }\n\n      case 'conversationResponse': {\n        const { currentSpeech } = message.body;\n        const { cardsAreStale } = thunk.getState().sm;\n        if (cardsAreStale === true) thunk.dispatch(actions.setActiveCards({}));\n        thunk.dispatch(\n          actions.addConversationResult({\n            source: 'persona',\n            text: currentSpeech,\n          }),\n        );\n        break;\n      }\n\n      // handle speech markers\n      case 'speechMarker': {\n        const { name: speechMarkerName, arguments: args } = message.body;\n        switch (speechMarkerName) {\n          case 'showcards': {\n            const { activeCards, contentCards, cardsAreStale } = thunk.getState().sm;\n            // if desired, multiple content cards can be displayed in one turn\n            const oldCards = cardsAreStale ? [] : activeCards;\n            // this will only ever be one card\n            const newCards = args.map((a) => ({ id: a, ...contentCards[a] }));\n            const newActiveCards = [...oldCards, ...newCards];\n            thunk.dispatch(actions.setActiveCards({ activeCards: newActiveCards }));\n            // send card to transcript as well\n            thunk.dispatch(\n              actions.addConversationResult({\n                source: 'persona',\n                card: newCards[0],\n              }),\n            );\n            break;\n          }\n          case 'hidecards': {\n            thunk.dispatch(actions.setActiveCards({}));\n            break;\n          }\n          case 'cinematic': {\n            // fired when CUE changes camera angles\n            break;\n          }\n          case 'amirtest': {\n            console.log('HELLO WORLD ITS A TEST');\n            break;\n          }\n          case 'feature': {\n            const { arguments: featureArgs } = message.body;\n            const feature = featureArgs[0];\n            const featureState = featureArgs[1];\n            switch (feature) {\n              case 'microphone': {\n                if (featureState === 'on') thunk.dispatch(mute(false));\n                else if (featureState === 'off') thunk.dispatch(mute(true));\n                else console.error(`state ${featureState} not supported by @feature(microphone)!`);\n                break;\n              }\n              case 'transcript': {\n                if (featureState === 'on') thunk.dispatch(actions.setShowTranscript(true));\n                else if (featureState === 'off') thunk.dispatch(actions.setShowTranscript(false));\n                else console.error(`state ${featureState} not supported by @feature(transcript)!`);\n                break;\n              }\n              default: {\n                console.error(`@feature(${feature}) not recognized!`);\n              }\n            }\n            break;\n          }\n          case 'close': {\n            thunk.dispatch(disconnect());\n            break;\n          }\n          case 'marker': {\n            // custom speech marker handler\n            const { arguments: markerArgs } = message.body;\n            markerArgs.forEach((a) => {\n              switch (a) {\n                // \"easter egg\" speech marker, prints ASCII \"summoned meatball\" to console\n                case 'triggerMeatball': {\n                  console.log(meatballString);\n                  break;\n                }\n                default: {\n                  console.warn(`no handler for @marker(${a})!`);\n                }\n              }\n            });\n            break;\n          }\n          default: {\n            console.warn(`unregonized speech marker: ${speechMarkerName}`);\n          }\n        }\n        break;\n      }\n\n      case 'updateContentAwareness': {\n        // fired when content awareness changes\n        // eg an element w/ data-sm-content enters/exits DOM\n        break;\n      }\n      case 'conversationSend': {\n        // fired when the user manually types in some input\n        // we handle this elsewhere so we don't need to handle this event\n        break;\n      }\n\n      // pull out content card data from contexts\n      case 'conversationResult': {\n        // get content cards from context\n        const { context } = message.body.output;\n\n        // filter out $cardName.original, we just want values for $cardName\n        const relevantKeys = Object.keys(context).filter((k) => /\\.original/gm.test(k) === false);\n        let contentCards = {};\n        relevantKeys.forEach((k) => {\n          // remove public- prefix from key\n          const cardKey = k.match(/public-(.*)/m)[1];\n          try {\n            contentCards[cardKey] = JSON.parse(context[k]);\n          } catch {\n            console.error(`invalid JSON in content card payload for ${k}!`);\n          }\n        });\n        // also consume DF custom payload\n        const fulfillmentMessages =\n          message.body?.provider?.meta?.dialogflow?.queryResult?.fulfillmentMessages;\n        if (fulfillmentMessages) {\n          fulfillmentMessages.forEach((m) => {\n            if ('payload' in m && 'soulmachines' in m.payload) {\n              contentCards = { ...contentCards, ...m.payload.soulmachines };\n            }\n          });\n        }\n        thunk.dispatch(actions.addContentCards({ contentCards }));\n\n        if (recorderStarted) {\n          recorderStarted = false;\n          // The user is done talking so let's stop the recording and save the file\n          recorder\n            .stop()\n            .getMp3()\n            .then(([buffer, blob]) => {\n              // get the file data  and save to MP3\n              const file = new File(buffer, parseInt(Date.now() / 1000) + '.mp3', {\n                type: blob.type,\n                lastModified: Date.now(),\n              });\n              // Create form data to send in the POST\n              const formData = new FormData();\n              formData.append('file', file);\n              // POST request configuration\n              const requestConfig = {\n                method: 'post',\n                url: AUDIO_SAVE_API,\n                headers: {\n                  'Content-Type': 'multipart/form-data',\n                },\n                data: formData,\n              };\n              // Post to backend\n              axios.request(requestConfig);\n            })\n            .catch((e) => {\n              //alert('Could not create get and create the audio recording');\n              console.log('recording fail error', e);\n            });\n        }\n\n        break;\n      }\n\n      // state messages contain a lot of things, including user emotions,\n      // call stats, and persona state\n      case 'state': {\n        const { body } = message;\n        if ('persona' in body) {\n          const personaState = body.persona[1];\n\n          // handle changes to persona speech state ie idle, animating, speaking\n          if ('speechState' in personaState) {\n            const { speechState } = personaState;\n            const action = actions.setSpeechState({ speechState });\n            // when DP starts idling ie its turn ends, set contentCardsStale to true\n            if (speechState === 'idle') {\n              const { activeCards } = thunk.getState().sm;\n              thunk.dispatch(actions.setActiveCards({ activeCards, cardsAreStale: true }));\n            }\n            thunk.dispatch(action);\n          }\n\n          if ('users' in personaState) {\n            // handle various numeric values such as user emotion or\n            // probability that the user is talking\n            const userState = personaState.users[0];\n\n            if ('emotion' in userState) {\n              const { emotion } = userState;\n              const roundedEmotion = roundObject(emotion);\n              const action = actions.setEmotionState({ emotion: roundedEmotion });\n              thunk.dispatch(action);\n            }\n\n            if ('activity' in userState) {\n              const { activity } = userState;\n              const roundedActivity = roundObject(activity, 1000);\n              const action = actions.setEmotionState({ activity: roundedActivity });\n              thunk.dispatch(action);\n            }\n\n            if ('conversation' in userState) {\n              const { conversation } = userState;\n              const { context } = conversation;\n              const roundedContext = roundObject(context);\n              const action = actions.setConversationState({\n                conversation: {\n                  ...conversation,\n                  context: roundedContext,\n                },\n              });\n              thunk.dispatch(action);\n            }\n          }\n        } else if ('statistics' in body) {\n          const { callQuality } = body.statistics;\n          thunk.dispatch(actions.setCallQuality({ callQuality }));\n        }\n        break;\n      }\n\n      // activation events are some kind of emotional metadata\n      case 'activation': {\n        // console.warn('activation handler not yet implemented', message);\n        break;\n      }\n\n      // animateToNamedCamera events are triggered whenever we change the camera angle.\n      // left unimplemented for now since there is only one named camera (closeUp)\n      case 'animateToNamedCamera': {\n        // console.warn('animateToNamedCamera handler not yet implemented', message);\n        break;\n      }\n\n      case 'stopRecognize': {\n        break;\n      }\n\n      case 'startRecognize': {\n        break;\n      }\n\n      case 'stopSpeaking': {\n        break;\n      }\n\n      default: {\n        console.warn(`unknown message type: ${message.name}`, message);\n      }\n    }\n    return true;\n  };\n\n  // create instance of Persona class w/ scene instance\n  persona = new Persona(scene, PERSONA_ID);\n\n  /* CONNECT TO PERSONA */\n  try {\n    // connect to Persona server\n    const retryOptions = {\n      maxRetries: 20,\n      delayMs: 500,\n    };\n    const [err, sessionID] = await to(scene.connect(retryOptions));\n    if (err) {\n      switch (err.name) {\n        case 'notSupported':\n        case 'noUserMedia': {\n          return thunk.rejectWithValue({ msg: 'permissionsDenied', err: { ...err } });\n        }\n        default: {\n          return thunk.rejectWithValue({ msg: 'generic', err: { ...err } });\n        }\n      }\n    }\n\n    // we can't disable logging until after the connection is established\n    // logging is pretty crowded, not recommended to enable\n    // unless you need to debug emotional data from webcam\n    scene.session().setLogging(false);\n\n    // set video dimensions\n    const { videoWidth, videoHeight } = thunk.getState().sm;\n    // calc resolution w/ device pixel ratio\n    const deviceWidth = Math.round(videoWidth * window.devicePixelRatio);\n    const deviceHeight = Math.round(videoHeight * window.devicePixelRatio);\n    scene.sendVideoBounds(deviceWidth, deviceHeight);\n\n    // create proxy of webcam video feed if user has granted us permission\n\n    // since we can't store the userMediaStream in the store since it's not serializable,\n    // we use an external proxy for video streams\n    const { userMediaStream: stream } = scene.session();\n    // detect if we're running audio-only\n    const videoEnabled =\n      typingOnly === false && stream !== undefined && stream.getVideoTracks().length > 0;\n    if (videoEnabled === false) thunk.dispatch(actions.setCameraState({ cameraOn: false }));\n    if (typingOnly === true) thunk.dispatch(actions.setTypingOnly());\n    // pass dispatch before calling setUserMediaStream so proxy can send dimensions to store\n    mediaStreamProxy.passDispatch(thunk.dispatch);\n    mediaStreamProxy.setUserMediaStream(stream, videoEnabled);\n    mediaStreamProxy.enableToggle(scene);\n\n    // fulfill promise, reducer sets state to indicate loading and connection are complete\n    return thunk.fulfillWithValue();\n  } catch (err) {\n    return thunk.rejectWithValue(err);\n  }\n});\n\n// send plain text to the persona.\n// usually used for typed input or UI elems that trigger a certain phrase\nexport const sendTextMessage = createAsyncThunk('sm/sendTextMessage', async ({ text }, thunk) => {\n  console.log(`SENDTEXTMESSAGETEXT: ${text}`);\n  if (text === '') return thunk.rejectWithValue('submitted empty string!');\n  if (scene !== null && persona !== null) {\n    persona.conversationSend(text);\n    return thunk.dispatch(actions.addConversationResult({\n      source: 'user',\n      text,\n    }));\n  } return thunk.rejectWithValue('not connected to persona!');\n});\n\n// send plain text to the persona.\n// usually used for typed input or UI elems that trigger a certain phrase\n// export const sendTextMessage = createAsyncThunk('sm/sendTextMessage', async ({ text }, thunk) => {\n//   console.log(`SENDTEXTMESSAGETEXT: ${text}`);\n//   if (scene && persona) {\n//     if (ORCHESTRATION_MODE === true) scene.sendUserText(text);\n//     else persona.conversationSend(text);\n//     thunk.dispatch(\n//       actions.addConversationResult({\n//         source: 'user',\n//         text,\n//       }),\n//     );\n//   } else thunk.rejectWithValue('not connected to persona!');\n// });\n\nexport const sendEvent = createAsyncThunk('sm/sendEvent', async ({ payload, eventName }) => {\n  if (scene && persona) {\n    persona.conversationSend(eventName, payload || {}, { kind: 'event' });\n    console.log(`dispatched ${eventName}`, payload);\n  }\n});\n\nexport const keepAlive = createAsyncThunk('sm/keepAlive', async () => {\n  if (scene) {\n    scene.keepAlive();\n  }\n});\n\nconst smSlice = createSlice({\n  name: 'sm',\n  initialState,\n  reducers: {\n    setTOS: (state, { payload }) => ({\n      ...state,\n      tosAccepted: payload.accepted,\n    }),\n    setShowTermsAndConditions: (state, { payload }) => ({\n      ...state,\n      showTermsAndConditions: !state.showTermsAndConditions,\n    }),\n    setShowTranscript: (state, { payload }) => ({\n      ...state,\n      showTranscript: payload?.showTranscript || !state.showTranscript,\n    }),\n    setHideTranscript: (state, { payload }) => {\n      return {\n        ...state,\n        showTranscript: payload?.showTranscript || false,\n      };\n    },\n\n    setBrowserId: (state, { payload }) => {\n      console.log(`set id ran: ${JSON.stringify(payload, null, 2)}`);\n      return {\n        ...state,\n        browserId: payload?.browserId,\n      };\n    },\n    setConvoStopped: (state, { payload }) => {\n      console.log(`set convo stop ran: ${JSON.stringify(payload, null, 2)}`);\n      return {\n        ...state,\n        convoStopped: payload?.convoStopped,\n      };\n    },\n\n    setTypingOnly: (state) => ({\n      ...state,\n      typingOnly: true,\n    }),\n    setCameraState: (state, { payload }) => ({\n      ...state,\n      cameraOn: payload.cameraOn,\n      cameraWidth: payload.cameraWidth || state.cameraWidth,\n      cameraHeight: payload.cameraHeight || state.cameraHeight,\n    }),\n    setActiveCards: (state, { payload }) => ({\n      ...state,\n      activeCards: payload.activeCards || [],\n      cardsAreStale: payload.cardsAreStale || false,\n    }),\n    // content cards with the same key may get overwritten, so when the card is called\n    // in @showCards(), we copy to transcript: [] and activeCards: []\n    addContentCards: (state, { payload }) => ({\n      ...state,\n      contentCards: { ...state.contentCards, ...payload.contentCards },\n    }),\n    stopSpeaking: (state) => {\n      if (persona) persona.stopSpeaking();\n      return { ...state };\n    },\n    setMute: (state, { payload }) => ({\n      ...state,\n      isMuted: payload.isMuted,\n    }),\n    setIntermediateUserUtterance: (state, { payload }) => ({\n      ...state,\n      intermediateUserUtterance: payload.text,\n      userSpeaking: true,\n    }),\n    resetTranscript: (state) => ({\n      ...state,\n      transcript: [],\n      activeCards: [],\n    }),\n    addConversationResult: (state, { payload }) => {\n      // we record both text and content cards in the transcript\n      if (payload.text !== '' || 'card' in payload !== false) {\n        const { source } = payload;\n        const newEntry = { source, timestamp: new Date().toISOString() };\n        // handle entering either text or card into transcript array\n        if ('text' in payload) newEntry.text = payload.text;\n        if ('card' in payload) newEntry.card = payload.card;\n        const out = {\n          ...state,\n          transcript: [...state.transcript, { ...newEntry }],\n          intermediateUserUtterance: '',\n          userSpeaking: false,\n        };\n        // copy any text to last___Utterance, used for captions and user confirmation of STT\n        if ('text' in payload) {\n          out[payload.source === 'user' ? 'lastUserUtterance' : 'lastPersonaUtterance'] =\n            payload.text;\n        }\n        return out;\n      }\n      return console.warn('addConversationResult: ignoring empty string');\n    },\n    setSpeechState: (state, { payload }) => ({\n      ...state,\n      speechState: payload.speechState,\n    }),\n    setEmotionState: (state, { payload }) => ({\n      ...state,\n      user: {\n        ...state.user,\n        emotion: payload.emotion,\n      },\n    }),\n    setConversationState: (state, { payload }) => ({\n      ...state,\n      user: {\n        ...state.user,\n        conversation: payload.conversation,\n      },\n    }),\n    setActivityState: (state, { payload }) => ({\n      ...state,\n      user: {\n        ...state.user,\n        activity: payload.activity,\n      },\n    }),\n    setCallQuality: (state, { payload }) => ({\n      ...state,\n      callQuality: payload.callQuality,\n    }),\n    setVideoDimensions: (state, { payload }) => {\n      const { videoWidth, videoHeight } = payload;\n      // update video dimensions in persona\n      // calc resolution w/ device pixel ratio\n      const deviceWidth = Math.round(videoWidth * window.devicePixelRatio);\n      const deviceHeight = Math.round(videoHeight * window.devicePixelRatio);\n      scene.sendVideoBounds(deviceWidth, deviceHeight);\n      return { ...state, videoWidth, videoHeight };\n    },\n    disconnect: (state) => {\n      scene = null;\n      persona = null;\n      const { error } = state;\n      return {\n        // completely reset SM state on disconnect, except for errors\n        ...initialState,\n        disconnected: true,\n        error,\n      };\n    },\n  },\n  extraReducers: {\n    [createScene.pending]: (state) => ({\n      ...state,\n      loading: true,\n      disconnected: false,\n      error: null,\n    }),\n    [createScene.fulfilled]: (state) => ({\n      ...state,\n      loading: false,\n      connected: true,\n      error: null,\n    }),\n    [createScene.rejected]: (state, { payload }) => {\n      scene.disconnect();\n      // if we call this immediately the disconnect call might not complete\n      setTimeout(() => {\n        scene = null;\n        persona = null;\n      }, 100);\n      return {\n        ...state,\n        loading: false,\n        connected: false,\n        error: { ...payload },\n      };\n    },\n  },\n});\n\n// hoist actions to top of file so thunks can access\nactions = smSlice.actions;\n\nexport const {\n  setVideoDimensions,\n  stopSpeaking,\n  setActiveCards,\n  setCameraState,\n  setShowTranscript,\n  setHideTranscript,\n  setShowTermsAndConditions,\n  setTOS,\n  resetTranscript,\n  setBrowserId,\n  setConvoStopped\n} = smSlice.actions;\n\nexport default smSlice.reducer;\n"],"mappings":"AAAA;AACA,SAASA,gBAAT,EAA2BC,WAA3B,QAA8C,kBAA9C;AACA,SAASC,OAAT,EAAkBC,KAAlB,EAAyBC,SAAzB,QAA0C,wBAA1C;AACA,OAAOC,EAAP,MAAe,aAAf;AACA,OAAOC,WAAP,MAAwB,qBAAxB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,QAAP,MAAqB,WAArB;AACA,OAAOC,UAAP,IAAqBC,gBAArB,QAA6C,kBAA7C;AACA,OAAOC,WAAP,MAAwB,yBAAxB;AACA,SAASC,cAAT,QAA+B,YAA/B;AAEA,MAAMC,kBAAkB,GAAGC,OAAO,CAACC,GAAR,CAAYC,4BAAZ,IAA4C,KAAvE;AACA,MAAMC,MAAM,GAAGH,OAAO,CAACC,GAAR,CAAYG,iBAA3B;AACA,MAAMC,UAAU,GAAG,GAAnB;AAEA,MAAMC,cAAc,GAAGN,OAAO,CAACC,GAAR,CAAYM,wBAAnC;AACA,MAAMC,eAAe,GAAGR,OAAO,CAACC,GAAR,CAAYQ,yBAApC;AACA,IAAIC,eAAe,GAAG,KAAtB,C,CAEA;AAEA;AACA;;AAEA,MAAMC,YAAY,GAAG;EACnBC,WAAW,EAAE,IADM;EAEnBC,SAAS,EAAE,KAFQ;EAGnBC,YAAY,EAAE,KAHK;EAInBC,OAAO,EAAE,KAJU;EAKnBC,KAAK,EAAE,IALY;EAMnBC,OAAO,EAAE,KANU;EAOnBC,UAAU,EAAE,KAPO;EAQnBC,WAAW,EAAEC,MAAM,CAACC,WARD;EASnBC,UAAU,EAAEF,MAAM,CAACG,UATA;EAUnBC,UAAU,EAAE,EAVO;EAWnBC,WAAW,EAAE,EAXM;EAYnBC,sBAAsB,EAAE,KAZL;EAanB;EACAC,SAAS,EAAE,IAdQ;EAenBC,YAAY,EAAE,KAfK;EAgBnB;EACAC,aAAa,EAAE,KAjBI;EAkBnBC,YAAY,EAAE,EAlBK;EAmBnBC,WAAW,EAAE,MAnBM;EAoBnB;EACAC,yBAAyB,EAAE,EArBR;EAsBnBC,YAAY,EAAE,KAtBK;EAuBnBC,iBAAiB,EAAE,EAvBA;EAwBnBC,oBAAoB,EAAE,EAxBH;EAyBnBC,IAAI,EAAE;IACJC,QAAQ,EAAE;MACRC,WAAW,EAAE,CADL;MAERC,SAAS,EAAE;IAFH,CADN;IAKJC,OAAO,EAAE;MACPC,SAAS,EAAE,CADJ;MAEPC,UAAU,EAAE,CAFL;MAGPC,UAAU,EAAE,CAHL;MAIPC,UAAU,EAAE;IAJL,CALL;IAWJC,YAAY,EAAE;MACZC,IAAI,EAAE,EADM;MAEZC,OAAO,EAAE;QACPC,WAAW,EAAE,CADN;QAEPC,uBAAuB,EAAE,CAFlB;QAGPC,qBAAqB,EAAE,IAHhB;QAIPC,sBAAsB,EAAE,IAJjB;QAKPC,uBAAuB,EAAE,IALlB;QAMPC,uBAAuB,EAAE,IANlB;QAOPC,oBAAoB,EAAE,CAPf;QAQPC,kBAAkB,EAAE,IARb;QASPC,mBAAmB,EAAE,IATd;QAUPC,oBAAoB,EAAE,IAVf;QAWPC,oBAAoB,EAAE;MAXf;IAFG;EAXV,CAzBa;EAqDnBC,WAAW,EAAE;IACXC,KAAK,EAAE;MACLC,OAAO,EAAE,IADJ;MAELC,WAAW,EAAE,IAFR;MAGLC,aAAa,EAAE;IAHV,CADI;IAMXC,KAAK,EAAE;MACLH,OAAO,EAAE,IADJ;MAELC,WAAW,EAAE,IAFR;MAGLC,aAAa,EAAE;IAHV;EANI,CArDM;EAiEnBE,QAAQ,EAAE,KAjES;EAkEnB;EACA;EACAC,WAAW,EAAE,CApEM;EAqEnBC,YAAY,EAAE,CArEK;EAsEnBC,cAAc,EAAE;AAtEG,CAArB,C,CAyEA;AACA;;AACA,IAAIC,OAAJ;AACA,IAAIC,OAAO,GAAG,IAAd;AACA,IAAIC,KAAK,GAAG,IAAZ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAa,GAAGtF,gBAAgB,CAAC,kBAAD,EAAqB,MAAM;EACtE,IAAI,CAACqF,KAAL,EAAYE,OAAO,CAACzD,KAAR,CAAc,6CAAd,EAD0D,CAGtE;EACA;EACA;EACA;EACA;EACA;EACA;AACD,CAV4C,CAAtC,C,CAYP;;AACA,OAAO,MAAM0D,IAAI,GAAGxF,gBAAgB,CAAC,SAAD,EAAY,OAAOyF,kBAAP,EAA2BC,KAA3B,KAAqC;EACnF,MAAM;IAAE3D;EAAF,IAAc2D,KAAK,CAACC,QAAN,GAAiBC,EAArC;;EACA,IAAIP,KAAJ,EAAW;IACT;IACA;IACA,MAAMQ,SAAS,GAAG,OAAOJ,kBAAP,KAA8B,SAA9B,GAA0C,CAAC,CAACA,kBAA5C,GAAiE,CAAC1D,OAApF;IACA,IAAI8D,SAAS,KAAK,IAAlB,EAAwBR,KAAK,CAACS,aAAN,GAAxB,KACKT,KAAK,CAACU,cAAN;IACLL,KAAK,CAACM,QAAN,CAAeb,OAAO,CAACc,OAAR,CAAgB;MAAElE,OAAO,EAAE8D;IAAX,CAAhB,CAAf;EACD,CAPD,MAOO;IACLN,OAAO,CAACW,IAAR,CAAa,uCAAb;EACD;AACF,CAZmC,CAA7B,C,CAcP;;AACA,OAAO,MAAMC,UAAU,GAAGnG,gBAAgB,CAAC,eAAD,EAAkB,OAAOoG,IAAP,EAAaV,KAAb,KAAuB;EACjF,IAAIL,KAAJ,EAAWA,KAAK,CAACc,UAAN;EACXE,UAAU,CAAC,MAAM;IACfX,KAAK,CAACM,QAAN,CAAeb,OAAO,CAACgB,UAAR,EAAf;IACAd,KAAK,GAAG,IAAR;IACAD,OAAO,GAAG,IAAV;EACD,CAJS,EAIP,GAJO,CAAV;AAKD,CAPyC,CAAnC;AASP,OAAO,MAAMkB,WAAW,GAAGtG,gBAAgB,CAAC,gBAAD,EAAmB,kBAAqC;EAAA,IAA9BgC,UAA8B,uEAAjB,KAAiB;EAAA,IAAV0D,KAAU;;EACjG;EACA,IAAIL,KAAK,YAAYlF,KAArB,EAA4B;IAC1B,OAAOoF,OAAO,CAACzD,KAAR,CAAc,wEAAd,CAAP;EACD,CAJgG,CAKjG;;;EACA,MAAM;IAAEyE,UAAF;IAAcC,mBAAd;IAAmCC;EAAnC,IAA4CrG,SAAlD;;EACA,IAAI;IACF,MAAMsG,SAAS,GAAG;MAChBC,YAAY,EAAElG,UADE;MAEhB;MACA;MACAmG,0BAA0B,EAAE,KAJZ;MAKhBC,SAAS,EAAE,KALK;MAMhB5F,MAAM,EAAEA;IANQ,CAAlB;IAQAoE,KAAK,GAAG,IAAIlF,KAAJ,CAAUuG,SAAV,CAAR;EACD,CAVD,CAUE,OAAOI,CAAP,EAAU;IACVvB,OAAO,CAACzD,KAAR,CAAcgF,CAAd;EACD,CAnBgG,CAqBjG;;;EACA,MAAMC,QAAQ,GAAG,IAAIzG,WAAJ,CAAgB;IAC/B0G,OAAO,EAAE;EADsB,CAAhB,CAAjB;EAIA;;EACA3B,KAAK,CAAC4B,cAAN,GAAuB,MAAMvB,KAAK,CAACM,QAAN,CAAeG,UAAU,EAAzB,CAA7B,CA3BiG,CA4BjG;EACA;;;EACA,MAAMe,iBAAiB,GAAG7B,KAAK,CAAC8B,SAAN,CAAgBC,IAAhB,CAAqB/B,KAArB,CAA1B;;EACAA,KAAK,CAAC8B,SAAN,GAAmBE,OAAD,IAAa;IAC7B;IACAH,iBAAiB,CAACG,OAAD,CAAjB;;IACA,QAAQA,OAAO,CAACC,IAAhB;MACE;MACA,KAAK,kBAAL;QAAyB;UACvB,IAAIhG,eAAe,IAAI,CAACE,eAAxB,EAAyC;YACvCA,eAAe,GAAG,IAAlB,CADuC,CAEvC;;YACAuF,QAAQ,CACLQ,KADH,GAEGC,IAFH,CAEQ,MAAM,CACV;YACD,CAJH,EAKGC,KALH,CAKUX,CAAD,IAAO;cACZvB,OAAO,CAACzD,KAAR,CAAcgF,CAAd;YACD,CAPH;UAQD;;UAED,MAAMY,MAAM,GAAGL,OAAO,CAACM,IAAR,CAAaC,OAAb,CAAqB,CAArB,CAAf,CAduB,CAevB;;UACA,IAAI,CAACF,MAAL,EAAa;YACXnC,OAAO,CAACW,IAAR,CAAa,mBAAb,EAAkCmB,OAAO,CAACM,IAA1C;YACA,OAAO,KAAP;UACD;;UACD,MAAM;YAAErF,UAAU,EAAEuF;UAAd,IAAuBH,MAAM,CAACI,YAAP,CAAoB,CAApB,CAA7B,CApBuB,CAqBvB;UACA;;UACA,IAAIJ,MAAM,CAACK,KAAP,KAAiB,KAArB,EAA4B;YAC1B,OAAOrC,KAAK,CAACM,QAAN,CACLb,OAAO,CAAC6C,4BAAR,CAAqC;cACnCH;YADmC,CAArC,CADK,CAAP;UAKD;;UACD,OAAOnC,KAAK,CAACM,QAAN,CACLb,OAAO,CAAC8C,qBAAR,CAA8B;YAC5BC,MAAM,EAAE,MADoB;YAE5BL;UAF4B,CAA9B,CADK,CAAP;QAMD;MAED;;MACA,KAAK,iBAAL;QAAwB;UACtB,MAAM;YAAEM;UAAF,IAAoBd,OAAO,CAACM,IAAlC;UACA,MAAM;YAAEhF;UAAF,IAAoB+C,KAAK,CAACC,QAAN,GAAiBC,EAA3C;UACA,IAAIjD,aAAa,KAAK,IAAtB,EAA4B+C,KAAK,CAACM,QAAN,CAAeb,OAAO,CAACiD,cAAR,CAAuB,EAAvB,CAAf;UAC5B1C,KAAK,CAACM,QAAN,CACEb,OAAO,CAAC8C,qBAAR,CAA8B;YAC5BC,MAAM,EAAE,SADoB;YAE5BL,IAAI,EAAEM;UAFsB,CAA9B,CADF;UAMA;QACD;;MAED,KAAK,sBAAL;QAA6B;UAC3B,MAAM;YAAEA;UAAF,IAAoBd,OAAO,CAACM,IAAlC;UACA,MAAM;YAAEhF;UAAF,IAAoB+C,KAAK,CAACC,QAAN,GAAiBC,EAA3C;UACA,IAAIjD,aAAa,KAAK,IAAtB,EAA4B+C,KAAK,CAACM,QAAN,CAAeb,OAAO,CAACiD,cAAR,CAAuB,EAAvB,CAAf;UAC5B1C,KAAK,CAACM,QAAN,CACEb,OAAO,CAAC8C,qBAAR,CAA8B;YAC5BC,MAAM,EAAE,SADoB;YAE5BL,IAAI,EAAEM;UAFsB,CAA9B,CADF;UAMA;QACD;MAED;;MACA,KAAK,cAAL;QAAqB;UACnB,MAAM;YAAEb,IAAI,EAAEe,gBAAR;YAA0BC,SAAS,EAAElC;UAArC,IAA8CiB,OAAO,CAACM,IAA5D;;UACA,QAAQU,gBAAR;YACE,KAAK,WAAL;cAAkB;gBAChB,MAAM;kBAAE9F,WAAF;kBAAeK,YAAf;kBAA6BD;gBAA7B,IAA+C+C,KAAK,CAACC,QAAN,GAAiBC,EAAtE,CADgB,CAEhB;;gBACA,MAAM2C,QAAQ,GAAG5F,aAAa,GAAG,EAAH,GAAQJ,WAAtC,CAHgB,CAIhB;;gBACA,MAAMiG,QAAQ,GAAGpC,IAAI,CAACqC,GAAL,CAAUC,CAAD,KAAQ;kBAAEC,EAAE,EAAED,CAAN;kBAAS,GAAG9F,YAAY,CAAC8F,CAAD;gBAAxB,CAAR,CAAT,CAAjB;gBACA,MAAME,cAAc,GAAG,CAAC,GAAGL,QAAJ,EAAc,GAAGC,QAAjB,CAAvB;gBACA9C,KAAK,CAACM,QAAN,CAAeb,OAAO,CAACiD,cAAR,CAAuB;kBAAE7F,WAAW,EAAEqG;gBAAf,CAAvB,CAAf,EAPgB,CAQhB;;gBACAlD,KAAK,CAACM,QAAN,CACEb,OAAO,CAAC8C,qBAAR,CAA8B;kBAC5BC,MAAM,EAAE,SADoB;kBAE5BW,IAAI,EAAEL,QAAQ,CAAC,CAAD;gBAFc,CAA9B,CADF;gBAMA;cACD;;YACD,KAAK,WAAL;cAAkB;gBAChB9C,KAAK,CAACM,QAAN,CAAeb,OAAO,CAACiD,cAAR,CAAuB,EAAvB,CAAf;gBACA;cACD;;YACD,KAAK,WAAL;cAAkB;gBAChB;gBACA;cACD;;YACD,KAAK,UAAL;cAAiB;gBACf7C,OAAO,CAACuD,GAAR,CAAY,wBAAZ;gBACA;cACD;;YACD,KAAK,SAAL;cAAgB;gBACd,MAAM;kBAAER,SAAS,EAAES;gBAAb,IAA6B1B,OAAO,CAACM,IAA3C;gBACA,MAAMqB,OAAO,GAAGD,WAAW,CAAC,CAAD,CAA3B;gBACA,MAAME,YAAY,GAAGF,WAAW,CAAC,CAAD,CAAhC;;gBACA,QAAQC,OAAR;kBACE,KAAK,YAAL;oBAAmB;sBACjB,IAAIC,YAAY,KAAK,IAArB,EAA2BvD,KAAK,CAACM,QAAN,CAAeR,IAAI,CAAC,KAAD,CAAnB,EAA3B,KACK,IAAIyD,YAAY,KAAK,KAArB,EAA4BvD,KAAK,CAACM,QAAN,CAAeR,IAAI,CAAC,IAAD,CAAnB,EAA5B,KACAD,OAAO,CAACzD,KAAR,CAAe,SAAQmH,YAAa,yCAApC;sBACL;oBACD;;kBACD,KAAK,YAAL;oBAAmB;sBACjB,IAAIA,YAAY,KAAK,IAArB,EAA2BvD,KAAK,CAACM,QAAN,CAAeb,OAAO,CAAC+D,iBAAR,CAA0B,IAA1B,CAAf,EAA3B,KACK,IAAID,YAAY,KAAK,KAArB,EAA4BvD,KAAK,CAACM,QAAN,CAAeb,OAAO,CAAC+D,iBAAR,CAA0B,KAA1B,CAAf,EAA5B,KACA3D,OAAO,CAACzD,KAAR,CAAe,SAAQmH,YAAa,yCAApC;sBACL;oBACD;;kBACD;oBAAS;sBACP1D,OAAO,CAACzD,KAAR,CAAe,YAAWkH,OAAQ,mBAAlC;oBACD;gBAfH;;gBAiBA;cACD;;YACD,KAAK,OAAL;cAAc;gBACZtD,KAAK,CAACM,QAAN,CAAeG,UAAU,EAAzB;gBACA;cACD;;YACD,KAAK,QAAL;cAAe;gBACb;gBACA,MAAM;kBAAEmC,SAAS,EAAEa;gBAAb,IAA4B9B,OAAO,CAACM,IAA1C;gBACAwB,UAAU,CAACC,OAAX,CAAoBV,CAAD,IAAO;kBACxB,QAAQA,CAAR;oBACE;oBACA,KAAK,iBAAL;sBAAwB;wBACtBnD,OAAO,CAACuD,GAAR,CAAYlI,cAAZ;wBACA;sBACD;;oBACD;sBAAS;wBACP2E,OAAO,CAACW,IAAR,CAAc,0BAAyBwC,CAAE,IAAzC;sBACD;kBARH;gBAUD,CAXD;gBAYA;cACD;;YACD;cAAS;gBACPnD,OAAO,CAACW,IAAR,CAAc,8BAA6BmC,gBAAiB,EAA5D;cACD;UA5EH;;UA8EA;QACD;;MAED,KAAK,wBAAL;QAA+B;UAC7B;UACA;UACA;QACD;;MACD,KAAK,kBAAL;QAAyB;UACvB;UACA;UACA;QACD;MAED;;MACA,KAAK,oBAAL;QAA2B;UAAA;;UACzB;UACA,MAAM;YAAExE;UAAF,IAAcwD,OAAO,CAACM,IAAR,CAAaD,MAAjC,CAFyB,CAIzB;;UACA,MAAM2B,YAAY,GAAGC,MAAM,CAACC,IAAP,CAAY1F,OAAZ,EAAqB2F,MAArB,CAA6BC,CAAD,IAAO,eAAeC,IAAf,CAAoBD,CAApB,MAA2B,KAA9D,CAArB;UACA,IAAI7G,YAAY,GAAG,EAAnB;UACAyG,YAAY,CAACD,OAAb,CAAsBK,CAAD,IAAO;YAC1B;YACA,MAAME,OAAO,GAAGF,CAAC,CAACG,KAAF,CAAQ,cAAR,EAAwB,CAAxB,CAAhB;;YACA,IAAI;cACFhH,YAAY,CAAC+G,OAAD,CAAZ,GAAwBE,IAAI,CAACC,KAAL,CAAWjG,OAAO,CAAC4F,CAAD,CAAlB,CAAxB;YACD,CAFD,CAEE,MAAM;cACNlE,OAAO,CAACzD,KAAR,CAAe,4CAA2C2H,CAAE,GAA5D;YACD;UACF,CARD,EAPyB,CAgBzB;;UACA,MAAMM,mBAAmB,oBACvB1C,OAAO,CAACM,IADe,2EACvB,cAAcqC,QADS,oFACvB,sBAAwBC,IADD,qFACvB,uBAA8BC,UADP,qFACvB,uBAA0CC,WADnB,2DACvB,uBAAuDJ,mBADzD;;UAEA,IAAIA,mBAAJ,EAAyB;YACvBA,mBAAmB,CAACX,OAApB,CAA6BgB,CAAD,IAAO;cACjC,IAAI,aAAaA,CAAb,IAAkB,kBAAkBA,CAAC,CAACC,OAA1C,EAAmD;gBACjDzH,YAAY,GAAG,EAAE,GAAGA,YAAL;kBAAmB,GAAGwH,CAAC,CAACC,OAAF,CAAUC;gBAAhC,CAAf;cACD;YACF,CAJD;UAKD;;UACD5E,KAAK,CAACM,QAAN,CAAeb,OAAO,CAACoF,eAAR,CAAwB;YAAE3H;UAAF,CAAxB,CAAf;;UAEA,IAAIpB,eAAJ,EAAqB;YACnBA,eAAe,GAAG,KAAlB,CADmB,CAEnB;;YACAuF,QAAQ,CACLyD,IADH,GAEGC,MAFH,GAGGjD,IAHH,CAGQ,QAAoB;cAAA,IAAnB,CAACkD,MAAD,EAASC,IAAT,CAAmB;cACxB;cACA,MAAMC,IAAI,GAAG,IAAIC,IAAJ,CAASH,MAAT,EAAiBI,QAAQ,CAACC,IAAI,CAACC,GAAL,KAAa,IAAd,CAAR,GAA8B,MAA/C,EAAuD;gBAClEC,IAAI,EAAEN,IAAI,CAACM,IADuD;gBAElEC,YAAY,EAAEH,IAAI,CAACC,GAAL;cAFoD,CAAvD,CAAb,CAFwB,CAMxB;;cACA,MAAMG,QAAQ,GAAG,IAAI3K,QAAJ,EAAjB;cACA2K,QAAQ,CAACC,MAAT,CAAgB,MAAhB,EAAwBR,IAAxB,EARwB,CASxB;;cACA,MAAMS,aAAa,GAAG;gBACpBC,MAAM,EAAE,MADY;gBAEpBC,GAAG,EAAEnK,cAFe;gBAGpBoK,OAAO,EAAE;kBACP,gBAAgB;gBADT,CAHW;gBAMpBC,IAAI,EAAEN;cANc,CAAtB,CAVwB,CAkBxB;;cACA5K,KAAK,CAACmL,OAAN,CAAcL,aAAd;YACD,CAvBH,EAwBG5D,KAxBH,CAwBUX,CAAD,IAAO;cACZ;cACAvB,OAAO,CAACuD,GAAR,CAAY,sBAAZ,EAAoChC,CAApC;YACD,CA3BH;UA4BD;;UAED;QACD;MAED;MACA;;MACA,KAAK,OAAL;QAAc;UACZ,MAAM;YAAEa;UAAF,IAAWN,OAAjB;;UACA,IAAI,aAAaM,IAAjB,EAAuB;YACrB,MAAMgE,YAAY,GAAGhE,IAAI,CAACvC,OAAL,CAAa,CAAb,CAArB,CADqB,CAGrB;;YACA,IAAI,iBAAiBuG,YAArB,EAAmC;cACjC,MAAM;gBAAE9I;cAAF,IAAkB8I,YAAxB;cACA,MAAMC,MAAM,GAAGzG,OAAO,CAAC0G,cAAR,CAAuB;gBAAEhJ;cAAF,CAAvB,CAAf,CAFiC,CAGjC;;cACA,IAAIA,WAAW,KAAK,MAApB,EAA4B;gBAC1B,MAAM;kBAAEN;gBAAF,IAAkBmD,KAAK,CAACC,QAAN,GAAiBC,EAAzC;gBACAF,KAAK,CAACM,QAAN,CAAeb,OAAO,CAACiD,cAAR,CAAuB;kBAAE7F,WAAF;kBAAeI,aAAa,EAAE;gBAA9B,CAAvB,CAAf;cACD;;cACD+C,KAAK,CAACM,QAAN,CAAe4F,MAAf;YACD;;YAED,IAAI,WAAWD,YAAf,EAA6B;cAC3B;cACA;cACA,MAAMG,SAAS,GAAGH,YAAY,CAACI,KAAb,CAAmB,CAAnB,CAAlB;;cAEA,IAAI,aAAaD,SAAjB,EAA4B;gBAC1B,MAAM;kBAAExI;gBAAF,IAAcwI,SAApB;gBACA,MAAME,cAAc,GAAGrL,WAAW,CAAC2C,OAAD,CAAlC;gBACA,MAAMsI,MAAM,GAAGzG,OAAO,CAAC8G,eAAR,CAAwB;kBAAE3I,OAAO,EAAE0I;gBAAX,CAAxB,CAAf;gBACAtG,KAAK,CAACM,QAAN,CAAe4F,MAAf;cACD;;cAED,IAAI,cAAcE,SAAlB,EAA6B;gBAC3B,MAAM;kBAAE3I;gBAAF,IAAe2I,SAArB;gBACA,MAAMI,eAAe,GAAGvL,WAAW,CAACwC,QAAD,EAAW,IAAX,CAAnC;gBACA,MAAMyI,MAAM,GAAGzG,OAAO,CAAC8G,eAAR,CAAwB;kBAAE9I,QAAQ,EAAE+I;gBAAZ,CAAxB,CAAf;gBACAxG,KAAK,CAACM,QAAN,CAAe4F,MAAf;cACD;;cAED,IAAI,kBAAkBE,SAAtB,EAAiC;gBAC/B,MAAM;kBAAEnI;gBAAF,IAAmBmI,SAAzB;gBACA,MAAM;kBAAEjI;gBAAF,IAAcF,YAApB;gBACA,MAAMwI,cAAc,GAAGxL,WAAW,CAACkD,OAAD,CAAlC;gBACA,MAAM+H,MAAM,GAAGzG,OAAO,CAACiH,oBAAR,CAA6B;kBAC1CzI,YAAY,EAAE,EACZ,GAAGA,YADS;oBAEZE,OAAO,EAAEsI;kBAFG;gBAD4B,CAA7B,CAAf;gBAMAzG,KAAK,CAACM,QAAN,CAAe4F,MAAf;cACD;YACF;UACF,CA/CD,MA+CO,IAAI,gBAAgBjE,IAApB,EAA0B;YAC/B,MAAM;cAAElD;YAAF,IAAkBkD,IAAI,CAAC0E,UAA7B;YACA3G,KAAK,CAACM,QAAN,CAAeb,OAAO,CAACmH,cAAR,CAAuB;cAAE7H;YAAF,CAAvB,CAAf;UACD;;UACD;QACD;MAED;;MACA,KAAK,YAAL;QAAmB;UACjB;UACA;QACD;MAED;MACA;;MACA,KAAK,sBAAL;QAA6B;UAC3B;UACA;QACD;;MAED,KAAK,eAAL;QAAsB;UACpB;QACD;;MAED,KAAK,gBAAL;QAAuB;UACrB;QACD;;MAED,KAAK,cAAL;QAAqB;UACnB;QACD;;MAED;QAAS;UACPc,OAAO,CAACW,IAAR,CAAc,yBAAwBmB,OAAO,CAACC,IAAK,EAAnD,EAAsDD,OAAtD;QACD;IAxTH;;IA0TA,OAAO,IAAP;EACD,CA9TD,CA/BiG,CA+VjG;;;EACAjC,OAAO,GAAG,IAAIlF,OAAJ,CAAYmF,KAAZ,EAAmBlE,UAAnB,CAAV;EAEA;;EACA,IAAI;IACF;IACA,MAAMoL,YAAY,GAAG;MACnBC,UAAU,EAAE,EADO;MAEnBC,OAAO,EAAE;IAFU,CAArB;IAIA,MAAM,CAACC,GAAD,EAAMC,SAAN,IAAmB,MAAMtM,EAAE,CAACgF,KAAK,CAACuH,OAAN,CAAcL,YAAd,CAAD,CAAjC;;IACA,IAAIG,GAAJ,EAAS;MACP,QAAQA,GAAG,CAACpF,IAAZ;QACE,KAAK,cAAL;QACA,KAAK,aAAL;UAAoB;YAClB,OAAO5B,KAAK,CAACmH,eAAN,CAAsB;cAAEC,GAAG,EAAE,mBAAP;cAA4BJ,GAAG,EAAE,EAAE,GAAGA;cAAL;YAAjC,CAAtB,CAAP;UACD;;QACD;UAAS;YACP,OAAOhH,KAAK,CAACmH,eAAN,CAAsB;cAAEC,GAAG,EAAE,SAAP;cAAkBJ,GAAG,EAAE,EAAE,GAAGA;cAAL;YAAvB,CAAtB,CAAP;UACD;MAPH;IASD,CAjBC,CAmBF;IACA;IACA;;;IACArH,KAAK,CAAC0H,OAAN,GAAgBC,UAAhB,CAA2B,KAA3B,EAtBE,CAwBF;;IACA,MAAM;MAAE5K,UAAF;MAAcH;IAAd,IAA8ByD,KAAK,CAACC,QAAN,GAAiBC,EAArD,CAzBE,CA0BF;;IACA,MAAMqH,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAW/K,UAAU,GAAGF,MAAM,CAACkL,gBAA/B,CAApB;IACA,MAAMC,YAAY,GAAGH,IAAI,CAACC,KAAL,CAAWlL,WAAW,GAAGC,MAAM,CAACkL,gBAAhC,CAArB;IACA/H,KAAK,CAACiI,eAAN,CAAsBL,WAAtB,EAAmCI,YAAnC,EA7BE,CA+BF;IAEA;IACA;;IACA,MAAM;MAAEE,eAAe,EAAEC;IAAnB,IAA8BnI,KAAK,CAAC0H,OAAN,EAApC,CAnCE,CAoCF;;IACA,MAAMU,YAAY,GAChBzL,UAAU,KAAK,KAAf,IAAwBwL,MAAM,KAAKE,SAAnC,IAAgDF,MAAM,CAACG,cAAP,GAAwBC,MAAxB,GAAiC,CADnF;IAEA,IAAIH,YAAY,KAAK,KAArB,EAA4B/H,KAAK,CAACM,QAAN,CAAeb,OAAO,CAAC0I,cAAR,CAAuB;MAAE9I,QAAQ,EAAE;IAAZ,CAAvB,CAAf;IAC5B,IAAI/C,UAAU,KAAK,IAAnB,EAAyB0D,KAAK,CAACM,QAAN,CAAeb,OAAO,CAAC2I,aAAR,EAAf,EAxCvB,CAyCF;;IACApN,gBAAgB,CAACqN,YAAjB,CAA8BrI,KAAK,CAACM,QAApC;IACAtF,gBAAgB,CAACsN,kBAAjB,CAAoCR,MAApC,EAA4CC,YAA5C;IACA/M,gBAAgB,CAACuN,YAAjB,CAA8B5I,KAA9B,EA5CE,CA8CF;;IACA,OAAOK,KAAK,CAACwI,gBAAN,EAAP;EACD,CAhDD,CAgDE,OAAOxB,GAAP,EAAY;IACZ,OAAOhH,KAAK,CAACmH,eAAN,CAAsBH,GAAtB,CAAP;EACD;AACF,CAtZ0C,CAApC,C,CAwZP;AACA;;AACA,OAAO,MAAMyB,eAAe,GAAGnO,gBAAgB,CAAC,oBAAD,EAAuB,cAAiB0F,KAAjB,KAA2B;EAAA,IAApB;IAAEmC;EAAF,CAAoB;EAC/FtC,OAAO,CAACuD,GAAR,CAAa,wBAAuBjB,IAAK,EAAzC;EACA,IAAIA,IAAI,KAAK,EAAb,EAAiB,OAAOnC,KAAK,CAACmH,eAAN,CAAsB,yBAAtB,CAAP;;EACjB,IAAIxH,KAAK,KAAK,IAAV,IAAkBD,OAAO,KAAK,IAAlC,EAAwC;IACtCA,OAAO,CAACgJ,gBAAR,CAAyBvG,IAAzB;IACA,OAAOnC,KAAK,CAACM,QAAN,CAAeb,OAAO,CAAC8C,qBAAR,CAA8B;MAClDC,MAAM,EAAE,MAD0C;MAElDL;IAFkD,CAA9B,CAAf,CAAP;EAID;;EAAC,OAAOnC,KAAK,CAACmH,eAAN,CAAsB,2BAAtB,CAAP;AACH,CAV8C,CAAxC,C,CAYP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMwB,SAAS,GAAGrO,gBAAgB,CAAC,cAAD,EAAiB,eAAkC;EAAA,IAA3B;IAAEqK,OAAF;IAAWiE;EAAX,CAA2B;;EAC1F,IAAIjJ,KAAK,IAAID,OAAb,EAAsB;IACpBA,OAAO,CAACgJ,gBAAR,CAAyBE,SAAzB,EAAoCjE,OAAO,IAAI,EAA/C,EAAmD;MAAEkE,IAAI,EAAE;IAAR,CAAnD;IACAhJ,OAAO,CAACuD,GAAR,CAAa,cAAawF,SAAU,EAApC,EAAuCjE,OAAvC;EACD;AACF,CALwC,CAAlC;AAOP,OAAO,MAAMmE,SAAS,GAAGxO,gBAAgB,CAAC,cAAD,EAAiB,YAAY;EACpE,IAAIqF,KAAJ,EAAW;IACTA,KAAK,CAACmJ,SAAN;EACD;AACF,CAJwC,CAAlC;AAMP,MAAMC,OAAO,GAAGxO,WAAW,CAAC;EAC1BqH,IAAI,EAAE,IADoB;EAE1B7F,YAF0B;EAG1BiN,QAAQ,EAAE;IACRC,MAAM,EAAE,CAACC,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EAC/B,GAAGuE,KAD4B;QAE/BlN,WAAW,EAAE2I,OAAO,CAACwE;MAFU,CAAzB;IAAA,CADA;IAKRC,yBAAyB,EAAE,CAACF,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EAClD,GAAGuE,KAD+C;QAElDpM,sBAAsB,EAAE,CAACoM,KAAK,CAACpM;MAFmB,CAAzB;IAAA,CALnB;IASR0G,iBAAiB,EAAE,CAAC0F,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EAC1C,GAAGuE,KADuC;QAE1C1J,cAAc,EAAE,CAAAmF,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEnF,cAAT,KAA2B,CAAC0J,KAAK,CAAC1J;MAFR,CAAzB;IAAA,CATX;IAaR6J,iBAAiB,EAAE,CAACH,KAAD,YAAwB;MAAA,IAAhB;QAAEvE;MAAF,CAAgB;MACzC,OAAO,EACL,GAAGuE,KADE;QAEL1J,cAAc,EAAE,CAAAmF,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEnF,cAAT,KAA2B;MAFtC,CAAP;IAID,CAlBO;IAoBR8J,YAAY,EAAE,CAACJ,KAAD,YAAwB;MAAA,IAAhB;QAAEvE;MAAF,CAAgB;MACpC9E,OAAO,CAACuD,GAAR,CAAa,eAAce,IAAI,CAACoF,SAAL,CAAe5E,OAAf,EAAwB,IAAxB,EAA8B,CAA9B,CAAiC,EAA5D;MACA,OAAO,EACL,GAAGuE,KADE;QAELnM,SAAS,EAAE4H,OAAF,aAAEA,OAAF,uBAAEA,OAAO,CAAE5H;MAFf,CAAP;IAID,CA1BO;IA2BRyM,eAAe,EAAE,CAACN,KAAD,YAAwB;MAAA,IAAhB;QAAEvE;MAAF,CAAgB;MACvC9E,OAAO,CAACuD,GAAR,CAAa,uBAAsBe,IAAI,CAACoF,SAAL,CAAe5E,OAAf,EAAwB,IAAxB,EAA8B,CAA9B,CAAiC,EAApE;MACA,OAAO,EACL,GAAGuE,KADE;QAELlM,YAAY,EAAE2H,OAAF,aAAEA,OAAF,uBAAEA,OAAO,CAAE3H;MAFlB,CAAP;IAID,CAjCO;IAmCRoL,aAAa,EAAGc,KAAD,KAAY,EACzB,GAAGA,KADsB;MAEzB5M,UAAU,EAAE;IAFa,CAAZ,CAnCP;IAuCR6L,cAAc,EAAE,CAACe,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EACvC,GAAGuE,KADoC;QAEvC7J,QAAQ,EAAEsF,OAAO,CAACtF,QAFqB;QAGvCC,WAAW,EAAEqF,OAAO,CAACrF,WAAR,IAAuB4J,KAAK,CAAC5J,WAHH;QAIvCC,YAAY,EAAEoF,OAAO,CAACpF,YAAR,IAAwB2J,KAAK,CAAC3J;MAJL,CAAzB;IAAA,CAvCR;IA6CRmD,cAAc,EAAE,CAACwG,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EACvC,GAAGuE,KADoC;QAEvCrM,WAAW,EAAE8H,OAAO,CAAC9H,WAAR,IAAuB,EAFG;QAGvCI,aAAa,EAAE0H,OAAO,CAAC1H,aAAR,IAAyB;MAHD,CAAzB;IAAA,CA7CR;IAkDR;IACA;IACA4H,eAAe,EAAE,CAACqE,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EACxC,GAAGuE,KADqC;QAExChM,YAAY,EAAE,EAAE,GAAGgM,KAAK,CAAChM,YAAX;UAAyB,GAAGyH,OAAO,CAACzH;QAApC;MAF0B,CAAzB;IAAA,CApDT;IAwDRuM,YAAY,EAAGP,KAAD,IAAW;MACvB,IAAIxJ,OAAJ,EAAaA,OAAO,CAAC+J,YAAR;MACb,OAAO,EAAE,GAAGP;MAAL,CAAP;IACD,CA3DO;IA4DR3I,OAAO,EAAE,CAAC2I,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EAChC,GAAGuE,KAD6B;QAEhC7M,OAAO,EAAEsI,OAAO,CAACtI;MAFe,CAAzB;IAAA,CA5DD;IAgERiG,4BAA4B,EAAE,CAAC4G,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EACrD,GAAGuE,KADkD;QAErD9L,yBAAyB,EAAEuH,OAAO,CAACxC,IAFkB;QAGrD9E,YAAY,EAAE;MAHuC,CAAzB;IAAA,CAhEtB;IAqERqM,eAAe,EAAGR,KAAD,KAAY,EAC3B,GAAGA,KADwB;MAE3BtM,UAAU,EAAE,EAFe;MAG3BC,WAAW,EAAE;IAHc,CAAZ,CArET;IA0ER0F,qBAAqB,EAAE,CAAC2G,KAAD,aAAwB;MAAA,IAAhB;QAAEvE;MAAF,CAAgB;;MAC7C;MACA,IAAIA,OAAO,CAACxC,IAAR,KAAiB,EAAjB,IAAuB,UAAUwC,OAAV,KAAsB,KAAjD,EAAwD;QACtD,MAAM;UAAEnC;QAAF,IAAamC,OAAnB;QACA,MAAMgF,QAAQ,GAAG;UAAEnH,MAAF;UAAUoH,SAAS,EAAE,IAAIvE,IAAJ,GAAWwE,WAAX;QAArB,CAAjB,CAFsD,CAGtD;;QACA,IAAI,UAAUlF,OAAd,EAAuBgF,QAAQ,CAACxH,IAAT,GAAgBwC,OAAO,CAACxC,IAAxB;QACvB,IAAI,UAAUwC,OAAd,EAAuBgF,QAAQ,CAACxG,IAAT,GAAgBwB,OAAO,CAACxB,IAAxB;QACvB,MAAM2G,GAAG,GAAG,EACV,GAAGZ,KADO;UAEVtM,UAAU,EAAE,CAAC,GAAGsM,KAAK,CAACtM,UAAV,EAAsB,EAAE,GAAG+M;UAAL,CAAtB,CAFF;UAGVvM,yBAAyB,EAAE,EAHjB;UAIVC,YAAY,EAAE;QAJJ,CAAZ,CANsD,CAYtD;;QACA,IAAI,UAAUsH,OAAd,EAAuB;UACrBmF,GAAG,CAACnF,OAAO,CAACnC,MAAR,KAAmB,MAAnB,GAA4B,mBAA5B,GAAkD,sBAAnD,CAAH,GACEmC,OAAO,CAACxC,IADV;QAED;;QACD,OAAO2H,GAAP;MACD;;MACD,OAAOjK,OAAO,CAACW,IAAR,CAAa,8CAAb,CAAP;IACD,CAhGO;IAiGR2F,cAAc,EAAE,CAAC+C,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EACvC,GAAGuE,KADoC;QAEvC/L,WAAW,EAAEwH,OAAO,CAACxH;MAFkB,CAAzB;IAAA,CAjGR;IAqGRoJ,eAAe,EAAE,CAAC2C,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EACxC,GAAGuE,KADqC;QAExC1L,IAAI,EAAE,EACJ,GAAG0L,KAAK,CAAC1L,IADL;UAEJI,OAAO,EAAE+G,OAAO,CAAC/G;QAFb;MAFkC,CAAzB;IAAA,CArGT;IA4GR8I,oBAAoB,EAAE,CAACwC,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EAC7C,GAAGuE,KAD0C;QAE7C1L,IAAI,EAAE,EACJ,GAAG0L,KAAK,CAAC1L,IADL;UAEJS,YAAY,EAAE0G,OAAO,CAAC1G;QAFlB;MAFuC,CAAzB;IAAA,CA5Gd;IAmHR8L,gBAAgB,EAAE,CAACb,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EACzC,GAAGuE,KADsC;QAEzC1L,IAAI,EAAE,EACJ,GAAG0L,KAAK,CAAC1L,IADL;UAEJC,QAAQ,EAAEkH,OAAO,CAAClH;QAFd;MAFmC,CAAzB;IAAA,CAnHV;IA0HRmJ,cAAc,EAAE,CAACsC,KAAD;MAAA,IAAQ;QAAEvE;MAAF,CAAR;MAAA,OAAyB,EACvC,GAAGuE,KADoC;QAEvCnK,WAAW,EAAE4F,OAAO,CAAC5F;MAFkB,CAAzB;IAAA,CA1HR;IA8HRiL,kBAAkB,EAAE,CAACd,KAAD,aAAwB;MAAA,IAAhB;QAAEvE;MAAF,CAAgB;MAC1C,MAAM;QAAEjI,UAAF;QAAcH;MAAd,IAA8BoI,OAApC,CAD0C,CAE1C;MACA;;MACA,MAAM4C,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAW/K,UAAU,GAAGF,MAAM,CAACkL,gBAA/B,CAApB;MACA,MAAMC,YAAY,GAAGH,IAAI,CAACC,KAAL,CAAWlL,WAAW,GAAGC,MAAM,CAACkL,gBAAhC,CAArB;MACA/H,KAAK,CAACiI,eAAN,CAAsBL,WAAtB,EAAmCI,YAAnC;MACA,OAAO,EAAE,GAAGuB,KAAL;QAAYxM,UAAZ;QAAwBH;MAAxB,CAAP;IACD,CAtIO;IAuIRkE,UAAU,EAAGyI,KAAD,IAAW;MACrBvJ,KAAK,GAAG,IAAR;MACAD,OAAO,GAAG,IAAV;MACA,MAAM;QAAEtD;MAAF,IAAY8M,KAAlB;MACA,OAAO,EACL;QACA,GAAGnN,YAFE;QAGLG,YAAY,EAAE,IAHT;QAILE;MAJK,CAAP;IAMD;EAjJO,CAHgB;EAsJ1B6N,aAAa,EAAE;IACb,CAACrJ,WAAW,CAACsJ,OAAb,GAAwBhB,KAAD,KAAY,EACjC,GAAGA,KAD8B;MAEjC/M,OAAO,EAAE,IAFwB;MAGjCD,YAAY,EAAE,KAHmB;MAIjCE,KAAK,EAAE;IAJ0B,CAAZ,CADV;IAOb,CAACwE,WAAW,CAACuJ,SAAb,GAA0BjB,KAAD,KAAY,EACnC,GAAGA,KADgC;MAEnC/M,OAAO,EAAE,KAF0B;MAGnCF,SAAS,EAAE,IAHwB;MAInCG,KAAK,EAAE;IAJ4B,CAAZ,CAPZ;IAab,CAACwE,WAAW,CAACwJ,QAAb,GAAwB,CAAClB,KAAD,aAAwB;MAAA,IAAhB;QAAEvE;MAAF,CAAgB;MAC9ChF,KAAK,CAACc,UAAN,GAD8C,CAE9C;;MACAE,UAAU,CAAC,MAAM;QACfhB,KAAK,GAAG,IAAR;QACAD,OAAO,GAAG,IAAV;MACD,CAHS,EAGP,GAHO,CAAV;MAIA,OAAO,EACL,GAAGwJ,KADE;QAEL/M,OAAO,EAAE,KAFJ;QAGLF,SAAS,EAAE,KAHN;QAILG,KAAK,EAAE,EAAE,GAAGuI;QAAL;MAJF,CAAP;IAMD;EA1BY;AAtJW,CAAD,CAA3B,C,CAoLA;;AACAlF,OAAO,GAAGsJ,OAAO,CAACtJ,OAAlB;AAEA,OAAO,MAAM;EACXuK,kBADW;EAEXP,YAFW;EAGX/G,cAHW;EAIXyF,cAJW;EAKX3E,iBALW;EAMX6F,iBANW;EAOXD,yBAPW;EAQXH,MARW;EASXS,eATW;EAUXJ,YAVW;EAWXE;AAXW,IAYTT,OAAO,CAACtJ,OAZL;AAcP,eAAesJ,OAAO,CAACsB,OAAvB"},"metadata":{},"sourceType":"module"}