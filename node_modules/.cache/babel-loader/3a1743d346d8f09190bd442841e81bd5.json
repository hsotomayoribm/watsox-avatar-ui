{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { ROOT_CONTEXT } from '@opentelemetry/api';\n/**\n * Stack Context Manager for managing the state in web\n * it doesn't fully support the async calls though\n */\n\nvar StackContextManager =\n/** @class */\nfunction () {\n  function StackContextManager() {\n    /**\n     * whether the context manager is enabled or not\n     */\n    this._enabled = false;\n    /**\n     * Keeps the reference to current context\n     */\n\n    this._currentContext = ROOT_CONTEXT;\n  }\n  /**\n   *\n   * @param context\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  StackContextManager.prototype._bindFunction = function (context, target) {\n    if (context === void 0) {\n      context = ROOT_CONTEXT;\n    }\n\n    var manager = this;\n\n    var contextWrapper = function () {\n      var _this = this;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return manager.with(context, function () {\n        return target.apply(_this, args);\n      });\n    };\n\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length\n    });\n    return contextWrapper;\n  };\n  /**\n   * Returns the active context\n   */\n\n\n  StackContextManager.prototype.active = function () {\n    return this._currentContext;\n  };\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n\n\n  StackContextManager.prototype.bind = function (context, target) {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    }\n\n    return target;\n  };\n  /**\n   * Disable the context manager (clears the current context)\n   */\n\n\n  StackContextManager.prototype.disable = function () {\n    this._currentContext = ROOT_CONTEXT;\n    this._enabled = false;\n    return this;\n  };\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n\n\n  StackContextManager.prototype.enable = function () {\n    if (this._enabled) {\n      return this;\n    }\n\n    this._enabled = true;\n    this._currentContext = ROOT_CONTEXT;\n    return this;\n  };\n  /**\n   * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.\n   * The context will be set as active\n   * @param context\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n\n\n  StackContextManager.prototype.with = function (context, fn, thisArg) {\n    var args = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n\n    var previousContext = this._currentContext;\n    this._currentContext = context || ROOT_CONTEXT;\n\n    try {\n      return fn.call.apply(fn, __spreadArray([thisArg], __read(args), false));\n    } finally {\n      this._currentContext = previousContext;\n    }\n  };\n\n  return StackContextManager;\n}();\n\nexport { StackContextManager }; //# sourceMappingURL=StackContextManager.js.map","map":null,"metadata":{},"sourceType":"module"}