{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\n\nvar TemporalMetricProcessor =\n/** @class */\nfunction () {\n  function TemporalMetricProcessor(_aggregator) {\n    this._aggregator = _aggregator;\n    this._unreportedAccumulations = new Map();\n    this._reportHistory = new Map();\n  }\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n\n\n  TemporalMetricProcessor.prototype.buildMetrics = function (collector, collectors, instrumentDescriptor, currentAccumulations, collectionTime) {\n    this._stashAccumulations(collectors, currentAccumulations);\n\n    var unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);\n\n    var result = unreportedAccumulations;\n    var aggregationTemporality; // Check our last report time.\n\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      var last = this._reportHistory.get(collector);\n\n      var lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality; // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);\n    } // Update last reported (cumulative) accumulation.\n\n\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime: collectionTime,\n      aggregationTemporality: aggregationTemporality\n    });\n\n    return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, AttributesMapToAccumulationRecords(result),\n    /* endTime */\n    collectionTime);\n  };\n\n  TemporalMetricProcessor.prototype._stashAccumulations = function (collectors, currentAccumulation) {\n    var _this = this;\n\n    collectors.forEach(function (it) {\n      var stash = _this._unreportedAccumulations.get(it);\n\n      if (stash === undefined) {\n        stash = [];\n\n        _this._unreportedAccumulations.set(it, stash);\n      }\n\n      stash.push(currentAccumulation);\n    });\n  };\n\n  TemporalMetricProcessor.prototype._getMergedUnreportedAccumulations = function (collector) {\n    var e_1, _a;\n\n    var result = new AttributeHashMap();\n\n    var unreportedList = this._unreportedAccumulations.get(collector);\n\n    this._unreportedAccumulations.set(collector, []);\n\n    if (unreportedList === undefined) {\n      return result;\n    }\n\n    try {\n      for (var unreportedList_1 = __values(unreportedList), unreportedList_1_1 = unreportedList_1.next(); !unreportedList_1_1.done; unreportedList_1_1 = unreportedList_1.next()) {\n        var it_1 = unreportedList_1_1.value;\n        result = TemporalMetricProcessor.merge(result, it_1, this._aggregator);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (unreportedList_1_1 && !unreportedList_1_1.done && (_a = unreportedList_1.return)) _a.call(unreportedList_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return result;\n  };\n\n  TemporalMetricProcessor.merge = function (last, current, aggregator) {\n    var result = last;\n    var iterator = current.entries();\n    var next = iterator.next();\n\n    while (next.done !== true) {\n      var _a = __read(next.value, 3),\n          key = _a[0],\n          record = _a[1],\n          hash = _a[2];\n\n      if (last.has(key, hash)) {\n        var lastAccumulation = last.get(key, hash); // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        var accumulation = aggregator.merge(lastAccumulation, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n\n      next = iterator.next();\n    }\n\n    return result;\n  };\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n\n\n  TemporalMetricProcessor.calibrateStartTime = function (last, current, lastCollectionTime) {\n    var e_2, _a;\n\n    try {\n      for (var _b = __values(last.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n            key = _d[0],\n            hash = _d[1];\n\n        var currentAccumulation = current.get(key, hash);\n        currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return current;\n  };\n\n  return TemporalMetricProcessor;\n}();\n\nexport { TemporalMetricProcessor }; // TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\n\nfunction AttributesMapToAccumulationRecords(map) {\n  return Array.from(map.entries());\n} //# sourceMappingURL=TemporalMetricProcessor.js.map","map":null,"metadata":{},"sourceType":"module"}