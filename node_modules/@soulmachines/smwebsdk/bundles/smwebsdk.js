(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "AnimateToNamedCameraRequestBody": () => (/* reexport */ AnimateToNamedCameraRequestBody_namespaceObject.AnimateToNamedCameraRequestBody),
  "ConnectOptions": () => (/* reexport */ Scene_namespaceObject.ConnectOptions),
  "ConnectionState": () => (/* reexport */ ConnectionState),
  "ConnectionStateTypes": () => (/* reexport */ ConnectionStateTypes),
  "ContentAwareness": () => (/* reexport */ ContentAwareness),
  "ContentCardFormatter": () => (/* reexport */ ContentCardFormatter),
  "Conversation": () => (/* reexport */ Conversation),
  "ConversationResultResponseBody": () => (/* reexport */ ConversationResultResponseBody_namespaceObject.ConversationResultResponseBody),
  "ConversationSendRequestBody": () => (/* reexport */ ConversationSendRequestBody_namespaceObject.ConversationSendRequestBody),
  "ConversationSetVariablesRequestBody": () => (/* reexport */ ConversationSetVariablesRequestBody_namespaceObject.ConversationSetVariablesRequestBody),
  "ConversationState": () => (/* reexport */ ConversationState),
  "ConversationStateTypes": () => (/* reexport */ ConversationStateTypes),
  "DemoModeResponseBody": () => (/* reexport */ DemoModeResponseBody_namespaceObject.DemoModeResponseBody),
  "GetModelChildrenRequestBody": () => (/* reexport */ GetModelChildrenRequestBody_namespaceObject.GetModelChildrenRequestBody),
  "GetModelFilterSearchResultRequestBody": () => (/* reexport */ GetModelFilterSearchResultRequestBody_namespaceObject.GetModelFilterSearchResultRequestBody),
  "GetModelVariableFilterSearchResultRequestBody": () => (/* reexport */ GetModelVariableFilterSearchResultRequestBody_namespaceObject.GetModelVariableFilterSearchResultRequestBody),
  "GetModelVariablesListRequestBody": () => (/* reexport */ GetModelVariablesListRequestBody_namespaceObject.GetModelVariablesListRequestBody),
  "GetVariablesListRequestBody": () => (/* reexport */ GetVariablesListRequestBody_namespaceObject.GetVariablesListRequestBody),
  "GetVariablesRequestBody": () => (/* reexport */ GetVariablesRequestBody_namespaceObject.GetVariablesRequestBody),
  "LogLevel": () => (/* reexport */ Logger_namespaceObject.LogLevel),
  "NLPIntent": () => (/* reexport */ NLPIntent),
  "Persona": () => (/* reexport */ Persona),
  "PersonaRequestBody": () => (/* reexport */ PersonaRequestBody_namespaceObject.PersonaRequestBody),
  "PlayAnimationRequestBody": () => (/* reexport */ PlayAnimationRequestBody_namespaceObject.PlayAnimationRequestBody),
  "RecognizeResultsResponseBody": () => (/* reexport */ RecognizeResultsResponseBody_namespaceObject.RecognizeResultsResponseBody),
  "Scene": () => (/* reexport */ Scene),
  "SceneOptions": () => (/* reexport */ Scene_namespaceObject.SceneOptions),
  "SceneRequest": () => (/* reexport */ SceneRequest_namespaceObject.SceneRequest),
  "SceneRequestBody": () => (/* reexport */ SceneRequest_namespaceObject.SceneRequestBody),
  "SceneResponse": () => (/* reexport */ SceneResponse_namespaceObject.SceneResponse),
  "SceneResponseError": () => (/* reexport */ SceneResponseError),
  "SetVariablesRequestBody": () => (/* reexport */ SetVariablesRequestBody_namespaceObject.SetVariablesRequestBody),
  "SmEvent": () => (/* reexport */ SmEvent),
  "SpeechMarkerResponseBody": () => (/* reexport */ SpeechMarker_namespaceObject.SpeechMarkerResponseBody),
  "StartRecognizeRequestBody": () => (/* reexport */ StartRecognizeRequestBody_namespaceObject.StartRecognizeRequestBody),
  "StartSpeakingOptionalArgs": () => (/* reexport */ StartSpeakingRequestBody_namespaceObject.StartSpeakingOptionalArgs),
  "StartSpeakingRequestBody": () => (/* reexport */ StartSpeakingRequestBody_namespaceObject.StartSpeakingRequestBody),
  "StateResponseBody": () => (/* reexport */ StateResponseBody_namespaceObject.StateResponseBody),
  "StopBlProfilingRequestBody": () => (/* reexport */ StopBlProfilingRequestBody_namespaceObject.StopBlProfilingRequestBody),
  "UpdateContentAwarenessRequestBody": () => (/* reexport */ UpdateContentAwarenessRequestBody_namespaceObject.UpdateContentAwarenessRequestBody),
  "UserMedia": () => (/* reexport */ UserMedia),
  "WebsocketKind": () => (/* reexport */ WebsocketKind),
  "smwebsdk": () => (/* reexport */ smwebsdk)
});

// NAMESPACE OBJECT: ./src/utils/Logger.ts
var Logger_namespaceObject = {};
__webpack_require__.r(Logger_namespaceObject);
__webpack_require__.d(Logger_namespaceObject, {
  "Y": () => (Logger)
});

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/ConversationSendRequestBody.ts
var ConversationSendRequestBody_namespaceObject = {};
__webpack_require__.r(ConversationSendRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/ConversationSetVariablesRequestBody.ts
var ConversationSetVariablesRequestBody_namespaceObject = {};
__webpack_require__.r(ConversationSetVariablesRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/GetVariablesRequestBody.ts
var GetVariablesRequestBody_namespaceObject = {};
__webpack_require__.r(GetVariablesRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/PersonaRequestBody.ts
var PersonaRequestBody_namespaceObject = {};
__webpack_require__.r(PersonaRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/AnimateToNamedCameraRequestBody.ts
var AnimateToNamedCameraRequestBody_namespaceObject = {};
__webpack_require__.r(AnimateToNamedCameraRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/PlayAnimationRequestBody.ts
var PlayAnimationRequestBody_namespaceObject = {};
__webpack_require__.r(PlayAnimationRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/SetVariablesRequestBody.ts
var SetVariablesRequestBody_namespaceObject = {};
__webpack_require__.r(SetVariablesRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/GetVariablesListRequestBody.ts
var GetVariablesListRequestBody_namespaceObject = {};
__webpack_require__.r(GetVariablesListRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/GetModelVariablesListRequestBody.ts
var GetModelVariablesListRequestBody_namespaceObject = {};
__webpack_require__.r(GetModelVariablesListRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/GetModelChildrenRequestBody.ts
var GetModelChildrenRequestBody_namespaceObject = {};
__webpack_require__.r(GetModelChildrenRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/GetModelFilterSearchResultRequestBody.ts
var GetModelFilterSearchResultRequestBody_namespaceObject = {};
__webpack_require__.r(GetModelFilterSearchResultRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/GetModelVariableFilterSearchResultRequestBody.ts
var GetModelVariableFilterSearchResultRequestBody_namespaceObject = {};
__webpack_require__.r(GetModelVariableFilterSearchResultRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/StopBlProfilingRequestBody.ts
var StopBlProfilingRequestBody_namespaceObject = {};
__webpack_require__.r(StopBlProfilingRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/StartRecognizeRequestBody.ts
var StartRecognizeRequestBody_namespaceObject = {};
__webpack_require__.r(StartRecognizeRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/StartSpeakingRequestBody.ts
var StartSpeakingRequestBody_namespaceObject = {};
__webpack_require__.r(StartSpeakingRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/request-body/UpdateContentAwarenessRequestBody.ts
var UpdateContentAwarenessRequestBody_namespaceObject = {};
__webpack_require__.r(UpdateContentAwarenessRequestBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/SceneRequest.ts
var SceneRequest_namespaceObject = {};
__webpack_require__.r(SceneRequest_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/response-body/DemoModeResponseBody.ts
var DemoModeResponseBody_namespaceObject = {};
__webpack_require__.r(DemoModeResponseBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/response-body/RecognizeResultsResponseBody.ts
var RecognizeResultsResponseBody_namespaceObject = {};
__webpack_require__.r(RecognizeResultsResponseBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/response-body/ConversationResultResponseBody.ts
var ConversationResultResponseBody_namespaceObject = {};
__webpack_require__.r(ConversationResultResponseBody_namespaceObject);

// NAMESPACE OBJECT: ./src/websocket-message/scene/response-body/SpeechMarker.ts
var SpeechMarker_namespaceObject = {};
__webpack_require__.r(SpeechMarker_namespaceObject);
__webpack_require__.d(SpeechMarker_namespaceObject, {
  "Z": () => (SpeechMarkerName)
});

// NAMESPACE OBJECT: ./src/websocket-message/scene/response-body/StateResponseBody.ts
var StateResponseBody_namespaceObject = {};
__webpack_require__.r(StateResponseBody_namespaceObject);
__webpack_require__.d(StateResponseBody_namespaceObject, {
  "T": () => (FeatureFlag)
});

// NAMESPACE OBJECT: ./src/websocket-message/scene/SceneResponse.ts
var SceneResponse_namespaceObject = {};
__webpack_require__.r(SceneResponse_namespaceObject);

// NAMESPACE OBJECT: ./src/Scene.ts
var Scene_namespaceObject = {};
__webpack_require__.r(Scene_namespaceObject);
__webpack_require__.d(Scene_namespaceObject, {
  "x": () => (Scene)
});

;// CONCATENATED MODULE: ./src/SmEvent.ts
/**
 * @module smwebsdk
 */
/*
 * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.
 */
/**
 * An event which can have a set of listeners registered against it using addListener().
 * @public
 */
var SmEvent = /** @class */ (function () {
    function SmEvent() {
        // eslint-disable-next-line @typescript-eslint/ban-types
        this._callbacks = [];
    }
    /**
     * Register a new listener for this event.
     * @param callback - Function called each time the event is triggered.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    SmEvent.prototype.addListener = function (callback) {
        this._callbacks.push(callback);
    };
    /**
     * Deregister a existing listener for this event.
     * @param callback - Previously registered function to be removed. It is a safe no-op to pass
     * a callback which was never registered against this event.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    SmEvent.prototype.removeListener = function (callback) {
        var callbackIndex = this._callbacks.indexOf(callback);
        if (callbackIndex > -1) {
            this._callbacks.splice(callbackIndex, 1);
        }
    };
    /**
     * Trigger the event, calling each registered listener, and passing on any parameters.
     */
    SmEvent.prototype.call = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._callbacks.forEach(function (callback) {
            callback.apply(callback, args);
        }, this);
    };
    return SmEvent;
}());


;// CONCATENATED MODULE: ./src/Persona.ts
/**
 * @module smwebsdk
 */

/**
 * Persona class to control a scene persona
 * @public
 */
var Persona = /** @class */ (function () {
    /**
     * @param scene - The scene the persona resides in
     * @param personaId - The id of the persona as received in a state callback
     */
    function Persona(scene, personaId) {
        this._scene = scene;
        this._personaId = personaId;
        if (!this._scene.onConversationResultEvents[personaId]) {
            this._scene.onConversationResultEvents[personaId] = new SmEvent();
        }
        // /** Event which will be triggered whenever conversation results are received. Use
        //   *  onConversationResultEvents.addListener() to register a callback for this event.
        //   *  The single parameter to the callback will be an object with the fields:
        //   *    - **status**        - Status code
        //   *    - **errorMessage**  - Optional error strubg
        //   *    - **personaId**     - Numeric ID of Persona
        //   *    - **output:**
        //   *      - **text**        - Textual response from the converstation backend
        //   *    - **context**       - Dictionary of public conversation variables
        //   *    - **provider:**
        //   *      - **kind**        - Conversation backend name, eg "watson"
        //   *      - **meta**        - Conversation backend specific metadata
        //   */
        this._onConversationResultEvent =
            this._scene.onConversationResultEvents[personaId];
        if (!this._scene.onSpeechMarkerEvents[personaId]) {
            this._scene.onSpeechMarkerEvents[personaId] = new SmEvent();
        }
        // /** Event which will be triggered whenever a speech marker is reached. Use
        //   * onSpeechMarkerEvents.addListener() to register a callback for this event.
        //   * A speech marker is triggered using the format @marker(markername, param0,... paramn)
        //   * in speech. There are also other verbs which establish speech markers.
        //   * Eg @showcards(cardA, cardB). When using a speech marker with Watson Assistant,
        //   * the @ symbol must be escaped with a backslash, as follows:
        //   * \@marker(markername, param0,... paramn)
        //   * The single parameter to the callback will be an object with the fields:
        //   *    - **personaId**     - Numeric ID of Persona
        //   *    - **name**          - Kind of speech marker, eg, "showcards", "hidecards"
        //   *    - **arguements**    - Marker specific arguements.
        //   */
        this._onSpeechMarkerEvent = this._scene.onSpeechMarkerEvents[personaId];
    }
    /**
     * Start speaking the given text
     * @param text - The text to speak
     * @param context - The context included in the transcript
     * @param optionalArgs - Optional start speaking arguments or null
     */
    Persona.prototype.startSpeaking = function (text, context, optionalArgs) {
        if (context === void 0) { context = null; }
        if (optionalArgs === void 0) { optionalArgs = null; }
        var body = {
            personaId: this._personaId,
            text: text,
        };
        if (context) {
            body.context = context;
        }
        if (optionalArgs) {
            body.optionalArgs = optionalArgs;
        }
        return this._scene.sendRequest('startSpeaking', body);
    };
    /**
     * Stop speaking
     */
    Persona.prototype.stopSpeaking = function () {
        var body = {
            personaId: this._personaId,
        };
        return this._scene.sendRequest('stopSpeaking', body);
    };
    /**
     * Send a chat message to conversation
     * @param text - Text to send to conversation
     * @param variables - Variables to send to the conversation provider
     * @param optionalArgs - Optional arguments object (none currently supported)
     */
    Persona.prototype.conversationSend = function (text, variables, optionalArgs) {
        var body = {
            personaId: this._personaId,
            text: text,
            variables: variables,
            optionalArgs: optionalArgs,
        };
        return this._scene.sendRequest('conversationSend', body);
    };
    /**
     * Set variables that will be applied on the next conversation request
     * triggered by speech to text or a conversationSend()
     * @param variables - Variables to send to the conversation provider
     */
    Persona.prototype.conversationSetVariables = function (variables) {
        var body = {
            personaId: this._personaId,
            variables: variables,
        };
        return this._scene.sendRequest('conversationSetVariables', body);
    };
    /**
     * Get variables will return the current conversation variable values
     * in the promise completion.
     * Completion/promise receives an object with member 'variables'.
     */
    Persona.prototype.conversationGetVariables = function () {
        var body = {
            personaId: this._personaId,
        };
        return this._scene.sendRequest('conversationGetVariables', body);
    };
    /**
     * Cut or animate to a named camera position, with support for camera adjustment.
     * @param cameraName - Named camera position. The currently supported option is "CloseUp".
     * @param time - Time in seconds for the animation to run. 0 indicates a cut.
     * @param orbitDegX - Degrees of horizontal rotation around implicit orbit point of camera position (typically the middle of the Persona's head)
     * @param orbitDegY - Degrees of vertical rotation around implicit orbit point of camera position (typically the middle of the Persona's head)
     * @param panDeg - Degrees of camera pan. Orbital adjustment is applied before pan adjustment.
     * @param tiltDeg - Degrees of camera tilt. Orbital adjustment is applied before tilt adjustment.
     */
    Persona.prototype.animateToNamedCameraWithOrbitPan = function (cameraName, time, orbitDegX, orbitDegY, panDeg, tiltDeg) {
        var body = {
            personaId: this._personaId,
            cameraName: cameraName,
            time: time,
            orbitDegX: orbitDegX,
            orbitDegY: orbitDegY,
            panDeg: panDeg,
            tiltDeg: tiltDeg,
        };
        return this._scene.sendRequest('animateToNamedCamera', body);
    };
    /**
     * Play an animation.
     * @internal
     * @param animation - Structured animation data.
     */
    Persona.prototype.playAnimation = function (animation) {
        var body = {
            personaId: this._personaId,
            animation: animation,
        };
        return this._scene.sendRequest('playAnimation', body);
    };
    /**
     * Get & Set bl variables.
     * @internal
     */
    Persona.prototype.getVariables = function (names, errorTolerant, format) {
        if (errorTolerant === void 0) { errorTolerant = false; }
        if (format === void 0) { format = ''; }
        var body = {
            personaId: this._personaId,
            names: names,
            errorTolerant: errorTolerant,
            format: format,
        };
        return this._scene.sendRequest('getVariables', body);
    };
    /**
     * @internal
     */
    Persona.prototype.setVariables = function (variables) {
        var body = {
            personaId: this._personaId,
            Variables: variables,
        };
        return this._scene.sendRequest('setVariables', body);
    };
    /**
     * @internal
     */
    Persona.prototype.setVariablesOneway = function (variables) {
        var body = {
            personaId: this._personaId,
            Variables: variables,
        };
        this._scene.sendOnewaySceneRequest('setVariables', body);
    };
    /**
     * Get bl variables list.
     * @internal
     */
    Persona.prototype.getVariablesList = function () {
        var body = {
            personaId: this._personaId,
        };
        return this._scene.sendRequest('getVariablesList', body);
    };
    /**
     * Get model bl variables list.
     * @internal
     */
    Persona.prototype.getModelVariablesList = function (modelName) {
        var body = {
            personaId: this._personaId,
            Models: modelName,
        };
        return this._scene.sendRequest('getModelVariablesList', body);
    };
    /**
     * Get model children.
     * @internal
     */
    Persona.prototype.getModelChildren = function (modelName) {
        var body = {
            personaId: this._personaId,
            Models: modelName,
        };
        return this._scene.sendRequest('getModelChildren', body);
    };
    /**
     * Get model list by snippet.
     * @internal
     */
    Persona.prototype.getModelFilterSearchResult = function (modelName) {
        var body = {
            personaId: this._personaId,
            Models: modelName,
        };
        return this._scene.sendRequest('getModelFilterSearchResult', body);
    };
    /**
     * Get model variable list by snippet.
     * @internal
     */
    Persona.prototype.getModelVariableFilterSearchResult = function (variableName) {
        var body = {
            personaId: this._personaId,
            Models: variableName,
        };
        return this._scene.sendRequest('getModelVariableFilterSearchResult', body);
    };
    /**
     * Get connector entries.
     * @internal
     */
    Persona.prototype.getConnectorEntries = function (model) {
        var body = {
            personaId: this._personaId,
            model: model,
        };
        return this._scene.sendRequest('getConnectorEntries', body);
    };
    /**
     * Start BL profiling.
     * @internal
     */
    Persona.prototype.startBlProfiling = function () {
        var body = {
            personaId: this._personaId,
        };
        return this._scene.sendRequest('startBlProfiling', body);
    };
    /**
     * Stop BL profiling.
     * @internal
     */
    Persona.prototype.stopBlProfiling = function (reverse) {
        var body = {
            personaId: this._personaId,
            reverse: reverse,
        };
        return this._scene.sendRequest('stopBlProfiling', body);
    };
    /**
     * Get model hierarchy.
     * @internal
     */
    Persona.prototype.getModelHierarchy = function (model) {
        var body = {
            personaId: this._personaId,
            model: model,
        };
        return this._scene.sendRequest('getModelHierarchy', body);
    };
    /**
     * Monitor bl variables.
     * @internal
     */
    Persona.prototype.createMonitorSet = function (setName, variables) {
        var body = {
            personaId: this._personaId,
            setName: [{ SetName: setName }],
            variables: variables,
        };
        return this._scene.sendRequest('createMonitorSet', body);
    };
    /**
     * @internal
     */
    Persona.prototype.removeMonitorSet = function (setName) {
        var body = {
            personaId: this._personaId,
            setName: [{ SetName: setName }],
        };
        return this._scene.sendRequest('removeMonitorSet', body);
    };
    /**
     * @internal
     */
    Persona.prototype.addVariableToMonitorSet = function (setName, variables) {
        var body = {
            personaId: this._personaId,
            setName: [{ SetName: setName }],
            variables: variables,
        };
        return this._scene.sendRequest('addVariableToMonitorSet', body);
    };
    /**
     * @internal
     */
    Persona.prototype.removeVariableFromMonitorSet = function (setName, variables) {
        var body = {
            personaId: this._personaId,
            setName: [{ SetName: setName }],
            variables: variables,
        };
        return this._scene.sendRequest('removeVariableFromMonitorSet', body);
    };
    /**
     * @internal
     */
    Persona.prototype.renderModel = function (modelName) {
        var body = {
            personaId: this._personaId,
            modelName: modelName,
        };
        return this._scene.sendRequest('renderModel', body);
    };
    Object.defineProperty(Persona.prototype, "onConversationResultEvent", {
        get: function () {
            return this._onConversationResultEvent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Persona.prototype, "onSpeechMarkerEvent", {
        get: function () {
            return this._onSpeechMarkerEvent;
        },
        enumerable: false,
        configurable: true
    });
    return Persona;
}());


;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}

;// CONCATENATED MODULE: ./src/Deferred.ts
/**
 * @module smwebsdk
 */
/*
 * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.
 */
/**
 * Deferred class
 * @preferred
 */
var Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this.state = 'pending';
        this.fate = 'unresolved';
        this.promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
        this.promise.then(function () { return (_this.state = 'fulfilled'); }, function () { return (_this.state = 'rejected'); });
    }
    Deferred.prototype.resolve = function (value) {
        if (this.fate === 'resolved') {
            console.error('Deferred cannot be resolved twice');
            return;
        }
        this.fate = 'resolved';
        this._resolve(value);
    };
    Deferred.prototype.reject = function (reason) {
        if (this.fate === 'resolved') {
            console.error('Deferred cannot be resolved twice');
            return;
        }
        this.fate = 'resolved';
        this._reject(reason);
    };
    Deferred.prototype.isResolved = function () {
        return this.fate === 'resolved';
    };
    Deferred.prototype.isPending = function () {
        return this.state === 'pending';
    };
    Deferred.prototype.isFulfilled = function () {
        return this.state === 'fulfilled';
    };
    Deferred.prototype.isRejected = function () {
        return this.state === 'rejected';
    };
    return Deferred;
}());


;// CONCATENATED MODULE: ./src/Features.ts
/**
 * @module smwebsdk
 */
/*
 * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.
 */
/**
 * Features class
 *
 * An instance of this class can also be created by the convenience API function DetectCapabilities()
 *
 * ```ts
 * var features  = window.smwebsdk.DetectCapabilities();
 * ```
 *
 * which also calls the detectWebRTCFeatures() method.
 */
var Features_Features = /** @class */ (function () {
    function Features() {
        this._hasMicrophone = false;
        this._hasCamera = false;
        this._isAndroid = false;
        this._isBrowserSupported = false;
        this._isEdge = false;
        this._isIos = false;
        this._isAndroid = this.detectAndroid();
        this._isEdge = this.detectEdge();
        this._isIos = this.detectIos();
    }
    Features.prototype.detectEdge = function () {
        return this.userAgentMatches('Edge');
    };
    Features.prototype.detectAndroid = function () {
        return this.userAgentMatches('Android');
    };
    Features.prototype.detectIos = function () {
        var isIOS = (/iPad|iPhone|iPod/i.test(navigator.platform) ||
            (navigator &&
                navigator.platform === 'MacIntel' &&
                navigator.maxTouchPoints > 1)) &&
            !window.MSStream;
        return isIOS;
    };
    Features.prototype.userAgentMatches = function (text) {
        var userAgent = window.navigator.userAgent;
        var matches = userAgent.match(text);
        if (matches) {
            return matches.length > 0 ? true : false;
        }
        return false;
    };
    Features.prototype.detectWebRTCFeatures = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // Check for runtime host
            if (window.SmIsUnderRuntimeHost) {
                // TODO - detect whether camera/microphone is available in runtime host
                _this._isBrowserSupported = true;
                _this._hasMicrophone = true;
                _this._hasCamera = true;
                resolve(_this);
            }
            // This approach heavily influenced by the helpful and MIT licensed:
            //    https://github.com/muaz-khan/DetectRTC/blob/master/DetectRTC.js
            // Detect webrtc support
            var isWebRTCSupported = false;
            [
                'RTCPeerConnection',
                'webkitRTCPeerConnection',
                'mozRTCPeerConnection',
                'RTCIceGatherer',
            ].forEach(function (item) {
                if (isWebRTCSupported) {
                    return;
                }
                if (item in window) {
                    isWebRTCSupported = true;
                }
            });
            // Apparently IE11 injected iPhone into user agent string, hence check for not MSStream
            var iOS = navigator.userAgent.match(/iPhone|iPad|iPod/i) && !window.MSStream;
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            if (isWebRTCSupported && iOS && !isSafari) {
                // Webrtc is not supported on an iOS device using webview instead of full Safari
                isWebRTCSupported = false;
            }
            _this._isBrowserSupported = isWebRTCSupported;
            if (!_this._isBrowserSupported) {
                resolve(_this);
            }
            // Find the enumerate devices function if available
            var navEnumerateDevices = null;
            if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                // Firefox 38+ seems having support of enumerateDevices
                // Thanks @xdumaine/enumerateDevices
                // eslint-disable-next-line @typescript-eslint/ban-types
                navEnumerateDevices = function (callback) {
                    Promise.resolve(navigator.mediaDevices.enumerateDevices())
                        .then(function (value) {
                        if (value === void 0) { value = []; }
                        callback(value);
                    })
                        .catch(function () {
                        callback([]);
                    });
                };
            }
            var MediaStreamTrack = window.MediaStreamTrack;
            if (!navEnumerateDevices &&
                MediaStreamTrack &&
                MediaStreamTrack.getSources) {
                navEnumerateDevices =
                    MediaStreamTrack.getSources.bind(MediaStreamTrack);
            }
            if (!navEnumerateDevices && navigator.enumerateDevices) {
                // ! block was originally unreachable until bug is fixed in trunk
                navEnumerateDevices = navigator.enumerateDevices.bind(navigator);
            }
            // Enumerate the media devices
            if (navEnumerateDevices) {
                navEnumerateDevices(function (devices) {
                    devices.forEach(function (device) {
                        if (device.kind === 'audioinput') {
                            _this._hasMicrophone = true;
                        }
                        if (device.kind === 'videoinput') {
                            _this._hasCamera = true;
                        }
                    });
                    resolve(_this);
                });
            }
            else {
                resolve(_this);
            }
        });
    };
    Object.defineProperty(Features.prototype, "hasMicrophone", {
        get: function () {
            return this._hasMicrophone;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Features.prototype, "hasCamera", {
        get: function () {
            return this._hasCamera;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Features.prototype, "isAndroid", {
        get: function () {
            return this._isAndroid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Features.prototype, "isBrowserSupported", {
        get: function () {
            return this._isBrowserSupported;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Features.prototype, "isEdge", {
        get: function () {
            return this._isEdge;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Features.prototype, "isIos", {
        get: function () {
            return this._isIos;
        },
        enumerable: false,
        configurable: true
    });
    return Features;
}());


;// CONCATENATED MODULE: ./src/utils/Logger.ts

var logLevels = ['debug', 'log', 'warn', 'error'];
var Logger = /** @class */ (function () {
    function Logger(minLogLevel, isEnabled) {
        if (minLogLevel === void 0) { minLogLevel = 'log'; }
        if (isEnabled === void 0) { isEnabled = true; }
        this.isEnabled = isEnabled;
        this.availableLogLevels = [];
        this._minLogLevel = 'log';
        this.setMinLogLevel(minLogLevel);
    }
    Logger.prototype.log = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.isEnabled && this.availableLogLevels.includes(type)) {
            console[type].apply(console, __spreadArray([], __read(args), false));
        }
    };
    Logger.prototype.enableLogging = function (enable) {
        this.isEnabled = enable;
    };
    Logger.prototype.getMinLogLevel = function () {
        return this._minLogLevel;
    };
    Logger.prototype.setMinLogLevel = function (level) {
        var index = logLevels.indexOf(level);
        this._minLogLevel = level;
        this.availableLogLevels = logLevels.slice(index);
    };
    return Logger;
}());


;// CONCATENATED MODULE: ./src/utils/make-error.ts
function makeError(message, reason) {
    var error = new Error(message);
    error.name = reason;
    return error;
}

;// CONCATENATED MODULE: ./src/LocalSession.ts
/**
 * @module smwebsdk
 */

/*
 * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.
 */




/**
 *  LocalSession class
 */
var LocalSession = /** @class */ (function () {
    function LocalSession(videoElement, logger) {
        if (logger === void 0) { logger = new Logger(); }
        var _this = this;
        this.logger = logger;
        this._isMicrophoneConnected = false;
        this._isCameraConnected = false;
        this._onConnectedStorage = function (resumeRequested, isResumedSession, server, sessionId
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        ) { };
        this._closed = false;
        this._outgoingQueue = [];
        // Duration that microphone mute is maintained by the web sdk after the persona has
        // finished speaking.  Set to -1 to disable.  Default value is -1 (disabled).
        this._microphoneMuteDelay = -1;
        this._offsetX = 0;
        this._offsetY = 0;
        if (videoElement) {
            this._viewport_element = videoElement;
        }
        window.SmRuntimeHostReceiveMessage = this.receiveMessage.bind(this);
        if (typeof window.SmRuntimeHostStyleViewportElement === 'function') {
            window.SmRuntimeHostStyleViewportElement(this._viewport_element);
        }
        // owner specifies custom close method
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onClose = function (reason) { };
        // owner specifies custom message handler
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onMessage = function (message) { };
        // owner specifies custom rtc user text message handler
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onUserText = function (text) { };
        this.sendVideoBounds(0, 0);
        // The initial positioning can take a while. Would be nice to make this more deterministic.
        setTimeout(function () {
            _this.sendVideoBounds(0, 0);
        }, 3000);
        this._features = new Features_Features();
        this.log('Local session created!');
    }
    LocalSession.prototype.receiveMessage = function (raw_text) {
        var _a, _b;
        var message = JSON.parse(raw_text);
        this.log("message received: ".concat(raw_text));
        this._onMessage(message);
        if (message.name === 'state' &&
            message.category === 'scene' &&
            ((_b = (_a = message.body) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.state) === 'idle') {
            this.log('Local session ending - conversationEnded');
            this.close(true, 'conversationEnded');
        }
    };
    Object.defineProperty(LocalSession.prototype, "onConnected", {
        set: function (sessionFunction) {
            this._onConnectedStorage = sessionFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "onClose", {
        set: function (closeFunction) {
            this._onClose = closeFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "onMessage", {
        set: function (messageFunction) {
            this._onMessage = messageFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "onUserText", {
        set: function (userTextFunction) {
            this._onUserText = userTextFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "loggingEnabled", {
        get: function () {
            return this.logger.isEnabled;
        },
        /**
         * @deprecated use setLogging(boolean).
         */
        set: function (enable) {
            this.logger.log('warn', 'loggingEnabled is deprecated and will be removed in a future version. Please use setLogging(boolean)');
            this.logger.enableLogging(enable);
        },
        enumerable: false,
        configurable: true
    });
    LocalSession.prototype.setMinLogLevel = function (level) {
        this.logger.setMinLogLevel(level);
    };
    LocalSession.prototype.setLogging = function (enable) {
        this.logger.enableLogging(enable);
    };
    LocalSession.prototype.log = function (text) {
        this.logger.log('log', text);
    };
    LocalSession.prototype.sendVideoBounds = function (widthIgnored, heightIgnored) {
        var _this = this;
        // We need to defer the update very slightly to give the browser time to reflow,
        // otherwise we get out of date values for width, height etc:
        setTimeout(function () {
            // Brute-force method for getting pos and dimensions, as
            // getBoundingClientRect seems to be unreliable (sometimes
            // returning zeroes for left and right):
            var el = _this._viewport_element;
            if (el) {
                var view = document.defaultView || window;
                var width = parseInt(view.getComputedStyle(el).width, 10);
                var height = parseInt(view.getComputedStyle(el).height, 10);
                _this._offsetX = 0;
                _this._offsetY = 0;
                while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
                    _this._offsetX += el.offsetLeft - el.scrollLeft;
                    _this._offsetY += el.offsetTop - el.scrollTop;
                    el = el.offsetParent;
                }
                if (document.documentElement) {
                    var x_off = document.documentElement.scrollLeft;
                    var y_off = document.documentElement.scrollTop;
                    _this._offsetX -= x_off;
                    _this._offsetY -= y_off;
                }
                _this.log("Updating bounds: x =  ".concat(_this._offsetX, " , y = ").concat(_this._offsetY, "', w = ").concat(width, ", h = ").concat(height));
                // update bounds
                var top = _this._offsetY;
                var left = _this._offsetX;
                var bottom = _this._offsetY + height;
                var right = _this._offsetX + width;
                var payload = {
                    name: 'videoBounds',
                    body: { top: top, left: left, bottom: bottom, right: right },
                    category: 'local',
                    kind: 'event',
                };
                _this.sendMessage(payload);
            }
        }, 0);
    };
    LocalSession.prototype.hideVideo = function () {
        var top = 0;
        var left = 0;
        var bottom = 0;
        var right = 0;
        var payload = {
            name: 'videoBounds',
            body: { top: top, left: left, bottom: bottom, right: right },
            category: 'local',
            kind: 'event',
        };
        this.sendMessage(payload);
    };
    LocalSession.prototype.sendRtcEvent = function (name, body) {
        // NOOP: Stuff for compatibility with Session in Scene
    };
    LocalSession.prototype.connect = function () {
        return __awaiter(this, void 0, Promise, function () {
            var deferred, result, payload;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deferred = new Deferred();
                        this.log('Local session connecting!');
                        this._closed = false;
                        return [4 /*yield*/, this._features.detectWebRTCFeatures()];
                    case 1:
                        result = _a.sent();
                        this._closed = false;
                        this._sessionId = undefined;
                        this._isMicrophoneConnected = result.hasMicrophone;
                        this._isCameraConnected = result.hasCamera;
                        if (typeof window.local_websocket_port === 'number') {
                            this._serverConnection = new WebSocket('ws://localhost:' + window.local_websocket_port);
                            this.log('websocket open');
                            this._serverConnection.onmessage = function (msg) {
                                _this.gotMessageFromServer(msg);
                            };
                            this._serverConnection.onerror = function (event) {
                                if (deferred.isPending()) {
                                    deferred.reject(makeError('websocket failed', 'serverConnectionFailed'));
                                }
                            };
                            this._serverConnection.onopen = function (event) {
                                // disable SmRuntimeHostReceiveMessage
                                // eslint-disable-next-line @typescript-eslint/no-empty-function
                                window.SmRuntimeHostReceiveMessage = function () { };
                                _this.log('Local session connected!');
                                // send out messages in queue
                                for (var i = 0; i < _this._outgoingQueue.length; i++) {
                                    _this._serverConnection.send(JSON.stringify(_this._outgoingQueue[i]));
                                    _this.logger.log('log', 'SmLocalSession.prototype.sendMessage, forwarding message to Web Socket: ' +
                                        _this._outgoingQueue[i]);
                                }
                                _this._outgoingQueue = [];
                                if (deferred.isPending()) {
                                    deferred.resolve();
                                }
                            };
                            this._serverConnection.onclose = function (event) {
                                _this.logger.log('log', "websocket closed: code(".concat(event.code, "), reason(").concat(event.reason, "), clean(").concat(event.wasClean, ")"));
                                if (!deferred.isRejected) {
                                    _this.close(false, 'normal');
                                }
                            };
                        }
                        else {
                            this.log('local_websocket_port not found! Failed to create WebSocket');
                            if (deferred.isPending()) {
                                deferred.reject(makeError('websocket failed', 'local_websocket_port not found'));
                            }
                        }
                        payload = {
                            name: 'startSession',
                            body: {},
                            category: 'scene',
                            kind: 'request',
                        };
                        this.sendMessage(payload);
                        return [2 /*return*/, deferred.promise];
                }
            });
        });
    };
    LocalSession.prototype.gotMessageFromServer = function (websocket_message) {
        var raw_text = websocket_message.data;
        var message = JSON.parse(raw_text);
        var category = message.category;
        var name = message.name;
        var body = message.body;
        if (category !== 'webrtc') {
            // forward on non-webrtc messages (e.g. scene)
            this._onMessage(message);
        }
        else if (name === 'close') {
            this.close(false, body.reason);
        }
        if (name === 'state' &&
            category === 'scene' &&
            body.session !== null &&
            body.session !== undefined &&
            body.session.state === 'idle') {
            this.log('Local session ending due to server idle message');
            this.close(true, 'conversationEnded');
        }
    };
    LocalSession.prototype.sendMessage = function (message) {
        var msg = JSON.stringify(message);
        if (this._serverConnection &&
            this._serverConnection.readyState === WebSocket.OPEN) {
            this._serverConnection.send(msg);
            this.log("SmLocalSession.prototype.sendMessage, forwarding message to Web Socket: ".concat(msg));
        }
        else {
            this._outgoingQueue.push(message);
        }
    };
    LocalSession.prototype.sendUserText = function (text) {
        this.logger.log('log', 'SmLocalSession.prototype.sendUserText, discarding text: ' + text);
    };
    LocalSession.prototype.close = function (sendRtcClose, reason) {
        if (sendRtcClose === void 0) { sendRtcClose = true; }
        if (reason === void 0) { reason = 'normal'; }
        if (this._closed) {
            return;
        }
        this._closed = true;
        this._onClose(reason);
        this._isMicrophoneConnected = false;
        this._isCameraConnected = false;
        this.hideVideo();
        if (this._serverConnection) {
            this.log('closing server connection');
            var normalClosureCode = 1000;
            this._serverConnection.close(normalClosureCode, reason);
        }
    };
    Object.defineProperty(LocalSession.prototype, "peerConnection", {
        get: function () {
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "userMediaStream", {
        get: function () {
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "serverConnection", {
        get: function () {
            return this._serverConnection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "sessionId", {
        get: function () {
            return this._sessionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "isMicrophoneConnected", {
        get: function () {
            return this._isMicrophoneConnected;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "isCameraConnected", {
        get: function () {
            return this._isCameraConnected;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "features", {
        get: function () {
            return this._features;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "microphoneMuteDelay", {
        get: function () {
            return this._microphoneMuteDelay;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "microphoneMuted", {
        get: function () {
            // todo - RuntimeHost does not yet support this,
            //        currently only needed in webrtc sessions and tests
            if (typeof window.SmRuntimeHostIsMicrophoneMuted === 'function') {
                return window.SmRuntimeHostIsMicrophoneMuted();
            }
            return false;
        },
        set: function (mute) {
            // todo - RuntimeHost does not yet support this,
            //        currently only needed in webrtc sessions and tests
            if (typeof window.SmRuntimeHostMuteMicrophone === 'function') {
                window.SmRuntimeHostMuteMicrophone(mute);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "offsetX", {
        get: function () {
            return this._offsetX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LocalSession.prototype, "offsetY", {
        get: function () {
            return this._offsetY;
        },
        enumerable: false,
        configurable: true
    });
    LocalSession.prototype.isMicrophoneActive = function () {
        return this.isMicrophoneConnected && !this.microphoneMuted;
    };
    LocalSession.prototype.isCameraActive = function () {
        return this.isCameraConnected;
    };
    LocalSession.prototype.setMediaDeviceActive = function (_a) {
        var microphone = _a.microphone, camera = _a.camera;
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_b) {
                throw makeError('setMediaDeviceActive not supported on LocalSession', 'notSupported');
            });
        });
    };
    return LocalSession;
}());


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/ConversationSendRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/ConversationSetVariablesRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/GetVariablesRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/PersonaRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/AnimateToNamedCameraRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/PlayAnimationRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/SetVariablesRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/GetVariablesListRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/GetModelVariablesListRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/GetModelChildrenRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/GetModelFilterSearchResultRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/GetModelVariableFilterSearchResultRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/StopBlProfilingRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/StartRecognizeRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/StartSpeakingRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/request-body/UpdateContentAwarenessRequestBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/SceneRequest.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/response-body/DemoModeResponseBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/response-body/RecognizeResultsResponseBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/response-body/ConversationResultResponseBody.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/response-body/SpeechMarker.ts
var SpeechMarkerName;
(function (SpeechMarkerName) {
    SpeechMarkerName["Showcards"] = "showcards";
    SpeechMarkerName["Hidecards"] = "hidecards";
    SpeechMarkerName["Feature"] = "feature";
    SpeechMarkerName["Marker"] = "marker";
})(SpeechMarkerName || (SpeechMarkerName = {}));

;// CONCATENATED MODULE: ./src/websocket-message/scene/response-body/StateResponseBody.ts
var FeatureFlag;
(function (FeatureFlag) {
    FeatureFlag["UI_CONTENT_AWARENESS"] = "UI_CONTENT_AWARENESS";
    FeatureFlag["UI_SDK_CAMERA_CONTROL"] = "UI_SDK_CAMERA_CONTROL";
})(FeatureFlag || (FeatureFlag = {}));

;// CONCATENATED MODULE: ./src/websocket-message/scene/SceneResponse.ts


;// CONCATENATED MODULE: ./src/websocket-message/scene/SceneResponseError.ts

/**
 * @public
 */
var SceneResponseError = /** @class */ (function (_super) {
    __extends(SceneResponseError, _super);
    function SceneResponseError() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.requestName = '';
        _this.status = 0;
        return _this;
    }
    Object.defineProperty(SceneResponseError.prototype, "message", {
        get: function () {
            return "Scene response failed, status: ".concat(this.status);
        },
        enumerable: false,
        configurable: true
    });
    return SceneResponseError;
}(Error));


;// CONCATENATED MODULE: ./src/websocket-message/scene/index.ts

























;// CONCATENATED MODULE: ./src/types/scene.ts


/**
 * Represents the different combinations of User Media that are supported
 * @public
 */
var UserMedia;
(function (UserMedia) {
    UserMedia[UserMedia["None"] = 0] = "None";
    UserMedia[UserMedia["Microphone"] = 1] = "Microphone";
    UserMedia[UserMedia["MicrophoneAndCamera"] = 2] = "MicrophoneAndCamera";
    UserMedia[UserMedia["Camera"] = 3] = "Camera";
})(UserMedia || (UserMedia = {}));
/**
 * @public
 */
var NLPIntent;
(function (NLPIntent) {
    NLPIntent["PAGE_METADATA"] = "PAGE_METADATA";
})(NLPIntent || (NLPIntent = {}));

;// CONCATENATED MODULE: ./src/enums/ConnectionStateTypes.ts
/**
 * @public
 */
var ConnectionStateTypes;
(function (ConnectionStateTypes) {
    ConnectionStateTypes["Disconnected"] = "Disconnected";
    //websocket open - searching for an available DP scene, may require queuing
    ConnectionStateTypes["SearchingForDigitalPerson"] = "SearchingForDigitalPerson";
    //established - scene is available/found, downloading/preparing DP assets on the server
    ConnectionStateTypes["DownloadingAssets"] = "DownloadingAssets";
    //accepted - DP is starting / forming webrtc connection
    ConnectionStateTypes["ConnectingToDigitalPerson"] = "ConnectingToDigitalPerson";
    //connected - DP is started and ready the webrtc session has connected
    ConnectionStateTypes["Connected"] = "Connected";
})(ConnectionStateTypes || (ConnectionStateTypes = {}));

;// CONCATENATED MODULE: ./src/Session.ts
/**
 * @module smwebsdk
 */

/*
 * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.
 */





// Reexporting here to keep backwards compatibility

/**
 *  Session class
 */
var Session = /** @class */ (function () {
    function Session(videoElement, serverUri, connectUserText, accessToken, audioOnly, requestedUserMedia, requiredUserMedia, echoCancellationEnabled, logger, connectionState) {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/ban-types
        this._connectPendingRemoteStream = null;
        this._resumeRequested = false;
        this._isResumedSession = false;
        this._outgoingQueue = [];
        this._controlOpen = false;
        this._controlQueue = [];
        this._requestedUserMedia = UserMedia.None;
        this._requiredUserMedia = UserMedia.None;
        this._onConnected = function (resumeRequested, isResumedSession, server, sessionId
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        ) { };
        this._pendingLog = [];
        this._closed = false;
        this._shouldLogToServer = false;
        // Duration that microphone mute is maintained by the web sdk after the persona has
        // finished speaking.  Set to -1 to disable.  Default value is -1 (disabled) if not specified
        // by server in 'established' message.
        this._microphoneMuteDelay = -1;
        this._changeUserMediaQueue = new Array();
        this._removeListeners = new Array();
        this._videoOptions = {
            frameRate: 10.0,
            width: 640.0,
            height: 480.0,
            facingMode: 'user',
        };
        // TypeScript support to MediaTrackConstraints is not complete, thus using any here
        this._audioOptions = {
            noiseSuppression: false,
            autoGainControl: false,
            channelCount: 1,
            sampleRate: 16000,
            sampleSize: 16,
            echoCancellation: true,
        };
        this._videoElement = videoElement;
        this._serverUri = serverUri;
        this._connectUserText = connectUserText || '';
        this._accessToken = accessToken;
        this._audioOnly = audioOnly;
        this._audioOptions.echoCancellation = echoCancellationEnabled;
        this._requiredUserMedia = requiredUserMedia;
        this._requestedUserMedia = requestedUserMedia;
        this._logger = logger;
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onClose = function (reason) { }; // owner specifies custom close method
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onMessage = function (message) { }; // owner specifies custom message handler
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onUserText = function (text) { }; // owner specifies custom rtc user text message handler
        this._sessionError = function (error) {
            // owner can specify custom session error handler
            _this.log("session error: ".concat(error), 'error');
        };
        this._features = new Features_Features();
        this._connectionState = connectionState;
    }
    Object.defineProperty(Session.prototype, "onConnected", {
        set: function (sessionFunction) {
            this._onConnected = sessionFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "onClose", {
        set: function (closeFunction) {
            this._onClose = closeFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "onMessage", {
        set: function (messageFunction) {
            this._onMessage = messageFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "onUserText", {
        set: function (userTextFunction) {
            this._onUserText = userTextFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "loggingEnabled", {
        /**
         * @deprecated use Scene method
         */
        get: function () {
            return this._logger.isEnabled;
        },
        /**
         * @deprecated use Scene
         */
        set: function (enable) {
            this.log('loggingEnabled is deprecated and will be removed in a future version. Please use setLogging(boolean)', 'warn');
            this._logger.enableLogging(enable);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @deprecated use Scene method
     */
    Session.prototype.setMinLogLevel = function (level) {
        this._logger.setMinLogLevel(level);
    };
    /**
     * @deprecated use Scene method
     */
    Session.prototype.setLogging = function (enable) {
        this._logger.enableLogging(enable);
    };
    Session.prototype.log = function (text, level) {
        if (level === void 0) { level = 'debug'; }
        if (this._logger.isEnabled) {
            var now = new Date();
            var msg = "smsdk: ".concat(now.toISOString(), ": ").concat(text);
            if (this._shouldLogToServer) {
                this.logToServer(msg);
            }
            this._logger.log(level, msg);
        }
    };
    Session.prototype.logToServer = function (msg) {
        if (this.sessionId) {
            this.sendlogMessage([msg]);
        }
        else {
            this._pendingLog.push(msg);
        }
    };
    Session.prototype.sendlogMessage = function (textArray) {
        if (this._sessionId && textArray && textArray.length > 0) {
            var payload = {
                category: 'diagnostics',
                kind: 'event',
                name: 'log',
                body: { name: 'browser', text: textArray },
            };
            this.sendMessage(payload);
        }
    };
    Session.prototype.connect = function (userText) {
        return __awaiter(this, void 0, Promise, function () {
            var deferred, xhr;
            var _this = this;
            return __generator(this, function (_a) {
                deferred = new Deferred();
                this._closed = false;
                if (userText) {
                    this._connectUserText = userText;
                }
                if (this._serverUri &&
                    (this._serverUri.startsWith('ws:') || this._serverUri.startsWith('wss:'))) {
                    // A server uri has been specified, continue with the connection
                    // by acquiring user media (microphone/camera) as needed
                    this.selectUserMedia(this._requestedUserMedia, this._requiredUserMedia, deferred, this.getUserMediaSuccess.bind(this));
                    return [2 /*return*/, deferred.promise];
                }
                xhr = new XMLHttpRequest();
                xhr.open('GET', '/api/jwt' + window.location.search);
                xhr.onreadystatechange = function (ev) { return __awaiter(_this, void 0, void 0, function () {
                    var response;
                    return __generator(this, function (_a) {
                        if (xhr.readyState === XMLHttpRequest.DONE) {
                            if (xhr.status === 200) {
                                this.log("JWT request returned: ".concat(xhr.responseText));
                                response = JSON.parse(xhr.responseText);
                                this._serverUri = response.url;
                                this._accessToken = response.jwt;
                                this.selectUserMedia(this._requestedUserMedia, this._requiredUserMedia, deferred, this.getUserMediaSuccess.bind(this));
                            }
                            else {
                                this.log("JWT Request failed, status: ".concat(xhr.statusText), 'error');
                                deferred.reject(makeError('Failed to acquire jwt at /api/jwt', 'noServer'));
                            }
                        }
                        return [2 /*return*/];
                    });
                }); };
                xhr.send();
                return [2 /*return*/, deferred.promise];
            });
        });
    };
    Session.prototype.webcamRequested = function (requestedMedia, requiredMedia) {
        return (!this._audioOnly &&
            [UserMedia.MicrophoneAndCamera, UserMedia.Camera].some(function (r) {
                return [requestedMedia, requiredMedia].includes(r);
            }));
    };
    Session.prototype.micRequested = function (requestedMedia, requiredMedia) {
        return [UserMedia.Microphone, UserMedia.MicrophoneAndCamera].some(function (r) {
            return [requestedMedia, requiredMedia].includes(r);
        });
    };
    Session.prototype.getMediaConstraints = function (requestedMedia, requiredMedia) {
        // checking supported constraints only for debugging purpose, no need to use it when applying constraints
        // as providing specific values for constraints, means they are a 'best effort' rather than required
        // https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API/Constraints#requesting_a_specific_value_for_a_setting
        var supports = navigator.mediaDevices.getSupportedConstraints();
        this.log("Browser supports media constraints: ".concat(supports));
        return {
            audio: this.micRequested(requestedMedia, requiredMedia)
                ? this.buildAudioOptions()
                : false,
            video: this.webcamRequested(requestedMedia, requiredMedia)
                ? this._videoOptions
                : false,
        };
    };
    Session.prototype.buildAudioOptions = function () {
        var supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
        var constraints = __assign({}, this._audioOptions);
        // Remove unknown and unsupported constraints, as these were causing errors in the latest version on Safari
        Object.keys(constraints).forEach(function (constraint) {
            if (!supportedConstraints[constraint]) {
                delete constraints[constraint];
            }
        });
        return constraints;
    };
    Session.prototype.selectUserMedia = function (requestedMedia, requiredMedia, deferred, completion) {
        var _this = this;
        if (requestedMedia === UserMedia.None && requiredMedia === UserMedia.None) {
            // no microphone or camera is required or requested
            completion(null, deferred);
            return;
        }
        if (navigator.mediaDevices.getUserMedia) {
            var constraints = this.getMediaConstraints(requestedMedia, requiredMedia);
            this.log("Best video constraints: ".concat(constraints));
            navigator.mediaDevices
                .getUserMedia(constraints)
                .then(function (stream) {
                completion(stream, deferred);
            })
                .catch(function (error) {
                //fail when required media wasn't obtained
                if (requiredMedia === requestedMedia) {
                    _this.log("getUserMedia could not get required media, error given: ".concat(error), 'error');
                    deferred.reject(_this.MakeErrorForUserMedia(error));
                }
                //re-try required media fallback
                else if (requiredMedia !== UserMedia.None) {
                    _this.getUserMediaRequiredOnlyFallback(requiredMedia, deferred, completion);
                }
                //re-try mic only fallback
                else if (requestedMedia === UserMedia.MicrophoneAndCamera) {
                    _this.getUserMediaAudioOnlyFallback(deferred, completion);
                }
                //complete without a stream
                else {
                    completion(null, deferred);
                }
            });
        }
        else {
            deferred.reject(makeError('Your browser does not support getUserMedia API', 'notSupported'));
        }
    };
    Session.prototype.getUserMediaRequiredOnlyFallback = function (requiredMedia, deferred, completion) {
        var _this = this;
        this.log('Retrying with required media only');
        var constraints = this.getMediaConstraints(UserMedia.None, requiredMedia);
        this.log("Attempt constraints: ".concat(constraints));
        return navigator.mediaDevices
            .getUserMedia(constraints)
            .then(function (stream) {
            completion(stream, deferred);
        })
            .catch(function (error) {
            _this.log("getUserMedia could not get required media, error given: ".concat(error), 'error');
            //fail when required media wasn't obtained
            deferred.reject(_this.MakeErrorForUserMedia(error));
        });
    };
    Session.prototype.getUserMediaAudioOnlyFallback = function (deferred, completion) {
        var _this = this;
        this.log('Retrying with microphone only');
        var constraints = {
            video: false,
            audio: this.buildAudioOptions(),
        };
        this.log("Attempt constraints: ".concat(constraints));
        return navigator.mediaDevices
            .getUserMedia(constraints)
            .then(function (stream) {
            completion(stream, deferred);
        })
            .catch(function (error) {
            _this.log("getUserMedia could not get microphone audio, error given: ".concat(error), 'error');
            // still succeed as fallback is only tried if media was required, not requested
            completion(null, deferred);
        });
    };
    Session.prototype.MakeErrorForUserMedia = function (error) {
        var name = 'noUserMedia';
        // Returning more specific errors below is considered a breaking change which we
        // cannot accommodate currently. This will be reinstated in the future, likely for v15
        // At that time, the error codes in Scene.connect() and scene.setMediaDeviceActive() need re-documenting -
        // see https://github.com/soulmachines/smwebsdk/blob/dfe3e1dc8d57aac17cb0be38fa2527190cd78ef4/src/Scene.ts#L916-L918
        // if (error.name === 'NotAllowedError' || error.name === 'SecurityError') {
        //   name = 'userMediaNotAllowed';
        // } else if (
        //   error.name === 'AbortError' ||
        //   error.name === 'NotReadableError'
        // ) {
        //   name = 'userMediaFailed';
        // }
        return makeError(error.message, name);
    };
    Session.prototype.getUserMediaSuccess = function (stream, deferred) {
        var _this = this;
        this.log('Got user media');
        this._localStream = stream;
        this.microphoneMuted = true; // mute the local microphone until the DP is visible
        // Connect to the session server
        // To pass the Json Web Token (jwt) to the server when opening the websocket
        // we basically have three options with the available javascript api:
        // 1) pass as a 'access_token' query parameter similar to auth2 bearer tokens when not auth header
        // 2) pass as basic auth user/pass embedded in the url
        // 3) pass as a custom protocol which is translated into the 'Sec-WebSocket-Protocol' request header
        //    more info here: https://stackoverflow.com/questions/4361173/http-headers-in-websockets-client-api
        // We've gone with using a query parameter with ssl.
        // create and connect the websocket
        // Note that javscript websockets do not allow most request headers to be set.  The two exceptions
        // are the Authorization header (via basic auth) and the protocol header - neither of which
        // are ideal for our jwt token.  Hence instead we pass the jwt as a query parameter.
        this.log("connecting to: ".concat(this._serverUri));
        if (!this._accessToken) {
            this._serverConnection = new WebSocket(this._serverUri);
        }
        else {
            this._serverConnection = new WebSocket(this._serverUri + '?access_token=' + this._accessToken);
        }
        this._serverConnection.onmessage = function (msg) {
            try {
                _this.gotMessageFromServer(msg, deferred);
            }
            catch (e) {
                _this.log("unexpected exception processing received message: ".concat(e), 'error');
            }
        };
        this._serverConnection.onerror = function (event) {
            if (deferred.isPending()) {
                deferred.reject(makeError('websocket failed', 'serverConnectionFailed'));
            }
        };
        // wait for the websocket to open, then continue with setup
        this._serverConnection.onopen = function (event) {
            _this.log('Websocket open');
            // wait for the welcome 'established' message to receive the ice servers, hence nothing more to do here
            // websocket open - searching for an available DP scene, may require queuing
            _this._connectionState.setConnectionState(ConnectionStateTypes.SearchingForDigitalPerson);
        };
        // setup a close handler
        this._serverConnection.onclose = function (event) {
            _this.log("websocket closed: code(".concat(event.code, "), reason(").concat(event.reason, "), clean(").concat(event.wasClean, ")"));
            if (!deferred.isRejected) {
                _this.close(false, 'normal', deferred);
            }
        };
    };
    Session.prototype.hasTurnServer = function (iceServers) {
        var e_1, _a, e_2, _b;
        // Check for at least one turn server by url in the array of ice servers
        if (!iceServers) {
            return false;
        }
        try {
            for (var iceServers_1 = __values(iceServers), iceServers_1_1 = iceServers_1.next(); !iceServers_1_1.done; iceServers_1_1 = iceServers_1.next()) {
                var server = iceServers_1_1.value;
                if (!server || !server.urls) {
                    continue;
                }
                try {
                    for (var _c = (e_2 = void 0, __values(server.urls)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var url = _d.value;
                        if (url.indexOf('turn:') === 0) {
                            return true;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (iceServers_1_1 && !iceServers_1_1.done && (_a = iceServers_1.return)) _a.call(iceServers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    Session.prototype.gotMessageFromServer = function (websocket_message, deferred) {
        var _this = this;
        var _a, _b;
        var raw_text = websocket_message.data;
        this.log("message received: ".concat(raw_text));
        var message = JSON.parse(raw_text);
        var category = message.category;
        var name = message.name;
        var body = message.body;
        if (category !== 'webrtc') {
            // If there is a control connection then forward 'scene' messages to that
            if (this._controlConnection !== null && category === 'scene') {
                if (this._controlOpen &&
                    this._serverConnection.readyState === WebSocket.OPEN) {
                    this._controlConnection.send(raw_text);
                }
                else {
                    this._controlQueue.push(raw_text);
                }
            }
            // forward on non-webrtc messages (e.g. scene)
            this._onMessage(message);
            return;
        }
        if (message.kind !== 'event') {
            // currently ignore requests and responses
            return;
        }
        if (name === 'established') {
            // established - scene is available/found, downloading/preparing DP assets on the server
            this._connectionState.setConnectionState(ConnectionStateTypes.DownloadingAssets);
            // Create the peer connection configuration from the established body
            // which includes the ice servers we should use
            var config = { iceServers: [] };
            if (body.iceServers) {
                config.iceServers = body.iceServers;
                // If at least one ice server is a turn server then force
                // our traffic to route over turn (relay)
                if (this.hasTurnServer(body.iceServers)) {
                    this.log('Detected turn server, forcing relay mode');
                    config.iceTransportPolicy = 'relay';
                }
            }
            this.log("selected ice servers: ".concat(config.iceServers));
            if (body.settings &&
                typeof body.settings.microphoneMuteDelay === 'number') {
                this._microphoneMuteDelay = body.settings.microphoneMuteDelay;
            }
            this.log("microphone mute delay after persona speech: ".concat(this._microphoneMuteDelay));
            // Send logging to server if requested by the server
            this._shouldLogToServer = (_b = (_a = body.settings) === null || _a === void 0 ? void 0 : _a.logToServer) !== null && _b !== void 0 ? _b : false;
            // Setup the WebRTC peer connection
            this._peerConnection = new RTCPeerConnection(config);
            // ref: Ice candidate will only trigger when media video is enabled in Safari
            // https://stackoverflow.com/a/53914556
            this._peerConnection.onicecandidate = this.gotIceCandidate.bind(this);
            if ('ontrack' in this._peerConnection && !this._features.isEdge) {
                // todo update when angular 7
                // This doesnt work with angular yet because of old definitions
                // this._peerConnection.ontrack = (event:RTCTrackEvent)=>{
                this._peerConnection.ontrack = function (event) {
                    if (event.track.kind === 'video' || event.track.kind === 'audio') {
                        if (!_this._remoteStream ||
                            (!_this._audioOnly && event.track.kind === 'video')) {
                            _this.onRemoteStream(event.streams[0]);
                        }
                    }
                };
                // Attach a video loaded event so the server can be notified when the video is
                // ready to start playing
                this._videoElement.addEventListener('loadeddata', this.onVideoLoaded.bind(this));
                this._removeListeners.push({
                    target: this._videoElement,
                    name: 'loadeddata',
                    callback: this.onVideoLoaded,
                });
            }
            else {
                // fallback to stream (for IE/Safari plugin)
                // onaddstream is deprecated
                // This feature has been removed from the Web standards.
                // Though some browsers may still support it, it is in the process of being dropped.
                // Writing like this to pass type checking as this isnt in current spec and therefore
                // neither the type definitions
                this._peerConnection.onaddstream = function (
                // as any because MediaStreamEvent has been removed from lib.dom.d.ts
                streamEvent) {
                    _this.onRemoteStream(streamEvent.stream);
                };
            }
            this._peerConnection.oniceconnectionstatechange = function (e) {
                // `this._peerConnection.iceConnectionState === 'disconnected'` is quite handy
                _this.log("ICE connection state: ".concat(_this._peerConnection.iceConnectionState));
                if (_this._peerConnection.iceConnectionState === 'failed') {
                    makeError('ice connection failed', 'mediaStreamFailed');
                    if (deferred && deferred.isPending()) {
                        // Close the connection and reject the connect()
                        _this._serverConnection.close();
                        if (_this._controlConnection &&
                            (_this._controlConnection.readyState === WebSocket.OPEN ||
                                _this._controlConnection.readyState === WebSocket.CONNECTING)) {
                            _this._controlConnection.close();
                        }
                        deferred.reject(makeError('ice connection failed', 'mediaStreamFailed'));
                    }
                }
            };
            this.log('adding local media stream if any');
            if (this._localStream) {
                if (!this._peerConnection.addTrack) {
                    this._peerConnection.addStream(this._localStream);
                    this.log('adding local media stream by stream');
                }
                else {
                    try {
                        this.log('adding local media stream by track');
                        this._localStream.getTracks().forEach(function (track) {
                            _this._peerConnection.addTrack(track, _this._localStream);
                        });
                    }
                    catch (e) {
                        this.log("error: ".concat(e), 'error');
                    }
                }
            }
            // Add an audio and video transceiver that are send and receive,
            // regardless of whether the user microphone / camera is currently
            // available.
            this._peerConnection.addTransceiver('audio', { direction: 'sendrecv' });
            this._peerConnection.addTransceiver('video', { direction: 'sendrecv' });
            // create updateOffer if resumeSessionId exists
            if (body.resumeSessionId) {
                var offerOptions = {
                    voiceActivityDetection: false,
                    iceRestart: true,
                };
                this._sessionId = body.resumeSessionId;
                this._isResumedSession = true;
                this.log("established, trying to resume session with session_id = ".concat(body.resumeSessionId));
                this.createOffer(this._peerConnection, offerOptions)
                    .then(function (sessionDescription) {
                    _this.createdDescription.bind(_this);
                    _this.createdDescription(sessionDescription, 'updateOffer');
                })
                    .catch(this._sessionError.bind(this));
            }
            else {
                // Create a webrtc offer
                var offerOptions = {
                    voiceActivityDetection: false,
                    iceRestart: false,
                };
                this._isResumedSession = false;
                this.createOffer(this._peerConnection, offerOptions)
                    .then(this.createdDescription.bind(this))
                    .catch(this._sessionError.bind(this));
            }
        }
        else if (name === 'accepted') {
            // accepted - DP is starting / forming webrtc connection
            this._connectionState.setConnectionState(ConnectionStateTypes.ConnectingToDigitalPerson);
            this.log("accepted, session_id = ".concat(body.sessionId));
            this._sessionId = body.sessionId;
            this._resumeRequested = body.resumeRequested;
            this._server = body.server;
            this._sceneId = body.sceneId;
            // The session has been accepted, send any outgoing queued messages
            for (var i = 0; i < this._outgoingQueue.length; i++) {
                this._outgoingQueue[i].body.sessionId = this._sessionId;
                this.sendMessage(this._outgoingQueue[i]);
            }
            this._outgoingQueue = [];
            // Monitor for orientation change events to update the camera rotation
            var callback = function () {
                if (_this) {
                    _this.sendCameraRotation();
                }
            };
            window.addEventListener('orientationchange', callback);
            this._removeListeners.push({
                target: window,
                name: 'orientationchange',
                callback: callback,
            });
            this.sendCameraRotation();
            var view = document.defaultView || window;
            var style = view.getComputedStyle(this._videoElement);
            var video_width = parseInt("".concat(style.width), 10); // cs check changed frm this.videoElement
            var video_height = parseInt("".concat(style.height), 10);
            this.log("accepted, sending video width/height: ".concat(video_width, " / ").concat(video_height));
            this.sendVideoBounds(video_width, video_height);
            // Send all pending log messages
            this.sendlogMessage(this._pendingLog);
            this._pendingLog = [];
            // Check whether the the server needs us to route control messages to the
            // orchestration server.
            if (body.controlUrl) {
                this._controlUrl = body.controlUrl;
                this._controlQueue = [];
                this._controlOpen = false;
                this._controlConnection = new WebSocket(body.controlUrl + '?access_token=' + this._accessToken);
                this._controlConnection.onmessage = function (msg) {
                    var raw_text = msg.data;
                    if (raw_text) {
                        // forward this message to the session server
                        if (_this._serverConnection.readyState === WebSocket.OPEN) {
                            _this._serverConnection.send(raw_text);
                        }
                    }
                };
                this._controlConnection.onerror = function () {
                    _this.close(true, 'controlFailed', deferred);
                };
                // wait for the websocket to open, then continue with setup
                this._controlConnection.onopen = function (event) {
                    _this.log('control websocket open');
                    if (!_this._controlOpen) {
                        _this._controlOpen = true;
                        // send any pending orchestration/control messages in the order they were received
                        for (var i = 0; i < _this._controlQueue.length; i++) {
                            _this.log("control websocket now open, forwarding queued message: ".concat(_this._controlQueue[i]));
                            _this._controlConnection.send(_this._controlQueue[i]);
                        }
                        _this._controlQueue = [];
                    }
                };
                // setup a close handler
                this._controlConnection.onclose = function (event) {
                    _this.log("control closed: code(".concat(event.code, "), reason(").concat(event.reason, "), clean(").concat(event.wasClean, ")"));
                    _this.close(true, 'controlDisconnected', deferred);
                };
            }
        }
        else if (name === 'answer') {
            this.log('set remote description');
            this.log(JSON.stringify(body));
            var sessionDescription = {
                sdp: body.sdp,
                type: 'answer',
            };
            this.setRemoteDescription(this._peerConnection, sessionDescription)
                .then(function () {
                // Currently there's nothing to do
            })
                .catch(this._sessionError.bind(this));
        }
        else if (name === 'connected') {
            if (this._remoteStream) {
                // connected - DP is started and ready the webrtc session has connected
                this._connectionState.setConnectionState(ConnectionStateTypes.Connected);
                this.onConnectedSuccess();
                if (deferred) {
                    deferred.resolve(body.sessionId);
                }
            }
            else {
                this.log('Connected but no remote media stream available');
                // The remote stream has not connected yet, give it more time to connect
                this._connectPendingRemoteStream = function () {
                    _this.onConnectedSuccess();
                    if (deferred) {
                        deferred.resolve(body.sessionId);
                    }
                };
            }
        }
        else if (name === 'ice') {
            this.log('add ice candidate');
            var addCandidate = void 0;
            if (body.complete) {
                if (this._features.isEdge) {
                    addCandidate = this._peerConnection.addIceCandidate(new RTCIceCandidate({
                        candidate: '',
                        sdpMid: '',
                        sdpMLineIndex: 0,
                    }));
                }
            }
            else {
                var iceCandidate = new RTCIceCandidate({
                    candidate: body.candidate,
                    sdpMid: body.sdpMid,
                    sdpMLineIndex: body.sdpMLineIndex,
                });
                addCandidate = this._peerConnection.addIceCandidate(iceCandidate);
            }
            if (addCandidate) {
                addCandidate.catch(this._sessionError.bind(this));
            }
        }
        else if (name === 'offer') {
            // NB: For calls inbound to browser, currently not used
            //     Perhaps we might use this for queueing to talk to an avatar?
            this._sessionId = body.sessionId;
            var sessionDescription = {
                sdp: body.sdp,
                type: 'offer',
            };
            this.setRemoteDescription(this._peerConnection, sessionDescription)
                // Create an answer in response to the offer
                .then(function () { return _this.createAnswer(_this._peerConnection); })
                .then(this.createdDescription.bind(this))
                .catch(this._sessionError.bind(this));
        }
        else if (name === 'userText') {
            this.log("rtc - user text message received: ".concat(body.userText));
            this._onUserText(body.userText);
        }
        else if (name === 'close') {
            this.close(false, body.reason, deferred);
        }
    };
    Session.prototype.gotIceCandidate = function (event) {
        if (event.candidate) {
            this.log('got local ice candidate');
            // Note we name each ice field as the IE/Safari plugin doesn't reflect these for json serialization
            this.sendRtcEvent('ice', {
                complete: false,
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex,
            });
        }
        else {
            this.log('end ice candidate');
            // all ice candidates have been gathered, send an end of ice notification
            this.sendRtcEvent('ice', {
                complete: true,
                candidate: '',
                sdpMid: '',
                sdpMLineIndex: 0,
            });
        }
    };
    Session.prototype.createdDescription = function (description, messageName) {
        var _this = this;
        if (messageName === void 0) { messageName = 'offer'; }
        this.log('got description');
        // Note we name each ice field as the IE/Safari plugin doesn't  reflect these for json serialization
        var descriptionObj = { sdp: description.sdp, type: description.type };
        this.log(JSON.stringify({ sdp: descriptionObj }));
        this.setLocalDescription(this._peerConnection, description)
            .then(function () {
            // Note with the sdp offer information we also send the
            // current video element width/height to remote end when
            // setting up webrtc session so that it can send the best
            // width/height
            _this.log('send sdp offer to server');
            // Note we name each sdp field as the IE/Safari plugin doesn't  reflect these for json serialization
            _this.sendRtcEvent(messageName, {
                sdp: _this._peerConnection.localDescription
                    ? _this._peerConnection.localDescription.sdp
                    : null,
                type: _this._peerConnection.localDescription
                    ? _this._peerConnection.localDescription.type
                    : null,
                user_text: _this._connectUserText,
                features: { videoStartedEvent: true },
            });
        })
            .catch(this._sessionError.bind(this));
    };
    Session.prototype.onRemoteStream = function (stream) {
        this.log('got remote stream');
        this._remoteStream = stream;
        this.log("ICE connection state: ".concat(this._peerConnection.iceConnectionState));
        if (this._connectPendingRemoteStream) {
            // A connect has been received however it has been paused while
            // we waited for the remote stream - continue it now
            this._connectPendingRemoteStream();
            this._connectPendingRemoteStream = null;
        }
    };
    Session.prototype.onConnectedSuccess = function () {
        var _this = this;
        var _a, _b;
        this._onConnected(this._resumeRequested, this._isResumedSession, this._server, this.sessionId);
        this._videoElement.hidden = false; // remote video stream
        this._videoElement.srcObject = this._remoteStream;
        var callback = function (event) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this._remoteStream) {
                    this._remoteStream.addTrack(event.track);
                }
                return [2 /*return*/];
            });
        }); };
        this._peerConnection.addEventListener('track', callback);
        this._removeListeners.push({
            target: this._peerConnection,
            name: 'track',
            callback: callback,
        });
        this.log('video enabled');
        // Update the server of the current camera active state
        this.sendUserCamera();
        // Update the application of the current microphone & camera state
        (_a = this._onMicrophoneActive) === null || _a === void 0 ? void 0 : _a.call(this.isMicrophoneActive());
        (_b = this._onCameraActive) === null || _b === void 0 ? void 0 : _b.call(this.isCameraActive());
    };
    Session.prototype.onVideoLoaded = function (e) {
        var _this = this;
        this.log('video has loaded');
        var videoStarted = function () {
            _this.log('video has started playing');
            _this.sendRtcEvent('videoStarted', {});
            _this.microphoneMuted = false; // allow the user to speak now that the DP is visible
        };
        // If the video element isn't muted the videoStarted event can be sent immediately
        if (!this._videoElement.muted) {
            videoStarted();
            return;
        }
        // The video element is muted, wait for it to be unmuted before declaring the video fully started
        // there isn't an event for unmuted however volumechange apparently provides a
        // fair alternative: https://stackoverflow.com/questions/25105414/html5-video-onmuted-and-onloop-event
        var unmuteCallback = function () {
            videoStarted();
            _this._videoElement.removeEventListener('volumechange', unmuteCallback);
        };
        this._videoElement.addEventListener('volumechange', unmuteCallback, false);
    };
    Session.prototype.sendRtcEvent = function (name, body) {
        if (this._serverConnection === null) {
            return;
        }
        if (this._sessionId) {
            body.sessionId = this._sessionId;
        }
        var payload = { category: 'webrtc', kind: 'event', name: name, body: body };
        if (this._sessionId || name === 'offer') {
            this.sendMessage(payload);
        }
        else {
            // The session has not yet been accepted, queue the message until it is
            this._outgoingQueue.push(payload);
        }
    };
    Session.prototype.sendVideoBounds = function (width, height) {
        this.sendRtcEvent('videoBounds', { width: width, height: height });
    };
    /**
     * Sends updated user camera rotation to server
     * this gives the app the chance to choose the required rotation of the user camera
     * such that it matches the devices orientation.  Values can be 0, 90, 180, 270.
     * @param rotation - The clockwise rotation in degrees of the user video feed (0, 90, 180 or 270)
     * @internal
     */
    Session.prototype.sendUserCamera = function (rotation) {
        var body = { active: this.isCameraActive() };
        if (rotation !== undefined) {
            body.rotation = rotation;
        }
        this.sendRtcEvent('userCamera', body);
    };
    Session.prototype.sendCameraRotation = function () {
        if (this._features.isIos) {
            var orientation = window.orientation;
            this.log("send updated camera rotation, device orientation: ".concat(orientation));
            // Compute the camera orientation for iOS, degrees to rotate the image to the right
            // to give it a correct orientation relative to how the iOS device is held
            var rotateCamera = 0;
            // NB: iOS safari fixedCameraOrientation = -90; - iOS front camera orientation in terms of window orientation positions
            if (orientation === 0) {
                rotateCamera = 90;
            }
            else if (orientation === 90) {
                rotateCamera = 180;
            }
            else if (orientation === 180) {
                rotateCamera = 270;
            }
            else if (orientation === -90) {
                rotateCamera = 0;
            }
            this.sendUserCamera(rotateCamera);
        }
    };
    Session.prototype.sendMessage = function (message) {
        if (!this._serverConnection) {
            return;
        }
        if (this._serverConnection.readyState === WebSocket.OPEN) {
            // connected
            this._serverConnection.send(JSON.stringify(message));
        }
        else {
            this.log("server connection not ready, discarding message: ".concat(message));
        }
    };
    Session.prototype.sendUserText = function (text) {
        this.sendRtcEvent('userText', { userText: text });
    };
    Session.prototype.hasCamera = function (userMedia) {
        return (userMedia === UserMedia.Camera ||
            userMedia === UserMedia.MicrophoneAndCamera);
    };
    Session.prototype.hasMicrophone = function (userMedia) {
        return (userMedia === UserMedia.Microphone ||
            userMedia === UserMedia.MicrophoneAndCamera);
    };
    Session.prototype.makeUserMedia = function (microphone, webcam) {
        if (microphone && webcam) {
            return UserMedia.MicrophoneAndCamera;
        }
        else if (microphone) {
            return UserMedia.Microphone;
        }
        else if (webcam) {
            return UserMedia.Camera;
        }
        return UserMedia.None;
    };
    Session.prototype.findSenderTrackByKind = function (kind) {
        var e_3, _a;
        var _b;
        if (!this._peerConnection) {
            return null;
        }
        var senders = this._peerConnection.getSenders();
        try {
            for (var senders_1 = __values(senders), senders_1_1 = senders_1.next(); !senders_1_1.done; senders_1_1 = senders_1.next()) {
                var sender = senders_1_1.value;
                if (sender.track && ((_b = sender.track) === null || _b === void 0 ? void 0 : _b.kind) === kind) {
                    return sender.track;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (senders_1_1 && !senders_1_1.done && (_a = senders_1.return)) _a.call(senders_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return null;
    };
    Session.prototype.findSenderByKind = function (kind) {
        var e_4, _a, e_5, _b;
        var _c, _d;
        if (!this._peerConnection) {
            return null;
        }
        try {
            for (var _e = __values(this._peerConnection.getTransceivers()), _f = _e.next(); !_f.done; _f = _e.next()) {
                var transceiver = _f.value;
                if (transceiver.direction === 'sendrecv' &&
                    ((_d = (_c = transceiver.receiver) === null || _c === void 0 ? void 0 : _c.track) === null || _d === void 0 ? void 0 : _d.kind) === kind) {
                    return transceiver.sender;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_4) throw e_4.error; }
        }
        try {
            for (var _g = __values(this._peerConnection.getSenders()), _h = _g.next(); !_h.done; _h = _g.next()) {
                var sender = _h.value;
                if (sender.track === null || sender.track.kind === kind) {
                    return sender;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return null;
    };
    Session.prototype.processChangeUserMediaQueue = function () {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var operation, lastMicrophoneActive, lastCameraActive, e_6;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        operation =
                            this._changeUserMediaQueue.length > 0
                                ? this._changeUserMediaQueue[0]
                                : undefined;
                        if (!operation) return [3 /*break*/, 5];
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 3, , 4]);
                        lastMicrophoneActive = this.isMicrophoneActive();
                        lastCameraActive = this.isCameraActive();
                        // Change the media to that requested by the operation
                        return [4 /*yield*/, this.changeUserMediaInternal(this.makeUserMedia((_a = operation.microphone) !== null && _a !== void 0 ? _a : lastMicrophoneActive, (_b = operation.camera) !== null && _b !== void 0 ? _b : lastCameraActive))];
                    case 2:
                        // Change the media to that requested by the operation
                        _e.sent();
                        // Notify of any change of microphone state
                        if (operation.microphone !== undefined &&
                            operation.microphone !== lastMicrophoneActive) {
                            (_c = this._onMicrophoneActive) === null || _c === void 0 ? void 0 : _c.call(this.isMicrophoneActive());
                        }
                        // Notify of any change of camera state
                        if (operation.camera !== undefined &&
                            operation.camera !== lastCameraActive) {
                            (_d = this._onCameraActive) === null || _d === void 0 ? void 0 : _d.call(this.isCameraActive());
                        }
                        // The operation has completed successfully
                        operation.deferred.resolve();
                        return [3 /*break*/, 4];
                    case 3:
                        e_6 = _e.sent();
                        operation.deferred.reject(e_6);
                        return [3 /*break*/, 4];
                    case 4:
                        // Remove the operation as it's now finished
                        this._changeUserMediaQueue.shift();
                        _e.label = 5;
                    case 5:
                        if (operation) return [3 /*break*/, 0];
                        _e.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    Session.prototype.changeUserMediaInternal = function (newUserMedia) {
        return __awaiter(this, void 0, Promise, function () {
            var microphoneTrack, cameraTrack, needMicrophoneUpgrade, needCameraUpgrade, newMediaStream, requiredMedia, mediaDeferred;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        microphoneTrack = this.findSenderTrackByKind('audio');
                        cameraTrack = this.findSenderTrackByKind('video');
                        needMicrophoneUpgrade = this.hasMicrophone(newUserMedia) &&
                            (!microphoneTrack || microphoneTrack.readyState === 'ended');
                        needCameraUpgrade = this.hasCamera(newUserMedia) &&
                            (!cameraTrack || cameraTrack.readyState === 'ended');
                        newMediaStream = null;
                        if (!(needMicrophoneUpgrade || needCameraUpgrade)) return [3 /*break*/, 2];
                        requiredMedia = this.makeUserMedia(needMicrophoneUpgrade, needCameraUpgrade);
                        mediaDeferred = new Deferred();
                        this.selectUserMedia(requiredMedia, requiredMedia, mediaDeferred, function (stream, deferred) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                newMediaStream = stream;
                                deferred.resolve();
                                return [2 /*return*/];
                            });
                        }); });
                        return [4 /*yield*/, mediaDeferred.promise];
                    case 1:
                        _a.sent();
                        if (!this._localStream) {
                            this._localStream = new MediaStream();
                        }
                        _a.label = 2;
                    case 2: 
                    // Update the microphone track
                    return [4 /*yield*/, this.updateSenderTrack('audio', this.hasMicrophone(newUserMedia), newMediaStream)];
                    case 3:
                        // Update the microphone track
                        _a.sent();
                        // Update the camera track
                        return [4 /*yield*/, this.updateSenderTrack('video', this.hasCamera(newUserMedia), newMediaStream)];
                    case 4:
                        // Update the camera track
                        _a.sent();
                        // Update the server of the current camera active state
                        this.sendUserCamera();
                        return [2 /*return*/];
                }
            });
        });
    };
    // Update the RTP sender / track to the given active state. If active then the newMediaStream must
    // contain a track for the requested 'kind'
    Session.prototype.updateSenderTrack = function (kind, active, newMediaStream) {
        var _a, _b;
        return __awaiter(this, void 0, Promise, function () {
            var sender, track, newTrack, e_7;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        sender = this.findSenderByKind(kind);
                        track = sender === null || sender === void 0 ? void 0 : sender.track;
                        if (!(!!sender && (!track || active !== track.enabled))) return [3 /*break*/, 7];
                        this.log('new user ' + kind + ' active state = ' + active);
                        if (!active) return [3 /*break*/, 6];
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 4, , 5]);
                        if (track) {
                            (_a = this._localStream) === null || _a === void 0 ? void 0 : _a.removeTrack(track);
                        }
                        if (!newMediaStream) return [3 /*break*/, 3];
                        newTrack = this.getTrackByKind(newMediaStream, kind);
                        if (!newTrack) return [3 /*break*/, 3];
                        (_b = this._localStream) === null || _b === void 0 ? void 0 : _b.addTrack(newTrack);
                        if (!(sender.track !== newTrack)) return [3 /*break*/, 3];
                        this.log('replacing user ' + kind + ' track');
                        return [4 /*yield*/, sender.replaceTrack(newTrack)];
                    case 2:
                        _c.sent();
                        _c.label = 3;
                    case 3: return [3 /*break*/, 5];
                    case 4:
                        e_7 = _c.sent();
                        this.log("failed to get user ".concat(kind, " track, error: ").concat(e_7), 'error');
                        throw makeError('failed to get user ' + kind + ': ' + e_7, 'failedUpgrade');
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        if (track) {
                            track.enabled = false;
                            track.stop();
                        }
                        _c.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    Session.prototype.getTrackByKind = function (stream, kind) {
        var e_8, _a;
        if (stream) {
            try {
                for (var _b = __values(stream.getTracks()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var track = _c.value;
                    if (track.kind === kind) {
                        return track;
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_8) throw e_8.error; }
            }
        }
        return undefined;
    };
    Session.prototype.isSenderTrackEnabled = function (kind) {
        var track = this.findSenderTrackByKind(kind);
        return Boolean(track === null || track === void 0 ? void 0 : track.enabled);
    };
    Session.prototype.isMicrophoneActive = function () {
        return this.isSenderTrackEnabled('audio');
    };
    Session.prototype.isCameraActive = function () {
        return this.isSenderTrackEnabled('video');
    };
    Session.prototype.setMediaDeviceActive = function (_a) {
        var microphone = _a.microphone, camera = _a.camera;
        return __awaiter(this, void 0, Promise, function () {
            var deferred;
            return __generator(this, function (_b) {
                deferred = new Deferred();
                this._changeUserMediaQueue.push({ microphone: microphone, camera: camera, deferred: deferred });
                if (this._changeUserMediaQueue.length === 1) {
                    this.processChangeUserMediaQueue();
                }
                return [2 /*return*/, deferred.promise];
            });
        });
    };
    Session.prototype.close = function (sendRtcClose, reason, deferred) {
        var e_9, _a;
        if (sendRtcClose === void 0) { sendRtcClose = true; }
        if (reason === void 0) { reason = 'normal'; }
        if (this._closed) {
            return;
        }
        this._closed = true;
        if (this._peerConnection) {
            try {
                this._peerConnection.close();
            }
            catch (e) {
                this.log("error: ".concat(e), 'error');
            }
        }
        if (this._localStream) {
            try {
                var tracks = this._localStream.getTracks();
                for (var i in tracks) {
                    tracks[i].stop();
                }
            }
            catch (e) {
                this.log("error: ".concat(e), 'error');
            }
        }
        if (sendRtcClose) {
            this.sendRtcEvent('close', { reason: 'normal' });
        }
        if (deferred) {
            if (deferred.isResolved()) {
                this._onClose(reason);
            }
            else {
                deferred.reject(makeError('websocket closed: ' + reason, reason));
            }
        }
        if (this._serverConnection) {
            this.log('closing server connection');
            this._serverConnection.close();
        }
        if (this._controlConnection) {
            this._controlConnection.close();
        }
        try {
            // Deregister event listeners
            for (var _b = __values(this._removeListeners), _c = _b.next(); !_c.done; _c = _b.next()) {
                var listener = _c.value;
                listener.target.removeEventListener(listener.name, listener.callback);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
    };
    Session.prototype.createOffer = function (peerConnection, options) {
        return peerConnection.createOffer(options);
    };
    Session.prototype.setRemoteDescription = function (peerConnection, sessionDescription) {
        return peerConnection.setRemoteDescription(sessionDescription);
    };
    Session.prototype.setLocalDescription = function (peerConnection, description) {
        return peerConnection.setLocalDescription(description);
    };
    Session.prototype.createAnswer = function (peerConnection) {
        return peerConnection.createAnswer();
    };
    Object.defineProperty(Session.prototype, "peerConnection", {
        get: function () {
            return this._peerConnection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "serverConnection", {
        get: function () {
            return this._serverConnection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "sessionId", {
        get: function () {
            return this._sessionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "server", {
        get: function () {
            return this._server;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "sceneId", {
        get: function () {
            return this._sceneId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "isMicrophoneConnected", {
        get: function () {
            return !!this.findSenderTrackByKind('audio');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "isCameraConnected", {
        get: function () {
            return !!this.findSenderTrackByKind('video');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "features", {
        get: function () {
            return this._features;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "microphoneMuteDelay", {
        get: function () {
            return this._microphoneMuteDelay;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "userMediaStream", {
        get: function () {
            return this._localStream;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "microphoneMuted", {
        get: function () {
            if (!this._localStream) {
                return true;
            }
            var audioTracks = this._localStream.getAudioTracks();
            if (!audioTracks || audioTracks.length < 1) {
                return true;
            }
            return !audioTracks[0].enabled;
        },
        set: function (mute) {
            var _a, _b;
            if (!this._localStream) {
                return;
            }
            var audioTracks = this._localStream.getAudioTracks();
            if (!audioTracks || audioTracks.length < 1) {
                return;
            }
            var audioSender = this.findSenderByKind('audio');
            if (((_a = audioSender === null || audioSender === void 0 ? void 0 : audioSender.track) === null || _a === void 0 ? void 0 : _a.readyState) === 'live' &&
                audioSender.track === audioTracks[0]) {
                var enable = !mute;
                audioTracks[0].enabled = enable;
                this.log("microphone muted active notification: ".concat(enable));
                (_b = this._onMicrophoneActive) === null || _b === void 0 ? void 0 : _b.call(enable);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "webcamMuted", {
        get: function () {
            if (!this._localStream) {
                return true;
            }
            var videoTracks = this._localStream.getVideoTracks();
            if (!videoTracks || videoTracks.length < 1) {
                return true;
            }
            return !videoTracks[0].enabled;
        },
        set: function (mute) {
            var _a, _b;
            if (!this._localStream) {
                return;
            }
            var videoTracks = this._localStream.getVideoTracks();
            if (!videoTracks || videoTracks.length < 1) {
                return;
            }
            var videoSender = this.findSenderByKind('video');
            if (((_a = videoSender === null || videoSender === void 0 ? void 0 : videoSender.track) === null || _a === void 0 ? void 0 : _a.readyState) === 'live' &&
                videoSender.track === videoTracks[0]) {
                var enable = !mute;
                videoTracks[0].enabled = enable;
                (_b = this._onCameraActive) === null || _b === void 0 ? void 0 : _b.call(enable);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "offsetX", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "offsetY", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "microphoneActiveCallbacks", {
        set: function (callbacks) {
            this._onMicrophoneActive = callbacks;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "cameraActiveCallbacks", {
        set: function (callbacks) {
            this._onCameraActive = callbacks;
        },
        enumerable: false,
        configurable: true
    });
    return Session;
}());


;// CONCATENATED MODULE: ./src/WebSocketSession.ts
/**
 * @module smwebsdk
 */

/*
 * Copyright 2020 Soul Machines Ltd. All Rights Reserved.
 */




/**
 *  WebSocketSession class
 */
var WebSocketSession = /** @class */ (function () {
    function WebSocketSession(serverUri, accessToken, logger) {
        if (logger === void 0) { logger = new Logger(); }
        var _this = this;
        this.logger = logger;
        this._outgoingQueue = [];
        this._onConnectedStorage = function (resumeRequested, isResumedSession, server, sessionId
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        ) { };
        this._pendingLog = [];
        this._closed = false;
        this._shouldLogToServer = false;
        this._serverUri = serverUri;
        this._accessToken = accessToken;
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onClose = function (reason) { }; // owner specifies custom close method
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._onMessage = function (message) { }; // owner specifies custom message handler
        this._sessionError = function (error) {
            // owner can specify custom session error handler
            _this.logger.log('error', "session error: ".concat(error));
        };
        this._features = new Features_Features();
    }
    Object.defineProperty(WebSocketSession.prototype, "onConnected", {
        set: function (sessionFunction) {
            this._onConnectedStorage = sessionFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "onClose", {
        set: function (closeFunction) {
            this._onClose = closeFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "onMessage", {
        set: function (messageFunction) {
            this._onMessage = messageFunction;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "loggingEnabled", {
        get: function () {
            return this.logger.isEnabled;
        },
        /**
         * @deprecated use setLogging(boolean).
         */
        set: function (enable) {
            this.logger.log('warn', 'loggingEnabled is deprecated and will be removed in a future version. Please use setLogging(boolean)');
            this.logger.enableLogging(enable);
        },
        enumerable: false,
        configurable: true
    });
    WebSocketSession.prototype.setMinLogLevel = function (level) {
        this.logger.setMinLogLevel(level);
    };
    WebSocketSession.prototype.setLogging = function (enable) {
        this.logger.enableLogging(enable);
    };
    WebSocketSession.prototype.log = function (text) {
        if (this.loggingEnabled) {
            if (this._shouldLogToServer) {
                this.logToServer(text);
            }
            else {
                this.logger.log('log', text);
            }
        }
    };
    WebSocketSession.prototype.logToServer = function (text) {
        if (this.sessionId) {
            this.sendlogMessage([text]);
        }
        else {
            this._pendingLog.push(text);
        }
    };
    WebSocketSession.prototype.sendlogMessage = function (textArray) {
        if (this._sessionId && textArray && textArray.length > 0) {
            var payload = {
                category: 'diagnostics',
                kind: 'event',
                name: 'log',
                body: { name: 'browser', text: textArray },
            };
            this.sendMessage(payload);
        }
    };
    WebSocketSession.prototype.connect = function () {
        return __awaiter(this, void 0, Promise, function () {
            var deferred;
            return __generator(this, function (_a) {
                deferred = new Deferred();
                this._closed = false;
                if (this._serverUri &&
                    (this._serverUri.startsWith('ws:') || this._serverUri.startsWith('wss:'))) {
                    // A server uri has been specified, continue with the connection
                    this.connectByWebSocket(deferred);
                }
                return [2 /*return*/, deferred.promise];
            });
        });
    };
    WebSocketSession.prototype.connectByWebSocket = function (deferred) {
        var _this = this;
        this.log("connecting to: ".concat(this._serverUri));
        if (!this._accessToken) {
            this._serverConnection = new WebSocket(this._serverUri);
        }
        else {
            this._serverConnection = new WebSocket(this._serverUri + '?access_token=' + this._accessToken);
        }
        this._serverConnection.onmessage = function (msg) {
            _this.gotMessageFromServer(msg, deferred);
        };
        this._serverConnection.onerror = function (event) {
            if (deferred.isPending()) {
                deferred.reject(makeError('websocket failed', 'serverConnectionFailed'));
            }
        };
        // wait for the websocket to open, then continue with setup
        this._serverConnection.onopen = function (event) {
            _this.log('websocket open');
            deferred.resolve();
        };
        // setup a close handler
        this._serverConnection.onclose = function (event) {
            _this.log("websocket closed: code(".concat(event.code, "), reason(").concat(event.reason, "), clean(").concat(event.wasClean, ")"));
            if (!deferred.isRejected) {
                _this.close(false, 'normal', deferred);
            }
        };
    };
    WebSocketSession.prototype.gotMessageFromServer = function (websocket_message, deferred) {
        var raw_text = websocket_message.data;
        this.log("message received: ".concat(raw_text));
        var message = JSON.parse(raw_text);
        var category = message.category;
        var name = message.name;
        var body = message.body;
        if (category !== 'webrtc') {
            // forward on non-webrtc messages (e.g. scene)
            this._onMessage(message);
            return;
        }
        if (message.kind !== 'event') {
            // currently ignore requests and responses
            return;
        }
        if (name === 'accepted') {
            this.log("accepted, session_id = ".concat(body.sessionId));
            this._sessionId = body.sessionId;
            // The session has been accepted, send any outgoing queued messages
            for (var i = 0; i < this._outgoingQueue.length; i++) {
                this._outgoingQueue[i].body.sessionId = this._sessionId;
                this.sendMessage(this._outgoingQueue[i]);
            }
            this._outgoingQueue = [];
            // Send all pending log messages
            this.sendlogMessage(this._pendingLog);
            this._pendingLog = [];
        }
        else if (name === 'close') {
            this.close(false, body.reason, deferred);
        }
    };
    WebSocketSession.prototype.sendMessage = function (message) {
        if (!this._serverConnection) {
            return;
        }
        if (this._serverConnection.readyState === WebSocket.OPEN) {
            // connected
            this._serverConnection.send(JSON.stringify(message));
        }
        else {
            this.log("not ready, discarding message: ".concat(message));
        }
    };
    WebSocketSession.prototype.close = function (sendRtcClose, reason, deferred) {
        if (sendRtcClose === void 0) { sendRtcClose = true; }
        if (reason === void 0) { reason = 'normal'; }
        if (this._closed) {
            return;
        }
        this._closed = true;
        if (deferred) {
            if (deferred.isResolved()) {
                this._onClose(reason);
            }
            else {
                deferred.reject(makeError('websocket closed: ' + reason, reason));
            }
        }
        if (this._serverConnection) {
            this.log('closing server connection');
            this._serverConnection.close();
        }
    };
    Object.defineProperty(WebSocketSession.prototype, "serverConnection", {
        get: function () {
            return this._serverConnection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "sessionId", {
        get: function () {
            return this._sessionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "peerConnection", {
        get: function () {
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "features", {
        get: function () {
            return this._features;
        },
        enumerable: false,
        configurable: true
    });
    WebSocketSession.prototype.sendRtcEvent = function (name, body) {
        // NOOP: Stuff for compatibility with Session in Scene
    };
    WebSocketSession.prototype.sendVideoBounds = function (widthIgnored, heightIgnored) {
        // NOOP: Stuff for compatibility with Session in Scene
    };
    WebSocketSession.prototype.sendUserText = function (text) {
        this.logger.log('error', 'WebSocketSession discarding text: ' + text);
    };
    Object.defineProperty(WebSocketSession.prototype, "microphoneMuteDelay", {
        get: function () {
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "microphoneMuted", {
        get: function () {
            return null;
        },
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        set: function (mute) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "onUserText", {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        set: function (userTextFunction) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "isMicrophoneConnected", {
        get: function () {
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "isCameraConnected", {
        get: function () {
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "offsetX", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebSocketSession.prototype, "offsetY", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    WebSocketSession.prototype.isMicrophoneActive = function () {
        return false;
    };
    WebSocketSession.prototype.isCameraActive = function () {
        return false;
    };
    WebSocketSession.prototype.setMediaDeviceActive = function (_a) {
        var microphone = _a.microphone, camera = _a.camera;
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_b) {
                throw makeError('setMediaDeviceActive not supported on WebSocketSession', 'notSupported');
            });
        });
    };
    return WebSocketSession;
}());


;// CONCATENATED MODULE: ./src/websocket-message/enums/WebsocketCategory.ts
var WebsocketCategory;
(function (WebsocketCategory) {
    WebsocketCategory["Scene"] = "scene";
})(WebsocketCategory || (WebsocketCategory = {}));

;// CONCATENATED MODULE: ./src/websocket-message/enums/WebsocketKind.ts
/**
 * @public
 */
var WebsocketKind;
(function (WebsocketKind) {
    WebsocketKind["Response"] = "response";
    WebsocketKind["Request"] = "request";
})(WebsocketKind || (WebsocketKind = {}));

;// CONCATENATED MODULE: ./src/websocket-message/index.ts





;// CONCATENATED MODULE: ./src/websocket-message/enums/SpeechState.ts
/*
 * Copyright 2019-2020 Soul Machines Ltd. All Rights Reserved.
 */
var SpeechState;
(function (SpeechState) {
    SpeechState["Idle"] = "idle";
    SpeechState["Animating"] = "animating";
    SpeechState["Speaking"] = "speaking";
})(SpeechState || (SpeechState = {}));

;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js

var hasActiveObservations = function () {
    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js

var hasSkippedObservations = function () {
    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function () {
    var event;
    if (typeof ErrorEvent === 'function') {
        event = new ErrorEvent('error', {
            message: msg
        });
    }
    else {
        event = document.createEvent('Event');
        event.initEvent('error', false, false);
        event.message = msg;
    }
    window.dispatchEvent(event);
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions) {
    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function (obj) { return Object.freeze(obj); };

;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js

var ResizeObserverSize = (function () {
    function ResizeObserverSize(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
    }
    return ResizeObserverSize;
}());


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js

var DOMRectReadOnly = (function () {
    function DOMRectReadOnly(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
    }
    DOMRectReadOnly.prototype.toJSON = function () {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };
    };
    DOMRectReadOnly.fromRect = function (rectangle) {
        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    };
    return DOMRectReadOnly;
}());


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };
var isHidden = function (target) {
    if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
    }
    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
    return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function (obj) {
    var _a;
    if (obj instanceof Element) {
        return true;
    }
    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
    return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function (target) {
    switch (target.tagName) {
        case 'INPUT':
            if (target.type !== 'image') {
                break;
            }
        case 'VIDEO':
        case 'AUDIO':
        case 'EMBED':
        case 'OBJECT':
        case 'CANVAS':
        case 'IFRAME':
        case 'IMG':
            return true;
    }
    return false;
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/utils/global.js
var global = typeof window !== 'undefined' ? window : {};

;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js






var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);
var parseDimension = function (pixel) { return parseFloat(pixel || '0'); };
var size = function (inlineSize, blockSize, switchSizes) {
    if (inlineSize === void 0) { inlineSize = 0; }
    if (blockSize === void 0) { blockSize = 0; }
    if (switchSizes === void 0) { switchSizes = false; }
    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
    devicePixelContentBoxSize: size(),
    borderBoxSize: size(),
    contentBoxSize: size(),
    contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function (target, forceRecalculation) {
    if (forceRecalculation === void 0) { forceRecalculation = false; }
    if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
    }
    if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
    }
    var cs = getComputedStyle(target);
    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
    var removePadding = !IE && cs.boxSizing === 'border-box';
    var switchSizes = verticalRegexp.test(cs.writingMode || '');
    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorderArea = borderLeft + borderRight;
    var verticalBorderArea = borderTop + borderBottom;
    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
    var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
    });
    cache.set(target, boxes);
    return boxes;
};
var calculateBoxSize = function (target, observedBox, forceRecalculation) {
    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
    switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
            return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
            return borderBoxSize;
        default:
            return contentBoxSize;
    }
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js


var ResizeObserverEntry = (function () {
    function ResizeObserverEntry(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
    }
    return ResizeObserverEntry;
}());


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js

var calculateDepthForNode = function (node) {
    if (isHidden(node)) {
        return Infinity;
    }
    var depth = 0;
    var parent = node.parentNode;
    while (parent) {
        depth += 1;
        parent = parent.parentNode;
    }
    return depth;
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js




var broadcastActiveObservations = function () {
    var shallowestDepth = Infinity;
    var callbacks = [];
    resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
            return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
            var entry = new ResizeObserverEntry(ot.target);
            var targetDepth = calculateDepthForNode(ot.target);
            entries.push(entry);
            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
            if (targetDepth < shallowestDepth) {
                shallowestDepth = targetDepth;
            }
        });
        callbacks.push(function resizeObserverCallback() {
            ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
    });
    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
    }
    return shallowestDepth;
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js


var gatherActiveObservationsAtDepth = function (depth) {
    resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
            if (ot.isActive()) {
                if (calculateDepthForNode(ot.target) > depth) {
                    ro.activeTargets.push(ot);
                }
                else {
                    ro.skippedTargets.push(ot);
                }
            }
        });
    });
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/utils/process.js





var process_process = function () {
    var depth = 0;
    gatherActiveObservationsAtDepth(depth);
    while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
    }
    if (hasSkippedObservations()) {
        deliverResizeLoopError();
    }
    return depth > 0;
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };
var queueMicroTask = function (callback) {
    if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode('');
        var config = { characterData: true };
        new MutationObserver(function () { return notify(); }).observe(el_1, config);
        trigger = function () { el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++); };
    }
    callbacks.push(callback);
    trigger();
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js

var queueResizeObserver = function (cb) {
    queueMicroTask(function ResizeObserver() {
        requestAnimationFrame(cb);
    });
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/utils/scheduler.js



var watching = 0;
var isWatching = function () { return !!watching; };
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
    'resize',
    'load',
    'transitionend',
    'animationend',
    'animationstart',
    'animationiteration',
    'keyup',
    'keydown',
    'mouseup',
    'mousedown',
    'mouseover',
    'mouseout',
    'blur',
    'focus'
];
var time = function (timeout) {
    if (timeout === void 0) { timeout = 0; }
    return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = (function () {
    function Scheduler() {
        var _this = this;
        this.stopped = true;
        this.listener = function () { return _this.schedule(); };
    }
    Scheduler.prototype.run = function (timeout) {
        var _this = this;
        if (timeout === void 0) { timeout = CATCH_PERIOD; }
        if (scheduled) {
            return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function () {
            var elementsHaveResized = false;
            try {
                elementsHaveResized = process_process();
            }
            finally {
                scheduled = false;
                timeout = until - time();
                if (!isWatching()) {
                    return;
                }
                if (elementsHaveResized) {
                    _this.run(1000);
                }
                else if (timeout > 0) {
                    _this.run(timeout);
                }
                else {
                    _this.start();
                }
            }
        });
    };
    Scheduler.prototype.schedule = function () {
        this.stop();
        this.run();
    };
    Scheduler.prototype.observe = function () {
        var _this = this;
        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };
        document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);
    };
    Scheduler.prototype.start = function () {
        var _this = this;
        if (this.stopped) {
            this.stopped = false;
            this.observer = new MutationObserver(this.listener);
            this.observe();
            events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });
        }
    };
    Scheduler.prototype.stop = function () {
        var _this = this;
        if (!this.stopped) {
            this.observer && this.observer.disconnect();
            events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });
            this.stopped = true;
        }
    };
    return Scheduler;
}());
var scheduler = new Scheduler();
var updateCount = function (n) {
    !watching && n > 0 && scheduler.start();
    watching += n;
    !watching && scheduler.stop();
};


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/ResizeObservation.js



var skipNotifyOnElement = function (target) {
    return !isSVG(target)
        && !isReplacedElement(target)
        && getComputedStyle(target).display === 'inline';
};
var ResizeObservation = (function () {
    function ResizeObservation(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
            inlineSize: 0,
            blockSize: 0
        };
    }
    ResizeObservation.prototype.isActive = function () {
        var size = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
            this.lastReportedSize = size;
        }
        if (this.lastReportedSize.inlineSize !== size.inlineSize
            || this.lastReportedSize.blockSize !== size.blockSize) {
            return true;
        }
        return false;
    };
    return ResizeObservation;
}());


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = (function () {
    function ResizeObserverDetail(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
    }
    return ResizeObserverDetail;
}());


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js




var observerMap = new WeakMap();
var getObservationIndex = function (observationTargets, target) {
    for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
            return i;
        }
    }
    return -1;
};
var ResizeObserverController = (function () {
    function ResizeObserverController() {
    }
    ResizeObserverController.connect = function (resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
    };
    ResizeObserverController.observe = function (resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
            firstObservation && resizeObservers.push(detail);
            detail.observationTargets.push(new ResizeObservation(target, options && options.box));
            updateCount(1);
            scheduler.schedule();
        }
    };
    ResizeObserverController.unobserve = function (resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
            detail.observationTargets.splice(index, 1);
            updateCount(-1);
        }
    };
    ResizeObserverController.disconnect = function (resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });
        detail.activeTargets.splice(0, detail.activeTargets.length);
    };
    return ResizeObserverController;
}());


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/ResizeObserver.js


var ResizeObserver = (function () {
    function ResizeObserver(callback) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== 'function') {
            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
    }
    ResizeObserver.prototype.observe = function (target, options) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
    };
    ResizeObserver.prototype.unobserve = function (target) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
    };
    ResizeObserver.prototype.disconnect = function () {
        ResizeObserverController.disconnect(this);
    };
    ResizeObserver.toString = function () {
        return 'function ResizeObserver () { [polyfill code] }';
    };
    return ResizeObserver;
}());


;// CONCATENATED MODULE: ./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js




;// CONCATENATED MODULE: ./src/utils/allImagesLoaded.ts
var allImagesLoaded = function () {
    return Promise.all(Array.from(document.images)
        .filter(function (img) { return !img.complete; })
        .map(function (img) {
        return new Promise(function (resolve) {
            img.onload = resolve;
            img.onerror = resolve;
        });
    }));
};
/* harmony default export */ const utils_allImagesLoaded = (allImagesLoaded);

;// CONCATENATED MODULE: ./src/utils/debounce.ts
var debouncedFunction = function (fn, debounceTimeMs) {
    if (debounceTimeMs === void 0) { debounceTimeMs = 500; }
    var debounceTimerId = -1;
    return function () {
        if (debounceTimerId) {
            clearTimeout(debounceTimerId);
        }
        debounceTimerId = setTimeout(function () { return fn(); }, debounceTimeMs);
    };
};

;// CONCATENATED MODULE: ./src/ContentAwareness.ts
/*
 * Copyright 2021 Soul Machines Ltd. All Rights Reserved.
 */




/**
 * ContentAwareness class
 *
 * An instance of this class is used to enable CUE behaviors in the digital human.
 * This is achived by measuring tagged HTML elements and sending their coordinates back to the server
 *
 * See documentation on GitHub for further reference on how to use this API
 * https://github.com/soulmachines/smwebsdk/blob/cue-content-awareness-api/guide/content-awareness.md
 *
 * @public
 */
var ContentAwareness = /** @class */ (function () {
    function ContentAwareness(scene, debounceTime, logger) {
        if (debounceTime === void 0) { debounceTime = 300; }
        if (logger === void 0) { logger = new Logger(); }
        var _this = this;
        this.scene = scene;
        this.debounceTime = debounceTime;
        this.logger = logger;
        // Data Attribute Strings
        this.VIDEO_FRAME_STR = 'data-sm-video';
        this.VIDEO_FRAME_STR_BRACKETED = "[".concat(this.VIDEO_FRAME_STR, "]");
        this.CONTENT_STR = 'data-sm-content';
        this.CONTENT_STR_BRACKETED = "[".concat(this.CONTENT_STR, "]");
        this.CUE_ATTRIBUTES = [this.VIDEO_FRAME_STR, this.CONTENT_STR];
        this.CUE_ATTRIBUTES_BRACKETED = [
            this.VIDEO_FRAME_STR_BRACKETED,
            this.CONTENT_STR_BRACKETED,
        ].join();
        this.RESIZE_OBSERVER_BOX_OPTIONS = 'border-box';
        this.callMeasure = false;
        this.contentCollection = {};
        this.videoFrame = null;
        this.debouncedMeasure = debouncedFunction(function () { return _this.measureInternal(); }, debounceTime);
        this.resizeObserver = new ResizeObserver(function () { return _this.measureDebounced(); });
        this.getInitialElements();
        this.mutationObserver = new MutationObserver(function (mutations) {
            return _this.mutationCallback(mutations);
        });
        this.setupEventListeners();
        this.observeMutations();
        this.measureInternal();
    }
    /**
     * Check if the content awareness logging is enabled.
     *
     * @returns Returns true if the content awareness logging is enabled otherwise false.
     */
    ContentAwareness.prototype.isLoggingEnabled = function () {
        return this.logger.isEnabled;
    };
    /**
     * Enable/disable content awareness logging
     * @param enable - set true to enable content awareness log, false to disable
     */
    ContentAwareness.prototype.setLogging = function (enable) {
        this.logger.enableLogging(enable);
    };
    /**
     * Check minimal log level of content awareness.
     *
     * @returns Returns minimal log setting of content awareness, type is LogLevel.
     */
    ContentAwareness.prototype.getMinLogLevel = function () {
        return this.logger.getMinLogLevel();
    };
    /**
     * Set minimal log level of  content awareness logging.
     * @param level - use LogLevel type to set minimal log level of  content awareness logging
     */
    ContentAwareness.prototype.setMinLogLevel = function (level) {
        this.logger.setMinLogLevel(level);
    };
    ContentAwareness.prototype.setupEventListeners = function () {
        var _this = this;
        window.addEventListener('resize', function () { return _this.measureDebounced(); });
    };
    /**
     * Get initial elements, future elements will be added via mutation observer
     */
    ContentAwareness.prototype.getInitialElements = function () {
        var _this = this;
        var videoEl = document.querySelector(this.VIDEO_FRAME_STR_BRACKETED);
        var contentElements = document.querySelectorAll(this.CONTENT_STR_BRACKETED);
        this.trackVideoElement(videoEl);
        Array.from(contentElements).map(function (element) {
            return _this.trackContentElement(element);
        });
    };
    /**
     * Start watching for changes in the DOM that are relevant to
     * ContentAwareness object tracking.
     * @returns The ContentAwareness MutationObserver used for all content
     */
    ContentAwareness.prototype.observeMutations = function () {
        var watchNode = document.documentElement || document.body; // Target node of DOM to watch
        this.mutationObserver.observe(watchNode, {
            attributeFilter: this.CUE_ATTRIBUTES,
            attributeOldValue: true,
            childList: true,
            subtree: true, // Monitor elements in child directories
        });
    };
    /**
     * Publicly accessible function to disconnect observers and event listeners
     */
    ContentAwareness.prototype.disconnect = function () {
        var _this = this;
        // Disconnect observers
        this.mutationObserver.disconnect();
        this.resizeObserver.disconnect();
        // Remove event listeners
        window.removeEventListener('resize', function () { return _this.measureDebounced(); });
        // Reset scene
        this.scene.contentAwareness = undefined;
    };
    /**
     * Publicly accessible function to reconnect observers and event listeners
     */
    ContentAwareness.prototype.reconnect = function () {
        // Restore the link between scene and ca
        this.scene.contentAwareness = this;
        this.observeMutations();
        this.setupEventListeners();
        this.measure();
    };
    /**
     * Publicly accessible function to trigger measurement of CUE-relevant elements in the DOM
     * and send an updateContentAwareness message
     */
    ContentAwareness.prototype.measure = function () {
        this.measureInternal();
    };
    ContentAwareness.prototype.measureDebounced = function () {
        this.debouncedMeasure();
    };
    /**
     * measures data-sm-video and data-sm-content HTML Elements
     *
     * This is automatically called in simple scenarios but can be manually called
     * if the dev knows an important element has changed
     *
     * See documentation on GitHub for further reference on how to use this API
     * https://github.com/soulmachines/smwebsdk/blob/cue-content-awareness-api/guide/content-awareness.md
     *
     * Console logs the sent message on success or an error on failure
     */
    ContentAwareness.prototype.measureInternal = function () {
        if (!this.scene.isConnected()) {
            this.logger.log('error', 'ContentAwareness: Scene does not exist or is not connected yet');
            return;
        }
        var windowSize = this.measureWindow();
        var videoFrame = this.measureVideoFrame();
        var contentCollection = this.measureContent();
        if (windowSize && videoFrame && contentCollection) {
            var contentAwarenessMessage = this.buildUpdateContentAwarenessRequest(windowSize.innerWidth, windowSize.innerHeight, videoFrame, contentCollection);
            this.scene.sendRequest('updateContentAwareness', contentAwarenessMessage);
        }
    };
    /**
     * measure elements tagged with data-videoFrame
     * @returns a ContentAwarenessObjectModel filled with
     * videoFrame coordinates on success. returns null on failure
     */
    ContentAwareness.prototype.measureVideoFrame = function () {
        if (!this.videoFrame) {
            this.logger.log('warn', 'ContentAwareness: Unable to find a video element');
            return null;
        }
        var videoRect = this.videoFrame.getBoundingClientRect();
        if (this.invalidDimensions(videoRect)) {
            this.logger.log('warn', 'ContentAwareness: Video has a zero width and height');
            return null;
        }
        return {
            x1: Math.round(videoRect.left),
            x2: Math.round(videoRect.right),
            y1: Math.round(videoRect.top),
            y2: Math.round(videoRect.bottom),
        };
    };
    /**
     * measure elements tagged with data-content
     * @returns a ContentAwarenessObjectModel array filled with the coordinates and
     * ids of content tagged with the data-sm-content attribute
     */
    ContentAwareness.prototype.measureContent = function () {
        var _this = this;
        var validContent = [];
        Object.keys(this.contentCollection).map(function (key) {
            var contentElement = _this.contentCollection[key];
            var contentRect = contentElement.getBoundingClientRect();
            if (_this.invalidDimensions(contentRect)) {
                _this.logger.log('warn', "ContentAwareness: Element '".concat(key, "' has a zero width and height"));
            }
            if (_this.invalidContent(contentRect)) {
                _this.logger.log('warn', "ContentAwareness: Element '".concat(key, "' is not being tracked"));
                // Remove id from content collection but keep observers incase it changes
                delete _this.contentCollection[key];
                return;
            }
            validContent.push({
                id: key,
                x1: Math.round(contentRect.left),
                x2: Math.round(contentRect.right),
                y1: Math.round(contentRect.top),
                y2: Math.round(contentRect.bottom),
            });
        });
        return validContent;
    };
    /**
     * Preliminary indication of if content dimensions are valid or not.
     * Checks if the length and height are zero
     * @param contentRect - the DOMRect to check
     * @returns a bool indicating validity
     */
    ContentAwareness.prototype.invalidDimensions = function (contentRect) {
        return contentRect.width === 0 && contentRect.height === 0;
    };
    /**
     * Preliminary indication of if content is valid or not.
     * Checks if the coordinates are non zero
     * @param contentRect - the DOMRect to check
     * @returns a bool indicating validity
     */
    ContentAwareness.prototype.invalidContent = function (contentRect) {
        return (contentRect.top === 0 &&
            contentRect.bottom === 0 &&
            contentRect.right === 0 &&
            contentRect.left === 0);
    };
    /**
     * measure the browser window
     * @returns an object containing the window height (innerHeight) and window width (innerWidth)
     */
    ContentAwareness.prototype.measureWindow = function () {
        return {
            innerHeight: Math.round(window.innerHeight),
            innerWidth: Math.round(window.innerWidth),
        };
    };
    /**
     * Builds the required UpdateContentAwareness message that gets sent to the server
     *
     * @param viewWidth - the width of the browser window
     * @param viewHeight - the height of the browser window
     * @param videoFrame - an object containing the coordinates of the video element in which the persona exists
     * @param content - an array of objects containing the coordinates of the content elements the persona should be aware of
     * @returns - UpdateContentAwarenessRequestBody the message body to send
     *
     * The return value from this function should be passed to
     * scene.sendRequest('updateContentAwareness', body)
     */
    ContentAwareness.prototype.buildUpdateContentAwarenessRequest = function (viewWidth, viewHeight, videoFrame, content) {
        return {
            viewWidth: viewWidth,
            viewHeight: viewHeight,
            videoFrame: videoFrame,
            content: content,
        };
    };
    ContentAwareness.prototype.trackVideoElement = function (element) {
        if (!element) {
            return;
        }
        if (this.videoFrame) {
            this.logger.log('warn', 'ContentAwareness: Already observing a video element, switching to new video element');
            this.untrackVideoElement(this.videoFrame);
        }
        this.videoFrame = element;
        this.resizeObserver.observe(this.videoFrame, {
            box: this.RESIZE_OBSERVER_BOX_OPTIONS,
        });
    };
    ContentAwareness.prototype.trackContentElement = function (element) {
        var id = element.getAttribute(this.CONTENT_STR);
        if (id) {
            this.contentCollection[id] = element;
            this.resizeObserver.observe(element, {
                box: this.RESIZE_OBSERVER_BOX_OPTIONS,
            });
            return true;
        }
        return false;
    };
    ContentAwareness.prototype.untrackContentElement = function (element) {
        var id = element.getAttribute(this.CONTENT_STR);
        var trackedElement = this.contentCollection[id];
        // only untrack the element if the element we have stored
        // against that id is the same one being requested for removal.
        // this allows for showing/hiding of elements that use the same id.
        if (element === trackedElement) {
            delete this.contentCollection[id];
            this.resizeObserver.unobserve(element);
        }
    };
    ContentAwareness.prototype.untrackVideoElement = function (element) {
        // Only clear the videoFrame element if its the same as the currently track video element.
        // A mismatch can occur when adding/removing different video elements. If a new video element appears we'll switch and track that.
        // If the remove event occurs after the switch we'll ignore it, as we don't want to untrack the newly added element
        if (element === this.videoFrame) {
            this.videoFrame = null;
        }
        // Always unobserve the removed element
        this.resizeObserver.unobserve(element);
    };
    /**
     * Takes an array of MutationRecords and measures the ones marked with content awareness attributes
     * @param mutations - an array of MutationRecords to check and measure
     */
    ContentAwareness.prototype.mutationCallback = function (mutations) {
        var _this = this;
        var imagesAdded = false;
        this.callMeasure = false; // reset callMeasure
        for (var i = 0; i < mutations.length; ++i) {
            switch (mutations[i].type) {
                case 'childList': {
                    if (mutations[i].target.nodeType !== Node.ELEMENT_NODE) {
                        break;
                    }
                    this.untrackRemovedNodeWithCUE(mutations[i].removedNodes); // Unobserve and stop tracking removed elements
                    this.trackAddedNodeWithCUE(mutations[i].addedNodes); // Start tracking elements added elements
                    for (var j = 0; j < mutations[i].addedNodes.length; j++) {
                        try {
                            var element = mutations[i].addedNodes[j];
                            if (!element.hasAttribute) {
                                // node is not an element, do not continue processing it
                                continue;
                            }
                            var isImage = element.tagName === 'IMG';
                            var containsImages = !!element.querySelector('img');
                            imagesAdded = isImage || containsImages;
                            if (imagesAdded) {
                                break;
                            }
                        }
                        catch (err) {
                            this.logger.log('warn', 'ContentAwareness: Failed to track non-element node', mutations[i].addedNodes[j]);
                        }
                    }
                    break;
                }
                case 'attributes': {
                    if (mutations[i].target.nodeType !== Node.ELEMENT_NODE) {
                        break;
                    }
                    try {
                        var element = mutations[i].target;
                        var attr = mutations[i].attributeName;
                        if (attr === this.VIDEO_FRAME_STR) {
                            if (element.hasAttribute(attr)) {
                                this.trackVideoElement(element);
                                this.callMeasure = true;
                            }
                            else if (this.videoFrame) {
                                this.untrackVideoElement(element);
                            }
                        }
                        else if (attr === this.CONTENT_STR) {
                            var newValue = element.getAttribute(attr);
                            var oldValue = mutations[i].oldValue;
                            if (oldValue) {
                                // data-sm-content attribute was changed and must be removed
                                this.resizeObserver.unobserve(this.contentCollection[oldValue]);
                                delete this.contentCollection[oldValue];
                            }
                            if (newValue) {
                                // data-sm-content attribute value was changed/added and now must be added to the list
                                this.contentCollection[newValue] = element;
                                this.resizeObserver.observe(element, {
                                    box: this.RESIZE_OBSERVER_BOX_OPTIONS,
                                });
                            }
                            this.callMeasure = true;
                        }
                        break;
                    }
                    catch (err) {
                        this.logger.log('warn', 'ContentAwareness: Failed to track non-element node', mutations[i].target);
                    }
                }
            }
        }
        if (this.callMeasure) {
            if (imagesAdded) {
                // Wait for all images to be loaded then remeasure
                utils_allImagesLoaded().then(function () {
                    _this.measureDebounced();
                });
            }
            else {
                this.measureDebounced();
            }
        }
    };
    ContentAwareness.prototype.trackAddedNodeWithCUE = function (mutations) {
        var _this = this;
        mutations.forEach(function (node) {
            try {
                var element = node;
                if (!element.hasAttribute) {
                    // node is not an element, do not continue processing it
                    return;
                }
                // check top level node for cue attributes
                if (element.hasAttribute(_this.VIDEO_FRAME_STR)) {
                    _this.trackVideoElement(element);
                    _this.callMeasure = true;
                }
                else if (element.hasAttribute(_this.CONTENT_STR)) {
                    _this.callMeasure = _this.trackContentElement(element);
                }
                // check child nodes for cue attributes
                if (element.querySelector(_this.CUE_ATTRIBUTES_BRACKETED) !== null) {
                    element
                        .querySelectorAll(_this.CUE_ATTRIBUTES_BRACKETED)
                        .forEach(function (childElement) {
                        if (childElement.hasAttribute(_this.VIDEO_FRAME_STR)) {
                            _this.trackVideoElement(childElement);
                            _this.callMeasure = true;
                        }
                        else if (childElement.hasAttribute(_this.CONTENT_STR)) {
                            _this.callMeasure = _this.trackContentElement(childElement);
                        }
                    });
                }
            }
            catch (err) {
                _this.logger.log('warn', 'ContentAwareness: Failed to track non-element node', node);
            }
        });
    };
    ContentAwareness.prototype.untrackRemovedNodeWithCUE = function (mutations) {
        var _this = this;
        mutations.forEach(function (node) {
            try {
                var element = node;
                if (!element.hasAttribute) {
                    // node is not an element, do not continue processing it
                    return;
                }
                if (element.hasAttribute(_this.VIDEO_FRAME_STR)) {
                    _this.untrackVideoElement(element);
                }
                else if (element.hasAttribute(_this.CONTENT_STR)) {
                    _this.untrackContentElement(element);
                    _this.callMeasure = true;
                }
                // check child nodes for cue attributes
                if (element.querySelector(_this.CUE_ATTRIBUTES_BRACKETED) !== null) {
                    element
                        .querySelectorAll(_this.CUE_ATTRIBUTES_BRACKETED)
                        .forEach(function (childElement) {
                        if (childElement.hasAttribute(_this.VIDEO_FRAME_STR)) {
                            _this.untrackVideoElement(childElement);
                        }
                        else if (childElement.hasAttribute(_this.CONTENT_STR)) {
                            _this.untrackContentElement(childElement);
                            _this.callMeasure = true;
                        }
                    });
                }
            }
            catch (err) {
                _this.logger.log('warn', 'ContentAwareness: Failed to track non-element node', node);
            }
        });
    };
    return ContentAwareness;
}());


;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/platform/browser/globalThis.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api-metrics and
// @opentelemetry/core too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var globalThis_globalThis = typeof globalThis === 'object' ? globalThis :
    typeof self === 'object' ? self :
        typeof window === 'object' ? window :
            typeof __webpack_require__.g === 'object' ? __webpack_require__.g :
                {};
//# sourceMappingURL=globalThis.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/platform/browser/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/version.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var VERSION = '1.2.0';
//# sourceMappingURL=version.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/internal/semver.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
/**
 * Create a function to test an API version to see if it is compatible with the provided ownVersion.
 *
 * The returned function has the following semantics:
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param ownVersion version which should be checked against
 */
function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = new Set([ownVersion]);
    var rejectedVersions = new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
        // we cannot guarantee compatibility so we always return noop
        return function () { return false; };
    }
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4],
    };
    // if ownVersion has a prerelease tag, versions must match exactly
    if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
            return globalVersion === ownVersion;
        };
    }
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
            return true;
        }
        if (rejectedVersions.has(globalVersion)) {
            return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
            // cannot parse other version
            // we cannot guarantee compatibility so we always noop
            return _reject(globalVersion);
        }
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4],
        };
        // if globalVersion has a prerelease tag, versions must match exactly
        if (globalVersionParsed.prerelease != null) {
            return _reject(globalVersion);
        }
        // major versions must match
        if (ownVersionParsed.major !== globalVersionParsed.major) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor &&
                ownVersionParsed.patch <= globalVersionParsed.patch) {
                return _accept(globalVersion);
            }
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
            return _accept(globalVersion);
        }
        return _reject(globalVersion);
    };
}
/**
 * Test an API version to see if it is compatible with this API.
 *
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param version version of the API requesting an instance of the global API
 */
var isCompatible = _makeCompatibilityCheck(VERSION);
//# sourceMappingURL=semver.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var major = VERSION.split('.')[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = globalThis_globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
    var _a;
    if (allowOverride === void 0) { allowOverride = false; }
    var api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: VERSION,
    });
    if (!allowOverride && api[type]) {
        // already registered an API of this type
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== VERSION) {
        // All registered APIs must be of the same version exactly
        var err = new Error('@opentelemetry/api: All API registration versions must match');
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
    return true;
}
function getGlobal(type) {
    var _a, _b;
    var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
    if (!globalVersion || !isCompatible(globalVersion)) {
        return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
        delete api[type];
    }
}
//# sourceMappingURL=global-utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Component Logger which is meant to be used as part of any component which
 * will add automatically additional namespace in front of the log message.
 * It will then forward all message to global diag logger
 * @example
 * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
 * cLogger.debug('test');
 * // @opentelemetry/instrumentation-http test
 */
var DiagComponentLogger = /** @class */ (function () {
    function DiagComponentLogger(props) {
        this._namespace = props.namespace || 'DiagComponentLogger';
    }
    DiagComponentLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('debug', this._namespace, args);
    };
    DiagComponentLogger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('error', this._namespace, args);
    };
    DiagComponentLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('info', this._namespace, args);
    };
    DiagComponentLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('warn', this._namespace, args);
    };
    DiagComponentLogger.prototype.verbose = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('verbose', this._namespace, args);
    };
    return DiagComponentLogger;
}());

function logProxy(funcName, namespace, args) {
    var logger = getGlobal('diag');
    // shortcut if logger not set
    if (!logger) {
        return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, args);
}
//# sourceMappingURL=ComponentLogger.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/diag/types.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Defines the available internal logging levels for the diagnostic logger, the numeric values
 * of the levels are defined to match the original values from the initial LogLevel to avoid
 * compatibility/migration issues for any implementation that assume the numeric ordering.
 */
var DiagLogLevel;
(function (DiagLogLevel) {
    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
    DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
    /** Identifies an error scenario */
    DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
    /** Identifies a warning scenario */
    DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
    /** General informational log message */
    DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
    /** General debug log message */
    DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
    /**
     * Detailed trace level logging should only be used for development, should only be set
     * in a development environment.
     */
    DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
    /** Used to set the logging level to include all logging */
    DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
    }
    else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
    }
    // In case the logger is null or undefined
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === 'function' && maxLevel >= theLevel) {
            return theFunc.bind(logger);
        }
        return function () { };
    }
    return {
        error: _filterFunc('error', DiagLogLevel.ERROR),
        warn: _filterFunc('warn', DiagLogLevel.WARN),
        info: _filterFunc('info', DiagLogLevel.INFO),
        debug: _filterFunc('debug', DiagLogLevel.DEBUG),
        verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),
    };
}
//# sourceMappingURL=logLevelLogger.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/api/diag.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var API_NAME = 'diag';
/**
 * Singleton object which represents the entry point to the OpenTelemetry internal
 * diagnostic API
 */
var DiagAPI = /** @class */ (function () {
    /**
     * Private internal constructor
     * @private
     */
    function DiagAPI() {
        function _logProxy(funcName) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var logger = getGlobal('diag');
                // shortcut if logger not set
                if (!logger)
                    return;
                return logger[funcName].apply(logger, args);
            };
        }
        // Using self local variable for minification purposes as 'this' cannot be minified
        var self = this;
        // DiagAPI specific functions
        self.setLogger = function (logger, logLevel) {
            var _a, _b;
            if (logLevel === void 0) { logLevel = DiagLogLevel.INFO; }
            if (logger === self) {
                // There isn't much we can do here.
                // Logging to the console might break the user application.
                // Try to log to self. If a logger was previously registered it will receive the log.
                var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
                return false;
            }
            var oldLogger = getGlobal('diag');
            var newLogger = createLogLevelDiagLogger(logLevel, logger);
            // There already is an logger registered. We'll let it know before overwriting it.
            if (oldLogger) {
                var stack = (_b = new Error().stack) !== null && _b !== void 0 ? _b : '<failed to generate stacktrace>';
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal('diag', newLogger, self, true);
        };
        self.disable = function () {
            unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function (options) {
            return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy('verbose');
        self.debug = _logProxy('debug');
        self.info = _logProxy('info');
        self.warn = _logProxy('warn');
        self.error = _logProxy('error');
    }
    /** Get the singleton instance of the DiagAPI API */
    DiagAPI.instance = function () {
        if (!this._instance) {
            this._instance = new DiagAPI();
        }
        return this._instance;
    };
    return DiagAPI;
}());

//# sourceMappingURL=diag.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BaggageImpl = /** @class */ (function () {
    function BaggageImpl(entries) {
        this._entries = entries ? new Map(entries) : new Map();
    }
    BaggageImpl.prototype.getEntry = function (key) {
        var entry = this._entries.get(key);
        if (!entry) {
            return undefined;
        }
        return Object.assign({}, entry);
    };
    BaggageImpl.prototype.getAllEntries = function () {
        return Array.from(this._entries.entries()).map(function (_a) {
            var k = _a[0], v = _a[1];
            return [k, v];
        });
    };
    BaggageImpl.prototype.setEntry = function (key, entry) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntry = function (key) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntries = function () {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl(this._entries);
        for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {
            var key = keys_1[_a];
            newBaggage._entries.delete(key);
        }
        return newBaggage;
    };
    BaggageImpl.prototype.clear = function () {
        return new BaggageImpl();
    };
    return BaggageImpl;
}());

//# sourceMappingURL=baggage-impl.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Symbol used to make BaggageEntryMetadata an opaque type
 */
var baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');
//# sourceMappingURL=symbol.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/baggage/utils.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var utils_diag = DiagAPI.instance();
/**
 * Create a new Baggage with optional entries
 *
 * @param entries An array of baggage entries the new baggage should contain
 */
function createBaggage(entries) {
    if (entries === void 0) { entries = {}; }
    return new BaggageImpl(new Map(Object.entries(entries)));
}
/**
 * Create a serializable BaggageEntryMetadata object from a string.
 *
 * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
 *
 */
function baggageEntryMetadataFromString(str) {
    if (typeof str !== 'string') {
        utils_diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
        str = '';
    }
    return {
        __TYPE__: baggageEntryMetadataSymbol,
        toString: function () {
            return str;
        },
    };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var consoleMap = [
    { n: 'error', c: 'error' },
    { n: 'warn', c: 'warn' },
    { n: 'info', c: 'info' },
    { n: 'debug', c: 'debug' },
    { n: 'verbose', c: 'trace' },
];
/**
 * A simple Immutable Console based diagnostic logger which will output any messages to the Console.
 * If you want to limit the amount of logging to a specific level or lower use the
 * {@link createLogLevelDiagLogger}
 */
var DiagConsoleLogger = /** @class */ (function () {
    function DiagConsoleLogger() {
        function _consoleFunc(funcName) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (console) {
                    // Some environments only expose the console when the F12 developer console is open
                    // eslint-disable-next-line no-console
                    var theFunc = console[funcName];
                    if (typeof theFunc !== 'function') {
                        // Not all environments support all functions
                        // eslint-disable-next-line no-console
                        theFunc = console.log;
                    }
                    // One last final check
                    if (typeof theFunc === 'function') {
                        return theFunc.apply(console, args);
                    }
                }
            };
        }
        for (var i = 0; i < consoleMap.length; i++) {
            this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
    }
    return DiagConsoleLogger;
}());

//# sourceMappingURL=consoleLogger.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/diag/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var defaultTextMapGetter = {
    get: function (carrier, key) {
        if (carrier == null) {
            return undefined;
        }
        return carrier[key];
    },
    keys: function (carrier) {
        if (carrier == null) {
            return [];
        }
        return Object.keys(carrier);
    },
};
var defaultTextMapSetter = {
    set: function (carrier, key, value) {
        if (carrier == null) {
            return;
        }
        carrier[key] = value;
    },
};
//# sourceMappingURL=TextMapPropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/context/context.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Get a key to uniquely identify a context value */
function createContextKey(description) {
    // The specification states that for the same input, multiple calls should
    // return different keys. Due to the nature of the JS dependency management
    // system, this creates problems where multiple versions of some package
    // could hold different keys for the same property.
    //
    // Therefore, we use Symbol.for which returns the same key for the same input.
    return Symbol.for(description);
}
var BaseContext = /** @class */ (function () {
    /**
     * Construct a new context which inherits values from an optional parent context.
     *
     * @param parentContext a context from which to inherit values
     */
    function BaseContext(parentContext) {
        // for minification
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : new Map();
        self.getValue = function (key) { return self._currentContext.get(key); };
        self.setValue = function (key, value) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function (key) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext;
}());
/** The root context is used as the default parent context when there is no active context */
var ROOT_CONTEXT = new BaseContext();
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NoopContextManager_spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};

var NoopContextManager = /** @class */ (function () {
    function NoopContextManager() {
    }
    NoopContextManager.prototype.active = function () {
        return ROOT_CONTEXT;
    };
    NoopContextManager.prototype.with = function (_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, NoopContextManager_spreadArray([thisArg], args));
    };
    NoopContextManager.prototype.bind = function (_context, target) {
        return target;
    };
    NoopContextManager.prototype.enable = function () {
        return this;
    };
    NoopContextManager.prototype.disable = function () {
        return this;
    };
    return NoopContextManager;
}());

//# sourceMappingURL=NoopContextManager.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/api/context.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var context_spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};



var context_API_NAME = 'context';
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 */
var ContextAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function ContextAPI() {
    }
    /** Get the singleton instance of the Context API */
    ContextAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new ContextAPI();
        }
        return this._instance;
    };
    /**
     * Set the current context manager.
     *
     * @returns true if the context manager was successfully registered, else false
     */
    ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
        return registerGlobal(context_API_NAME, contextManager, DiagAPI.instance());
    };
    /**
     * Get the currently active context
     */
    ContextAPI.prototype.active = function () {
        return this._getContextManager().active();
    };
    /**
     * Execute a function with an active context
     *
     * @param context context to be active during function execution
     * @param fn function to execute in a context
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */
    ContextAPI.prototype.with = function (context, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, context_spreadArray([context, fn, thisArg], args));
    };
    /**
     * Bind a context to a target function or event emitter
     *
     * @param context context to bind to the event emitter or function. Defaults to the currently active context
     * @param target function or event emitter to bind
     */
    ContextAPI.prototype.bind = function (context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI.prototype._getContextManager = function () {
        return getGlobal(context_API_NAME) || NOOP_CONTEXT_MANAGER;
    };
    /** Disable and remove the global context manager */
    ContextAPI.prototype.disable = function () {
        this._getContextManager().disable();
        unregisterGlobal(context_API_NAME, DiagAPI.instance());
    };
    return ContextAPI;
}());

//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TraceFlags;
(function (TraceFlags) {
    /** Represents no flag set. */
    TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
    /** Bit to represent whether trace is sampled in trace flags. */
    TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));
//# sourceMappingURL=trace_flags.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var INVALID_SPANID = '0000000000000000';
var INVALID_TRACEID = '00000000000000000000000000000000';
var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: TraceFlags.NONE,
};
//# sourceMappingURL=invalid-span-constants.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The NonRecordingSpan is the default {@link Span} that is used when no Span
 * implementation is available. All operations are no-op including context
 * propagation.
 */
var NonRecordingSpan = /** @class */ (function () {
    function NonRecordingSpan(_spanContext) {
        if (_spanContext === void 0) { _spanContext = INVALID_SPAN_CONTEXT; }
        this._spanContext = _spanContext;
    }
    // Returns a SpanContext.
    NonRecordingSpan.prototype.spanContext = function () {
        return this._spanContext;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttribute = function (_key, _value) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttributes = function (_attributes) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.addEvent = function (_name, _attributes) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setStatus = function (_status) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.updateName = function (_name) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.end = function (_endTime) { };
    // isRecording always returns false for NonRecordingSpan.
    NonRecordingSpan.prototype.isRecording = function () {
        return false;
    };
    // By default does nothing
    NonRecordingSpan.prototype.recordException = function (_exception, _time) { };
    return NonRecordingSpan;
}());

//# sourceMappingURL=NonRecordingSpan.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * span key
 */
var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
/**
 * Return the span if one exists
 *
 * @param context context to get span from
 */
function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
}
/**
 * Gets the span from the current context, if one exists.
 */
function getActiveSpan() {
    return getSpan(ContextAPI.getInstance().active());
}
/**
 * Set the span on a context
 *
 * @param context context to use as parent
 * @param span span to set active
 */
function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
}
/**
 * Remove current span stored in the context
 *
 * @param context context to delete span from
 */
function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
}
/**
 * Wrap span context in a NoopSpan and set as span in a new
 * context
 *
 * @param context context to set active span on
 * @param spanContext span context to be wrapped
 */
function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan(spanContext));
}
/**
 * Get the span context of the span if it exists.
 *
 * @param context context to get values from
 */
function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
//# sourceMappingURL=context-utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
/**
 * Returns true if this {@link SpanContext} is valid.
 * @return true if this {@link SpanContext} is valid.
 */
function isSpanContextValid(spanContext) {
    return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));
}
/**
 * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
 *
 * @param spanContext span context to be wrapped
 * @returns a new non-recording {@link Span} with the provided context
 */
function wrapSpanContext(spanContext) {
    return new NonRecordingSpan(spanContext);
}
//# sourceMappingURL=spancontext-utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var context = ContextAPI.getInstance();
/**
 * No-op implementations of {@link Tracer}.
 */
var NoopTracer = /** @class */ (function () {
    function NoopTracer() {
    }
    // startSpan starts a noop span.
    NoopTracer.prototype.startSpan = function (name, options, context) {
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
            return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) &&
            isSpanContextValid(parentFromContext)) {
            return new NonRecordingSpan(parentFromContext);
        }
        else {
            return new NonRecordingSpan();
        }
    };
    NoopTracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        }
        else if (arguments.length === 2) {
            fn = arg2;
        }
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        }
        else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return context.with(contextWithSpanSet, fn, undefined, span);
    };
    return NoopTracer;
}());

function isSpanContext(spanContext) {
    return (typeof spanContext === 'object' &&
        typeof spanContext['spanId'] === 'string' &&
        typeof spanContext['traceId'] === 'string' &&
        typeof spanContext['traceFlags'] === 'number');
}
//# sourceMappingURL=NoopTracer.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var NOOP_TRACER = new NoopTracer();
/**
 * Proxy tracer provided by the proxy tracer provider
 */
var ProxyTracer = /** @class */ (function () {
    function ProxyTracer(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    ProxyTracer.prototype.startSpan = function (name, options, context) {
        return this._getTracer().startSpan(name, options, context);
    };
    ProxyTracer.prototype.startActiveSpan = function (_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    /**
     * Try to get a tracer from the proxy tracer provider.
     * If the proxy tracer provider has no delegate, return a noop tracer.
     */
    ProxyTracer.prototype._getTracer = function () {
        if (this._delegate) {
            return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
            return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer;
}());

//# sourceMappingURL=ProxyTracer.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An implementation of the {@link TracerProvider} which returns an impotent
 * Tracer for all calls to `getTracer`.
 *
 * All operations are no-op.
 */
var NoopTracerProvider = /** @class */ (function () {
    function NoopTracerProvider() {
    }
    NoopTracerProvider.prototype.getTracer = function (_name, _version, _options) {
        return new NoopTracer();
    };
    return NoopTracerProvider;
}());

//# sourceMappingURL=NoopTracerProvider.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
/**
 * Tracer provider which provides {@link ProxyTracer}s.
 *
 * Before a delegate is set, tracers provided are NoOp.
 *   When a delegate is set, traces are provided from the delegate.
 *   When a delegate is set after tracers have already been provided,
 *   all tracers already provided will use the provided delegate implementation.
 */
var ProxyTracerProvider = /** @class */ (function () {
    function ProxyTracerProvider() {
    }
    /**
     * Get a {@link ProxyTracer}
     */
    ProxyTracerProvider.prototype.getTracer = function (name, version, options) {
        var _a;
        return ((_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options));
    };
    ProxyTracerProvider.prototype.getDelegate = function () {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
    };
    /**
     * Set the delegate tracer provider
     */
    ProxyTracerProvider.prototype.setDelegate = function (delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider.prototype.getDelegateTracer = function (name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
    };
    return ProxyTracerProvider;
}());

//# sourceMappingURL=ProxyTracerProvider.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */
var SamplingDecision;
(function (SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */
    SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */
    SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */
    SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));
//# sourceMappingURL=SamplingResult.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SpanKind;
(function (SpanKind) {
    /** Default value. Indicates that the span is used internally. */
    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));
//# sourceMappingURL=span_kind.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/status.js
/**
 * An enumeration of status codes.
 */
var SpanStatusCode;
(function (SpanStatusCode) {
    /**
     * The default status.
     */
    SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */
    SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
    /**
     * The operation contains an error.
     */
    SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));
//# sourceMappingURL=status.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */
function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
}
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */
function validateValue(value) {
    return (VALID_VALUE_BASE_REGEX.test(value) &&
        !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));
}
//# sourceMappingURL=tracestate-validators.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ',';
var LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */
var tracestate_impl_TraceStateImpl = /** @class */ (function () {
    function TraceStateImpl(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState)
            this._parse(rawTraceState);
    }
    TraceStateImpl.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
            traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceStateImpl.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceStateImpl.prototype.get = function (key) {
        return this._internalState.get(key);
    };
    TraceStateImpl.prototype.serialize = function () {
        var _this = this;
        return this._keys()
            .reduce(function (agg, key) {
            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, [])
            .join(LIST_MEMBERS_SEPARATOR);
    };
    TraceStateImpl.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
            return;
        this._internalState = rawTraceState
            .split(LIST_MEMBERS_SEPARATOR)
            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
            .reduce(function (agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if (validateKey(key) && validateValue(value)) {
                    agg.set(key, value);
                }
                else {
                    // TODO: Consider to add warning log
                }
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
            this._internalState = new Map(Array.from(this._internalState.entries())
                .reverse() // Use reverse same as original tracestate parse chain
                .slice(0, MAX_TRACE_STATE_ITEMS));
        }
    };
    TraceStateImpl.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceStateImpl.prototype._clone = function () {
        var traceState = new TraceStateImpl();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceStateImpl;
}());

//# sourceMappingURL=tracestate-impl.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function createTraceState(rawTraceState) {
    return new TraceStateImpl(rawTraceState);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/api/trace.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var trace_API_NAME = 'trace';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 */
var TraceAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function TraceAPI() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
    }
    /** Get the singleton instance of the Trace API */
    TraceAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new TraceAPI();
        }
        return this._instance;
    };
    /**
     * Set the current global tracer.
     *
     * @returns true if the tracer provider was successfully registered, else false
     */
    TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
        var success = registerGlobal(trace_API_NAME, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
            this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
    };
    /**
     * Returns the global tracer provider.
     */
    TraceAPI.prototype.getTracerProvider = function () {
        return getGlobal(trace_API_NAME) || this._proxyTracerProvider;
    };
    /**
     * Returns a tracer from the global tracer provider.
     */
    TraceAPI.prototype.getTracer = function (name, version) {
        return this.getTracerProvider().getTracer(name, version);
    };
    /** Remove the global tracer provider */
    TraceAPI.prototype.disable = function () {
        unregisterGlobal(trace_API_NAME, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI;
}());

//# sourceMappingURL=trace.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * No-op implementations of {@link TextMapPropagator}.
 */
var NoopTextMapPropagator = /** @class */ (function () {
    function NoopTextMapPropagator() {
    }
    /** Noop inject function does nothing */
    NoopTextMapPropagator.prototype.inject = function (_context, _carrier) { };
    /** Noop extract function does nothing and returns the input context */
    NoopTextMapPropagator.prototype.extract = function (context, _carrier) {
        return context;
    };
    NoopTextMapPropagator.prototype.fields = function () {
        return [];
    };
    return NoopTextMapPropagator;
}());

//# sourceMappingURL=NoopTextMapPropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Baggage key
 */
var BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
/**
 * Retrieve the current baggage from the given context
 *
 * @param {Context} Context that manage all context values
 * @returns {Baggage} Extracted baggage from the context
 */
function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
}
/**
 * Store a baggage in the given context
 *
 * @param {Context} Context that manage all context values
 * @param {Baggage} baggage that will be set in the actual context
 */
function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
}
/**
 * Delete the baggage stored in the given context
 *
 * @param {Context} Context that manage all context values
 */
function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
}
//# sourceMappingURL=context-helpers.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/api/propagation.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var propagation_API_NAME = 'propagation';
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 */
var PropagationAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function PropagationAPI() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
    }
    /** Get the singleton instance of the Propagator API */
    PropagationAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new PropagationAPI();
        }
        return this._instance;
    };
    /**
     * Set the current propagator.
     *
     * @returns true if the propagator was successfully registered, else false
     */
    PropagationAPI.prototype.setGlobalPropagator = function (propagator) {
        return registerGlobal(propagation_API_NAME, propagator, DiagAPI.instance());
    };
    /**
     * Inject context into a carrier to be propagated inter-process
     *
     * @param context Context carrying tracing data to inject
     * @param carrier carrier to inject context into
     * @param setter Function used to set values on the carrier
     */
    PropagationAPI.prototype.inject = function (context, carrier, setter) {
        if (setter === void 0) { setter = defaultTextMapSetter; }
        return this._getGlobalPropagator().inject(context, carrier, setter);
    };
    /**
     * Extract context from a carrier
     *
     * @param context Context which the newly created context will inherit from
     * @param carrier Carrier to extract context from
     * @param getter Function used to extract keys from a carrier
     */
    PropagationAPI.prototype.extract = function (context, carrier, getter) {
        if (getter === void 0) { getter = defaultTextMapGetter; }
        return this._getGlobalPropagator().extract(context, carrier, getter);
    };
    /**
     * Return a list of all fields which may be used by the propagator.
     */
    PropagationAPI.prototype.fields = function () {
        return this._getGlobalPropagator().fields();
    };
    /** Remove the global propagator */
    PropagationAPI.prototype.disable = function () {
        unregisterGlobal(propagation_API_NAME, DiagAPI.instance());
    };
    PropagationAPI.prototype._getGlobalPropagator = function () {
        return getGlobal(propagation_API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI;
}());

//# sourceMappingURL=propagation.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





























/** Entrypoint for context API */
var esm_context = ContextAPI.getInstance();

/** Entrypoint for trace API */
var trace = TraceAPI.getInstance();

/** Entrypoint for propagation API */
var propagation = PropagationAPI.getInstance();

/**
 * Entrypoint for Diag API.
 * Defines Diagnostic handler used for internal diagnostic logging operations.
 * The default provides a Noop DiagLogger implementation which may be changed via the
 * diag.setLogger(logger: DiagLogger) function.
 */
var esm_diag = DiagAPI.instance();
/* harmony default export */ const esm = ({
    trace: trace,
    context: esm_context,
    propagation: propagation,
    diag: esm_diag,
});
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./src/utils/convertToUserMedia.ts

var convertToUserMedia = function (options, fallbackValue) {
    if (fallbackValue === void 0) { fallbackValue = UserMedia.None; }
    if (!options) {
        return fallbackValue;
    }
    if (options.camera && options.microphone) {
        return UserMedia.MicrophoneAndCamera;
    }
    else if (options.camera) {
        return UserMedia.Camera;
    }
    else if (options.microphone) {
        return UserMedia.Microphone;
    }
    else {
        return UserMedia.None;
    }
};
/* harmony default export */ const utils_convertToUserMedia = (convertToUserMedia);

;// CONCATENATED MODULE: ./src/utils/utils.ts
/**
 * Replace "wss://" at the front of the URL with "https://".
 * @param uri the uri to convert
 * @returns the converted uri
 */
function convertWssToHttps(uri) {
    return uri.replace(/^wss:\/\//, 'https://');
}
/**
 * Removes the path and search parameters from the url.
 * @param url - The url to be sanitized.
 * @returns The sanitized url.
 */
function getUrlHost(url) {
    try {
        if (!url) {
            return undefined;
        }
        var outUrl = new URL(url);
        // remove path and query params
        outUrl.pathname = '';
        outUrl.search = '';
        return outUrl.toString();
    }
    catch (e) {
        return undefined;
    }
}

;// CONCATENATED MODULE: ./src/enums/ConversationStateTypes.ts
/**
 * @public
 */
var ConversationStateTypes;
(function (ConversationStateTypes) {
    ConversationStateTypes["dpSpeaking"] = "dpSpeaking";
    ConversationStateTypes["userSpeaking"] = "userSpeaking";
    ConversationStateTypes["dpProcessing"] = "dpProcessing";
    ConversationStateTypes["idle"] = "idle";
})(ConversationStateTypes || (ConversationStateTypes = {}));

;// CONCATENATED MODULE: ./src/ConversationState.ts
/**
 * @module smwebsdk
 */




/**
 * Determines and stores Conversation State.
 *
 * @public
 */
var ConversationState = /** @class */ (function () {
    function ConversationState(logger) {
        if (logger === void 0) { logger = new Logger(); }
        this.logger = logger;
        this._conversationState = ConversationStateTypes.idle;
        this._userActive = false;
        this._onConversationStateUpdated = new SmEvent();
    }
    ConversationState.prototype.processStateMessage = function (responseBody) {
        if (responseBody &&
            responseBody.persona &&
            Object.keys(responseBody.persona).length > 0) {
            var dpId = Object.keys(responseBody.persona)[0];
            if (!this._userActive && responseBody.persona[dpId].speechState) {
                var messageSpeechState = responseBody.persona[dpId]
                    .speechState;
                if (messageSpeechState === SpeechState.Idle) {
                    this.setSpeechState(ConversationStateTypes.idle);
                }
                else if (messageSpeechState === SpeechState.Speaking) {
                    this.setSpeechState(ConversationStateTypes.dpSpeaking);
                }
            }
        }
    };
    ConversationState.prototype.processRecognizeResultsMessage = function (responseBody) {
        this._userActive = true;
        var isErrorMessage = responseBody.status !== 0;
        var isFinal = responseBody.results &&
            responseBody.results.some(function (result) { return result.final; });
        if (isErrorMessage) {
            var errorMessage = typeof responseBody.errorMessage !== 'undefined'
                ? responseBody.errorMessage
                : 'recognizeResults sent back a message with non-zero status but no error message.';
            this.logger.log('error', errorMessage);
        }
        else if (isFinal) {
            this.setSpeechState(ConversationStateTypes.dpProcessing);
        }
        else {
            this.setSpeechState(ConversationStateTypes.userSpeaking);
        }
        this._userActive = false;
    };
    ConversationState.prototype.setSpeechState = function (speechState) {
        if (this._conversationState !== speechState) {
            this._conversationState = speechState;
            this._onConversationStateUpdated.call(this._conversationState);
        }
    };
    ConversationState.prototype.getSpeechState = function () {
        return this._conversationState;
    };
    Object.defineProperty(ConversationState.prototype, "onConversationStateUpdated", {
        get: function () {
            return this._onConversationStateUpdated;
        },
        enumerable: false,
        configurable: true
    });
    ConversationState.prototype.reset = function () {
        this._userActive = false;
        this._conversationState = ConversationStateTypes.idle;
        this._onConversationStateUpdated.call(this._conversationState);
    };
    return ConversationState;
}());


;// CONCATENATED MODULE: ./src/ContentCardFormatter.ts

/**
 * Formats content card data in a consistent structure
 *
 * @public
 */
var ContentCardFormatter = /** @class */ (function () {
    function ContentCardFormatter() {
    }
    /**
     * Format different NLP content cards into a consistent structure
     */
    ContentCardFormatter.prototype.format = function (body) {
        var _a;
        var fullfillments = (_a = body.provider.meta.dialogflow) === null || _a === void 0 ? void 0 : _a.queryResult.fulfillmentMessages;
        var data = fullfillments === null || fullfillments === void 0 ? void 0 : fullfillments.find(function (fullfillment) {
            return Boolean(fullfillment === null || fullfillment === void 0 ? void 0 : fullfillment.payload);
        });
        if (data) {
            return this.formatLegacyDialogflow(data);
        }
        return this.formatContextData(body.output.context);
    };
    ContentCardFormatter.prototype.formatLegacyDialogflow = function (data) {
        var _this = this;
        var payload = data.payload.soulmachines;
        return Object.keys(payload).map(function (id) {
            return {
                id: id,
                data: __assign({ id: id }, _this.formatCardData(payload[id])),
            };
        });
    };
    ContentCardFormatter.prototype.formatContextData = function (data) {
        var _this = this;
        return this.allowedIds(data).map(function (id) {
            var cardId = id.replace('public-', '');
            return {
                id: cardId,
                data: __assign({ id: cardId }, _this.formatCardData(data[id])),
            };
        });
    };
    ContentCardFormatter.prototype.allowedIds = function (values) {
        return Object.keys(values)
            .filter(function (k) { return /public-/.test(k) === true; })
            .filter(function (k) { return /\.original/gm.test(k) === false; });
    };
    // Data should be JSON or a ContentCard, however, we can attempt to parse
    // unknown values as JSON.
    ContentCardFormatter.prototype.formatCardData = function (data) {
        var parsedData = typeof data === 'string' ? JSON.parse(data) : data;
        var component = parsedData.component, type = parsedData.type, rest = __rest(parsedData, ["component", "type"]);
        return __assign({ type: type ? type : component }, rest);
    };
    return ContentCardFormatter;
}());


;// CONCATENATED MODULE: ./src/Conversation.ts






/**
 * Stores content cards and conversation state
 *
 * @public
 */
var Conversation = /** @class */ (function () {
    function Conversation(logger, conversationState, contentCardFormatter) {
        if (logger === void 0) { logger = new Logger(); }
        if (conversationState === void 0) { conversationState = new ConversationState(); }
        if (contentCardFormatter === void 0) { contentCardFormatter = new ContentCardFormatter(); }
        this.logger = logger;
        this.conversationState = conversationState;
        this.contentCardFormatter = contentCardFormatter;
        this._onCardChanged = new SmEvent();
        this._autoClearCards = false;
        this.cardData = new Map();
        this.activeCardIds = new Set();
    }
    Conversation.prototype.processStateMessage = function (message) {
        this.conversationState.processStateMessage(message);
    };
    Conversation.prototype.processRecognizeResultsMessage = function (message) {
        this.conversationState.processRecognizeResultsMessage(message);
    };
    Object.defineProperty(Conversation.prototype, "onConversationStateUpdated", {
        /**
         * A callback function which fires when conversation state changes
         */
        get: function () {
            return this.conversationState.onConversationStateUpdated;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "autoClearCards", {
        /**
         * Automatically clear active content cards each conversation turn
         */
        set: function (enabled) {
            this._autoClearCards = enabled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "onCardChanged", {
        /**
         * A callback function which fires when active cards are changed
         */
        get: function () {
            return this._onCardChanged;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "activeCards", {
        get: function () {
            var _this = this;
            var activeCardInfo = [];
            this.activeCardIds.forEach(function (id) {
                var data = _this.cardData.get(id);
                if (data) {
                    activeCardInfo.push(data);
                }
                else {
                    _this.logger.log('error', "card data for ".concat(id, " does not exist"));
                }
            });
            return activeCardInfo;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Handles speech marker messages and updates the active card state
     */
    Conversation.prototype.onSpeechMarker = function (messageBody) {
        var cardIds = messageBody.arguments;
        if (messageBody.name === SpeechMarkerName.Showcards) {
            this.addActiveCardIds(cardIds);
        }
        else if (messageBody.name === SpeechMarkerName.Hidecards) {
            this.removeActiveCards(cardIds);
        }
        if (
        // Hide all cards when arg list is empty and hidecards message is received
        cardIds.length === 0 &&
            messageBody.name === SpeechMarkerName.Hidecards) {
            this.clearActiveCards();
        }
    };
    /**
     * Stores content card data contained in conversation result messages
     */
    Conversation.prototype.onConversationResult = function (messageBody) {
        var _this = this;
        var cards = this.contentCardFormatter.format(messageBody);
        if (this._autoClearCards) {
            this.clearActiveCards();
        }
        cards.map(function (_a) {
            var id = _a.id, data = _a.data;
            _this.cardData.set(id, data);
        });
    };
    /**
     * Clears active card ids and data. Emits a card changed event
     */
    Conversation.prototype.reset = function () {
        this.clearActiveCards();
        this.cardData.clear();
        this.conversationState.reset();
    };
    /**
     * Clears active card ids. Emits a card changed event
     */
    Conversation.prototype.clearActiveCards = function () {
        this.activeCardIds.clear();
        this.onCardChanged.call(this.activeCards);
    };
    Conversation.prototype.addActiveCardIds = function (cardIds) {
        this.activeCardIds = new Set(__spreadArray(__spreadArray([], __read(this.activeCardIds), false), __read(cardIds), false));
        this.onCardChanged.call(this.activeCards);
    };
    Conversation.prototype.removeActiveCards = function (cardIds) {
        var _this = this;
        cardIds.forEach(function (cardId) { return _this.activeCardIds.delete(cardId); });
        this.onCardChanged.call(this.activeCards);
    };
    return Conversation;
}());


;// CONCATENATED MODULE: ./src/MetadataSender.ts

var MetadataSender = /** @class */ (function () {
    function MetadataSender(scene) {
        var _this = this;
        this.scene = scene;
        this._previousUrl = window.location.href;
        this._observer = new MutationObserver(function () { return _this.observeDocumentChanges(); });
    }
    MetadataSender.prototype.observeUrlChanges = function () {
        this._observer.observe(document, { subtree: true, childList: true });
    };
    MetadataSender.prototype.disconnect = function () {
        this._observer.disconnect();
    };
    MetadataSender.prototype.send = function () {
        var conversationVariables = {
            personaId: this.scene.currentPersonaId,
            text: NLPIntent.PAGE_METADATA,
            variables: {
                pageUrl: window.location.href.split('?')[0],
            },
            optionalArgs: {},
        };
        this.scene.sendRequest('conversationSend', conversationVariables);
    };
    MetadataSender.prototype.observeDocumentChanges = function () {
        if (window.location.href !== this._previousUrl) {
            // Update url to current one
            this._previousUrl = window.location.href;
            // Send event
            this.send();
        }
    };
    return MetadataSender;
}());


;// CONCATENATED MODULE: ./src/ConnectionState.ts
/**
 * @module smwebsdk
 */


var TOTAL_CONNECTION_STEPS = Object.keys(ConnectionStateTypes).length;
/**
 * Determines and stores Connection State.
 *
 * @public
 */
var ConnectionState = /** @class */ (function () {
    function ConnectionState() {
        this._connectionState = {
            name: ConnectionStateTypes.Disconnected,
            totalSteps: TOTAL_CONNECTION_STEPS,
            currentStep: 0,
            percentageLoaded: 0,
        };
        this._onConnectionStateUpdated = new SmEvent();
    }
    ConnectionState.prototype.setConnectionState = function (connectionStateType) {
        // Return if state has not changed
        if (this._connectionState.name === connectionStateType) {
            return;
        }
        var currentStep = Object.keys(ConnectionStateTypes).indexOf(connectionStateType);
        var data = {
            name: connectionStateType,
            currentStep: currentStep,
            totalSteps: TOTAL_CONNECTION_STEPS,
            percentageLoaded: (100 / (TOTAL_CONNECTION_STEPS - 1)) * currentStep,
        };
        this._connectionState = data;
        this._onConnectionStateUpdated.call(data);
    };
    ConnectionState.prototype.getConnectionState = function () {
        return this._connectionState;
    };
    Object.defineProperty(ConnectionState.prototype, "onConnectionStateUpdated", {
        get: function () {
            return this._onConnectionStateUpdated;
        },
        enumerable: false,
        configurable: true
    });
    ConnectionState.prototype.reset = function () {
        this.setConnectionState(ConnectionStateTypes.Disconnected);
    };
    return ConnectionState;
}());


;// CONCATENATED MODULE: ./node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var SemanticResourceAttributes = {
    /**
    * Name of the cloud provider.
    */
    CLOUD_PROVIDER: 'cloud.provider',
    /**
    * The cloud account ID the resource is assigned to.
    */
    CLOUD_ACCOUNT_ID: 'cloud.account.id',
    /**
    * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
    */
    CLOUD_REGION: 'cloud.region',
    /**
    * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
    *
    * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
    */
    CLOUD_AVAILABILITY_ZONE: 'cloud.availability_zone',
    /**
    * The cloud platform in use.
    *
    * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
    */
    CLOUD_PLATFORM: 'cloud.platform',
    /**
    * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
    */
    AWS_ECS_CONTAINER_ARN: 'aws.ecs.container.arn',
    /**
    * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
    */
    AWS_ECS_CLUSTER_ARN: 'aws.ecs.cluster.arn',
    /**
    * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
    */
    AWS_ECS_LAUNCHTYPE: 'aws.ecs.launchtype',
    /**
    * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
    */
    AWS_ECS_TASK_ARN: 'aws.ecs.task.arn',
    /**
    * The task definition family this task definition is a member of.
    */
    AWS_ECS_TASK_FAMILY: 'aws.ecs.task.family',
    /**
    * The revision for this task definition.
    */
    AWS_ECS_TASK_REVISION: 'aws.ecs.task.revision',
    /**
    * The ARN of an EKS cluster.
    */
    AWS_EKS_CLUSTER_ARN: 'aws.eks.cluster.arn',
    /**
    * The name(s) of the AWS log group(s) an application is writing to.
    *
    * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
    */
    AWS_LOG_GROUP_NAMES: 'aws.log.group.names',
    /**
    * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
    *
    * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
    */
    AWS_LOG_GROUP_ARNS: 'aws.log.group.arns',
    /**
    * The name(s) of the AWS log stream(s) an application is writing to.
    */
    AWS_LOG_STREAM_NAMES: 'aws.log.stream.names',
    /**
    * The ARN(s) of the AWS log stream(s).
    *
    * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
    */
    AWS_LOG_STREAM_ARNS: 'aws.log.stream.arns',
    /**
    * Container name.
    */
    CONTAINER_NAME: 'container.name',
    /**
    * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
    */
    CONTAINER_ID: 'container.id',
    /**
    * The container runtime managing this container.
    */
    CONTAINER_RUNTIME: 'container.runtime',
    /**
    * Name of the image the container was built on.
    */
    CONTAINER_IMAGE_NAME: 'container.image.name',
    /**
    * Container image tag.
    */
    CONTAINER_IMAGE_TAG: 'container.image.tag',
    /**
    * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
    */
    DEPLOYMENT_ENVIRONMENT: 'deployment.environment',
    /**
    * A unique identifier representing the device.
    *
    * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
    */
    DEVICE_ID: 'device.id',
    /**
    * The model identifier for the device.
    *
    * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
    */
    DEVICE_MODEL_IDENTIFIER: 'device.model.identifier',
    /**
    * The marketing name for the device model.
    *
    * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
    */
    DEVICE_MODEL_NAME: 'device.model.name',
    /**
    * The name of the single function that this runtime instance executes.
    *
    * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
    */
    FAAS_NAME: 'faas.name',
    /**
    * The unique ID of the single function that this runtime instance executes.
    *
    * Note: Depending on the cloud provider, use:
  
  * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
  Take care not to use the &#34;invoked ARN&#34; directly but replace any
  [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
  different aliases.
  * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
  * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
  
  On some providers, it may not be possible to determine the full ID at startup,
  which is why this field cannot be made required. For example, on AWS the account ID
  part of the ARN is not available without calling another AWS API
  which may be deemed too slow for a short-running lambda function.
  As an alternative, consider setting `faas.id` as a span attribute instead.
    */
    FAAS_ID: 'faas.id',
    /**
    * The immutable version of the function being executed.
    *
    * Note: Depending on the cloud provider and platform, use:
  
  * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
    (an integer represented as a decimal string).
  * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
    (i.e., the function name plus the revision suffix).
  * **Google Cloud Functions:** The value of the
    [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
  * **Azure Functions:** Not applicable. Do not set this attribute.
    */
    FAAS_VERSION: 'faas.version',
    /**
    * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
    *
    * Note: * **AWS Lambda:** Use the (full) log stream name.
    */
    FAAS_INSTANCE: 'faas.instance',
    /**
    * The amount of memory available to the serverless function in MiB.
    *
    * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
    */
    FAAS_MAX_MEMORY: 'faas.max_memory',
    /**
    * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
    */
    HOST_ID: 'host.id',
    /**
    * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
    */
    HOST_NAME: 'host.name',
    /**
    * Type of host. For Cloud, this must be the machine type.
    */
    HOST_TYPE: 'host.type',
    /**
    * The CPU architecture the host system is running on.
    */
    HOST_ARCH: 'host.arch',
    /**
    * Name of the VM image or OS install the host was instantiated from.
    */
    HOST_IMAGE_NAME: 'host.image.name',
    /**
    * VM image ID. For Cloud, this value is from the provider.
    */
    HOST_IMAGE_ID: 'host.image.id',
    /**
    * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
    */
    HOST_IMAGE_VERSION: 'host.image.version',
    /**
    * The name of the cluster.
    */
    K8S_CLUSTER_NAME: 'k8s.cluster.name',
    /**
    * The name of the Node.
    */
    K8S_NODE_NAME: 'k8s.node.name',
    /**
    * The UID of the Node.
    */
    K8S_NODE_UID: 'k8s.node.uid',
    /**
    * The name of the namespace that the pod is running in.
    */
    K8S_NAMESPACE_NAME: 'k8s.namespace.name',
    /**
    * The UID of the Pod.
    */
    K8S_POD_UID: 'k8s.pod.uid',
    /**
    * The name of the Pod.
    */
    K8S_POD_NAME: 'k8s.pod.name',
    /**
    * The name of the Container in a Pod template.
    */
    K8S_CONTAINER_NAME: 'k8s.container.name',
    /**
    * The UID of the ReplicaSet.
    */
    K8S_REPLICASET_UID: 'k8s.replicaset.uid',
    /**
    * The name of the ReplicaSet.
    */
    K8S_REPLICASET_NAME: 'k8s.replicaset.name',
    /**
    * The UID of the Deployment.
    */
    K8S_DEPLOYMENT_UID: 'k8s.deployment.uid',
    /**
    * The name of the Deployment.
    */
    K8S_DEPLOYMENT_NAME: 'k8s.deployment.name',
    /**
    * The UID of the StatefulSet.
    */
    K8S_STATEFULSET_UID: 'k8s.statefulset.uid',
    /**
    * The name of the StatefulSet.
    */
    K8S_STATEFULSET_NAME: 'k8s.statefulset.name',
    /**
    * The UID of the DaemonSet.
    */
    K8S_DAEMONSET_UID: 'k8s.daemonset.uid',
    /**
    * The name of the DaemonSet.
    */
    K8S_DAEMONSET_NAME: 'k8s.daemonset.name',
    /**
    * The UID of the Job.
    */
    K8S_JOB_UID: 'k8s.job.uid',
    /**
    * The name of the Job.
    */
    K8S_JOB_NAME: 'k8s.job.name',
    /**
    * The UID of the CronJob.
    */
    K8S_CRONJOB_UID: 'k8s.cronjob.uid',
    /**
    * The name of the CronJob.
    */
    K8S_CRONJOB_NAME: 'k8s.cronjob.name',
    /**
    * The operating system type.
    */
    OS_TYPE: 'os.type',
    /**
    * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
    */
    OS_DESCRIPTION: 'os.description',
    /**
    * Human readable operating system name.
    */
    OS_NAME: 'os.name',
    /**
    * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
    */
    OS_VERSION: 'os.version',
    /**
    * Process identifier (PID).
    */
    PROCESS_PID: 'process.pid',
    /**
    * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_NAME: 'process.executable.name',
    /**
    * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_PATH: 'process.executable.path',
    /**
    * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
    */
    PROCESS_COMMAND: 'process.command',
    /**
    * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
    */
    PROCESS_COMMAND_LINE: 'process.command_line',
    /**
    * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
    */
    PROCESS_COMMAND_ARGS: 'process.command_args',
    /**
    * The username of the user that owns the process.
    */
    PROCESS_OWNER: 'process.owner',
    /**
    * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
    */
    PROCESS_RUNTIME_NAME: 'process.runtime.name',
    /**
    * The version of the runtime of this process, as returned by the runtime without modification.
    */
    PROCESS_RUNTIME_VERSION: 'process.runtime.version',
    /**
    * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
    */
    PROCESS_RUNTIME_DESCRIPTION: 'process.runtime.description',
    /**
    * Logical name of the service.
    *
    * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
    */
    SERVICE_NAME: 'service.name',
    /**
    * A namespace for `service.name`.
    *
    * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
    */
    SERVICE_NAMESPACE: 'service.namespace',
    /**
    * The string ID of the service instance.
    *
    * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
    */
    SERVICE_INSTANCE_ID: 'service.instance.id',
    /**
    * The version string of the service API or implementation.
    */
    SERVICE_VERSION: 'service.version',
    /**
    * The name of the telemetry SDK as defined above.
    */
    TELEMETRY_SDK_NAME: 'telemetry.sdk.name',
    /**
    * The language of the telemetry SDK.
    */
    TELEMETRY_SDK_LANGUAGE: 'telemetry.sdk.language',
    /**
    * The version string of the telemetry SDK.
    */
    TELEMETRY_SDK_VERSION: 'telemetry.sdk.version',
    /**
    * The version string of the auto instrumentation agent, if used.
    */
    TELEMETRY_AUTO_VERSION: 'telemetry.auto.version',
    /**
    * The name of the web engine.
    */
    WEBENGINE_NAME: 'webengine.name',
    /**
    * The version of the web engine.
    */
    WEBENGINE_VERSION: 'webengine.version',
    /**
    * Additional description of the web engine (e.g. detailed version and edition information).
    */
    WEBENGINE_DESCRIPTION: 'webengine.description',
};
var CloudProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var CloudPlatformValues = {
    /** Alibaba Cloud Elastic Compute Service. */
    ALIBABA_CLOUD_ECS: 'alibaba_cloud_ecs',
    /** Alibaba Cloud Function Compute. */
    ALIBABA_CLOUD_FC: 'alibaba_cloud_fc',
    /** AWS Elastic Compute Cloud. */
    AWS_EC2: 'aws_ec2',
    /** AWS Elastic Container Service. */
    AWS_ECS: 'aws_ecs',
    /** AWS Elastic Kubernetes Service. */
    AWS_EKS: 'aws_eks',
    /** AWS Lambda. */
    AWS_LAMBDA: 'aws_lambda',
    /** AWS Elastic Beanstalk. */
    AWS_ELASTIC_BEANSTALK: 'aws_elastic_beanstalk',
    /** Azure Virtual Machines. */
    AZURE_VM: 'azure_vm',
    /** Azure Container Instances. */
    AZURE_CONTAINER_INSTANCES: 'azure_container_instances',
    /** Azure Kubernetes Service. */
    AZURE_AKS: 'azure_aks',
    /** Azure Functions. */
    AZURE_FUNCTIONS: 'azure_functions',
    /** Azure App Service. */
    AZURE_APP_SERVICE: 'azure_app_service',
    /** Google Cloud Compute Engine (GCE). */
    GCP_COMPUTE_ENGINE: 'gcp_compute_engine',
    /** Google Cloud Run. */
    GCP_CLOUD_RUN: 'gcp_cloud_run',
    /** Google Cloud Kubernetes Engine (GKE). */
    GCP_KUBERNETES_ENGINE: 'gcp_kubernetes_engine',
    /** Google Cloud Functions (GCF). */
    GCP_CLOUD_FUNCTIONS: 'gcp_cloud_functions',
    /** Google Cloud App Engine (GAE). */
    GCP_APP_ENGINE: 'gcp_app_engine',
};
var AwsEcsLaunchtypeValues = {
    /** ec2. */
    EC2: 'ec2',
    /** fargate. */
    FARGATE: 'fargate',
};
var HostArchValues = {
    /** AMD64. */
    AMD64: 'amd64',
    /** ARM32. */
    ARM32: 'arm32',
    /** ARM64. */
    ARM64: 'arm64',
    /** Itanium. */
    IA64: 'ia64',
    /** 32-bit PowerPC. */
    PPC32: 'ppc32',
    /** 64-bit PowerPC. */
    PPC64: 'ppc64',
    /** 32-bit x86. */
    X86: 'x86',
};
var OsTypeValues = {
    /** Microsoft Windows. */
    WINDOWS: 'windows',
    /** Linux. */
    LINUX: 'linux',
    /** Apple Darwin. */
    DARWIN: 'darwin',
    /** FreeBSD. */
    FREEBSD: 'freebsd',
    /** NetBSD. */
    NETBSD: 'netbsd',
    /** OpenBSD. */
    OPENBSD: 'openbsd',
    /** DragonFly BSD. */
    DRAGONFLYBSD: 'dragonflybsd',
    /** HP-UX (Hewlett Packard Unix). */
    HPUX: 'hpux',
    /** AIX (Advanced Interactive eXecutive). */
    AIX: 'aix',
    /** Oracle Solaris. */
    SOLARIS: 'solaris',
    /** IBM z/OS. */
    Z_OS: 'z_os',
};
var TelemetrySdkLanguageValues = {
    /** cpp. */
    CPP: 'cpp',
    /** dotnet. */
    DOTNET: 'dotnet',
    /** erlang. */
    ERLANG: 'erlang',
    /** go. */
    GO: 'go',
    /** java. */
    JAVA: 'java',
    /** nodejs. */
    NODEJS: 'nodejs',
    /** php. */
    PHP: 'php',
    /** python. */
    PYTHON: 'python',
    /** ruby. */
    RUBY: 'ruby',
    /** webjs. */
    WEBJS: 'webjs',
};
//# sourceMappingURL=SemanticResourceAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/version.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var version_VERSION = '1.8.0';
//# sourceMappingURL=version.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/platform/browser/sdk-info.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;


/** Constants describing the SDK in use */
var SDK_INFO = (_a = {},
    _a[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = 'opentelemetry',
    _a[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = 'browser',
    _a[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = TelemetrySdkLanguageValues.WEBJS,
    _a[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = version_VERSION,
    _a);
//# sourceMappingURL=sdk-info.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/resources/build/esm/platform/browser/default-service-name.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function defaultServiceName() {
    return 'unknown_service';
}
//# sourceMappingURL=default-service-name.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/resources/build/esm/Resource.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * A Resource describes the entity for which a signals (metrics or trace) are
 * collected.
 */
var Resource_Resource = /** @class */ (function () {
    function Resource(
    /**
     * A dictionary of attributes with string keys and values that provide
     * information about the entity as numbers, strings or booleans
     * TODO: Consider to add check/validation on attributes.
     */
    attributes) {
        this.attributes = attributes;
    }
    /**
     * Returns an empty Resource
     */
    Resource.empty = function () {
        return Resource.EMPTY;
    };
    /**
     * Returns a Resource that indentifies the SDK in use.
     */
    Resource.default = function () {
        var _a;
        return new Resource((_a = {},
            _a[SemanticResourceAttributes.SERVICE_NAME] = defaultServiceName(),
            _a[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE],
            _a[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_NAME],
            _a[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_VERSION],
            _a));
    };
    /**
     * Returns a new, merged {@link Resource} by merging the current Resource
     * with the other Resource. In case of a collision, other Resource takes
     * precedence.
     *
     * @param other the Resource that will be merged with this.
     * @returns the newly merged Resource.
     */
    Resource.prototype.merge = function (other) {
        if (!other || !Object.keys(other.attributes).length)
            return this;
        // SpanAttributes from resource overwrite attributes from other resource.
        var mergedAttributes = Object.assign({}, this.attributes, other.attributes);
        return new Resource(mergedAttributes);
    };
    Resource.EMPTY = new Resource({});
    return Resource;
}());

//# sourceMappingURL=Resource.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/utils/sampling.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TracesSamplerValues;
(function (TracesSamplerValues) {
    TracesSamplerValues["AlwaysOff"] = "always_off";
    TracesSamplerValues["AlwaysOn"] = "always_on";
    TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues || (TracesSamplerValues = {}));
//# sourceMappingURL=sampling.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/platform/browser/globalThis.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var browser_globalThis_globalThis = typeof globalThis === 'object' ? globalThis :
    typeof self === 'object' ? self :
        typeof window === 'object' ? window :
            typeof __webpack_require__.g === 'object' ? __webpack_require__.g :
                {};
//# sourceMappingURL=globalThis.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/utils/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var DEFAULT_LIST_SEPARATOR = ',';
/**
 * Environment interface to define all names
 */
var ENVIRONMENT_NUMBERS_KEYS = [
    'OTEL_BSP_EXPORT_TIMEOUT',
    'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BSP_MAX_QUEUE_SIZE',
    'OTEL_BSP_SCHEDULE_DELAY',
    'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_LINK_COUNT_LIMIT',
    'OTEL_EXPORTER_OTLP_TIMEOUT',
    'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
    'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
    'OTEL_EXPORTER_JAEGER_AGENT_PORT',
];
function isEnvVarANumber(key) {
    return (ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1);
}
var ENVIRONMENT_LISTS_KEYS = [
    'OTEL_NO_PATCH_MODULES',
    'OTEL_PROPAGATORS',
];
function isEnvVarAList(key) {
    return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
/**
 * Default environment variables
 */
var environment_DEFAULT_ENVIRONMENT = {
    CONTAINER_NAME: '',
    ECS_CONTAINER_METADATA_URI_V4: '',
    ECS_CONTAINER_METADATA_URI: '',
    HOSTNAME: '',
    KUBERNETES_SERVICE_HOST: '',
    NAMESPACE: '',
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: '',
    OTEL_EXPORTER_JAEGER_PASSWORD: '',
    OTEL_EXPORTER_JAEGER_USER: '',
    OTEL_EXPORTER_OTLP_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_HEADERS: '',
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
    OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
    OTEL_LOG_LEVEL: DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
    OTEL_RESOURCE_ATTRIBUTES: '',
    OTEL_SERVICE_NAME: '',
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_TRACES_EXPORTER: 'otlp',
    OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: '',
    OTEL_EXPORTER_OTLP_INSECURE: '',
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
    OTEL_EXPORTER_OTLP_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: 'cumulative'
};
/**
 * Parses a variable as number with number validation
 * @param name
 * @param environment
 * @param values
 * @param min
 * @param max
 */
function parseNumber(name, environment, values, min, max) {
    if (min === void 0) { min = -Infinity; }
    if (max === void 0) { max = Infinity; }
    if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
            if (value < min) {
                environment[name] = min;
            }
            else if (value > max) {
                environment[name] = max;
            }
            else {
                environment[name] = value;
            }
        }
    }
}
/**
 * Parses list-like strings from input into output.
 * @param name
 * @param environment
 * @param values
 * @param separator
 */
function parseStringList(name, output, input, separator) {
    if (separator === void 0) { separator = DEFAULT_LIST_SEPARATOR; }
    var givenValue = input[name];
    if (typeof givenValue === 'string') {
        output[name] = givenValue.split(separator).map(function (v) { return v.trim(); });
    }
}
// The support string -> DiagLogLevel mappings
var logLevelMap = {
    ALL: DiagLogLevel.ALL,
    VERBOSE: DiagLogLevel.VERBOSE,
    DEBUG: DiagLogLevel.DEBUG,
    INFO: DiagLogLevel.INFO,
    WARN: DiagLogLevel.WARN,
    ERROR: DiagLogLevel.ERROR,
    NONE: DiagLogLevel.NONE,
};
/**
 * Environmentally sets log level if valid log level string is provided
 * @param key
 * @param environment
 * @param values
 */
function setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if (typeof value === 'string') {
        var theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
            environment[key] = theLevel;
        }
    }
}
/**
 * Parses environment values
 * @param values
 */
function environment_parseEnvironment(values) {
    var environment = {};
    for (var env in environment_DEFAULT_ENVIRONMENT) {
        var key = env;
        switch (key) {
            case 'OTEL_LOG_LEVEL':
                setLogLevelFromEnv(key, environment, values);
                break;
            default:
                if (isEnvVarANumber(key)) {
                    parseNumber(key, environment, values);
                }
                else if (isEnvVarAList(key)) {
                    parseStringList(key, environment, values);
                }
                else {
                    var value = values[key];
                    if (typeof value !== 'undefined' && value !== null) {
                        environment[key] = String(value);
                    }
                }
        }
    }
    return environment;
}
/**
 * Get environment in node or browser without
 * populating default values.
 */
function getEnvWithoutDefaults() {
    return typeof process !== 'undefined' ?
        environment_parseEnvironment("MISSING_ENV_VAR") :
        environment_parseEnvironment(browser_globalThis_globalThis);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/platform/browser/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Gets the environment variables
 */
function getEnv() {
    var globalEnv = environment_parseEnvironment(browser_globalThis_globalThis);
    return Object.assign({}, environment_DEFAULT_ENVIRONMENT, globalEnv);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/utils/promise.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var promise_Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function (val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function (err) {
        this._reject(err);
    };
    return Deferred;
}());

//# sourceMappingURL=promise.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/utils/callback.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var callback_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var callback_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */
var BindOnceFuture = /** @class */ (function () {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_Deferred();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function () {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function () {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, callback_spreadArray([this._that], callback_read(args), false)))
                    .then(function (val) { return _this._deferred.resolve(val); }, function (err) { return _this._deferred.reject(err); });
            }
            catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}());

//# sourceMappingURL=callback.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SUPPRESS_TRACING_KEY = createContextKey('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
}
function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
}
function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
}
//# sourceMappingURL=suppress-tracing.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/ExportResult.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ExportResultCode;
(function (ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(ExportResultCode || (ExportResultCode = {}));
//# sourceMappingURL=ExportResult.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */
function loggingErrorHandler() {
    return function (ex) {
        esm_diag.error(stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */
function stringifyException(ex) {
    if (typeof ex === 'string') {
        return ex;
    }
    else {
        return JSON.stringify(flattenException(ex));
    }
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */
function flattenException(ex) {
    var result = {};
    var current = ex;
    while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function (propertyName) {
            if (result[propertyName])
                return;
            var value = current[propertyName];
            if (value) {
                result[propertyName] = String(value);
            }
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}
//# sourceMappingURL=logging-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** The global error handler delegate */
var delegateHandler = loggingErrorHandler();
/**
 * Set the global error handler
 * @param {ErrorHandler} handler
 */
function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
}
/**
 * Return the global error handler
 * @param {Exception} ex
 */
function globalErrorHandler(ex) {
    try {
        delegateHandler(ex);
    }
    catch (_a) { } // eslint-disable-line no-empty
}
//# sourceMappingURL=global-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/platform/browser/timer-util.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function unrefTimer(_timer) { }
//# sourceMappingURL=timer-util.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/export/BatchSpanProcessorBase.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Implementation of the {@link SpanProcessor} that batches spans exported by
 * the SDK then pushes them to the exporter pipeline.
 */
var BatchSpanProcessorBase = /** @class */ (function () {
    function BatchSpanProcessorBase(_exporter, config) {
        this._exporter = _exporter;
        this._finishedSpans = [];
        var env = getEnv();
        this._maxExportBatchSize =
            typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number'
                ? config.maxExportBatchSize
                : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize =
            typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number'
                ? config.maxQueueSize
                : env.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis =
            typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number'
                ? config.scheduledDelayMillis
                : env.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis =
            typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number'
                ? config.exportTimeoutMillis
                : env.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
        if (this._maxExportBatchSize > this._maxQueueSize) {
            esm_diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');
            this._maxExportBatchSize = this._maxQueueSize;
        }
    }
    BatchSpanProcessorBase.prototype.forceFlush = function () {
        if (this._shutdownOnce.isCalled) {
            return this._shutdownOnce.promise;
        }
        return this._flushAll();
    };
    // does nothing.
    BatchSpanProcessorBase.prototype.onStart = function (_span, _parentContext) { };
    BatchSpanProcessorBase.prototype.onEnd = function (span) {
        if (this._shutdownOnce.isCalled) {
            return;
        }
        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
            return;
        }
        this._addToBuffer(span);
    };
    BatchSpanProcessorBase.prototype.shutdown = function () {
        return this._shutdownOnce.call();
    };
    BatchSpanProcessorBase.prototype._shutdown = function () {
        var _this = this;
        return Promise.resolve()
            .then(function () {
            return _this.onShutdown();
        })
            .then(function () {
            return _this._flushAll();
        })
            .then(function () {
            return _this._exporter.shutdown();
        });
    };
    /** Add a span in the buffer. */
    BatchSpanProcessorBase.prototype._addToBuffer = function (span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
            // limit reached, drop span
            return;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
    };
    /**
     * Send all spans to the exporter respecting the batch size limit
     * This function is used only on forceFlush or shutdown,
     * for all other cases _flush should be used
     * */
    BatchSpanProcessorBase.prototype._flushAll = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var promises = [];
            // calculate number of batches
            var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
            for (var i = 0, j = count; i < j; i++) {
                promises.push(_this._flushOneBatch());
            }
            Promise.all(promises)
                .then(function () {
                resolve();
            })
                .catch(reject);
        });
    };
    BatchSpanProcessorBase.prototype._flushOneBatch = function () {
        var _this = this;
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
            return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
            var timer = setTimeout(function () {
                // don't wait anymore for export, this way the next batch can start
                reject(new Error('Timeout'));
            }, _this._exportTimeoutMillis);
            // prevent downstream exporter calls from generating spans
            esm_context["with"](suppressTracing(esm_context.active()), function () {
                // Reset the finished spans buffer here because the next invocations of the _flush method
                // could pass the same finished spans to the exporter if the buffer is cleared
                // outside of the execution of this callback.
                _this._exporter.export(_this._finishedSpans.splice(0, _this._maxExportBatchSize), function (result) {
                    var _a;
                    clearTimeout(timer);
                    if (result.code === ExportResultCode.SUCCESS) {
                        resolve();
                    }
                    else {
                        reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));
                    }
                });
            });
        });
    };
    BatchSpanProcessorBase.prototype._maybeStartTimer = function () {
        var _this = this;
        if (this._timer !== undefined)
            return;
        this._timer = setTimeout(function () {
            _this._flushOneBatch()
                .then(function () {
                if (_this._finishedSpans.length > 0) {
                    _this._clearTimer();
                    _this._maybeStartTimer();
                }
            })
                .catch(function (e) {
                globalErrorHandler(e);
            });
        }, this._scheduledDelayMillis);
        unrefTimer(this._timer);
    };
    BatchSpanProcessorBase.prototype._clearTimer = function () {
        if (this._timer !== undefined) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
    };
    return BatchSpanProcessorBase;
}());

//# sourceMappingURL=BatchSpanProcessorBase.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/browser/export/BatchSpanProcessor.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BatchSpanProcessor_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var BatchSpanProcessor = /** @class */ (function (_super) {
    BatchSpanProcessor_extends(BatchSpanProcessor, _super);
    function BatchSpanProcessor(_exporter, config) {
        var _this = _super.call(this, _exporter, config) || this;
        _this.onInit(config);
        return _this;
    }
    BatchSpanProcessor.prototype.onInit = function (config) {
        var _this = this;
        if ((config === null || config === void 0 ? void 0 : config.disableAutoFlushOnDocumentHide) !== true && typeof document !== 'undefined') {
            this._visibilityChangeListener = function () {
                if (document.visibilityState === 'hidden') {
                    void _this.forceFlush();
                }
            };
            this._pageHideListener = function () {
                void _this.forceFlush();
            };
            document.addEventListener('visibilitychange', this._visibilityChangeListener);
            // use 'pagehide' event as a fallback for Safari; see https://bugs.webkit.org/show_bug.cgi?id=116769
            document.addEventListener('pagehide', this._pageHideListener);
        }
    };
    BatchSpanProcessor.prototype.onShutdown = function () {
        if (typeof document !== 'undefined') {
            if (this._visibilityChangeListener) {
                document.removeEventListener('visibilitychange', this._visibilityChangeListener);
            }
            if (this._pageHideListener) {
                document.removeEventListener('pagehide', this._pageHideListener);
            }
        }
    };
    return BatchSpanProcessor;
}(BatchSpanProcessorBase));

//# sourceMappingURL=BatchSpanProcessor.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * based on lodash in order to support esm builds without esModuleInterop.
 * lodash is using MIT License.
 **/
var objectTag = '[object Object]';
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
var objectCtorString = funcToString.call(Object);
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectProto = Object.prototype;
var lodash_merge_hasOwnProperty = objectProto.hasOwnProperty;
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
var nativeObjectToString = objectProto.toString;
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function lodash_merge_isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = lodash_merge_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) === objectCtorString;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
    var isOwn = lodash_merge_hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    var unmasked = false;
    try {
        value[symToStringTag] = undefined;
        unmasked = true;
    }
    catch (e) {
        // silence
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        }
        else {
            delete value[symToStringTag];
        }
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
    return nativeObjectToString.call(value);
}
//# sourceMappingURL=lodash.merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/utils/merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */

var MAX_LEVEL = 20;
/**
 * Merges objects together
 * @param args - objects / values to be merged
 */
function merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var result = args.shift();
    var objects = new WeakMap();
    while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
}
function takeValue(value) {
    if (isArray(value)) {
        return value.slice();
    }
    return value;
}
/**
 * Merges two objects
 * @param one - first object
 * @param two - second object
 * @param level - current deep level
 * @param objects - objects holder that has been already referenced - to prevent
 * cyclic dependency
 */
function mergeTwoObjects(one, two, level, objects) {
    if (level === void 0) { level = 0; }
    var result;
    if (level > MAX_LEVEL) {
        return undefined;
    }
    level++;
    if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
    }
    else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
            for (var i = 0, j = two.length; i < j; i++) {
                result.push(takeValue(two[i]));
            }
        }
        else if (isObject(two)) {
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                result[key] = takeValue(two[key]);
            }
        }
    }
    else if (isObject(one)) {
        if (isObject(two)) {
            if (!shouldMerge(one, two)) {
                return two;
            }
            result = Object.assign({}, one);
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                var twoValue = two[key];
                if (isPrimitive(twoValue)) {
                    if (typeof twoValue === 'undefined') {
                        delete result[key];
                    }
                    else {
                        // result[key] = takeValue(twoValue);
                        result[key] = twoValue;
                    }
                }
                else {
                    var obj1 = result[key];
                    var obj2 = twoValue;
                    if (wasObjectReferenced(one, key, objects) ||
                        wasObjectReferenced(two, key, objects)) {
                        delete result[key];
                    }
                    else {
                        if (isObject(obj1) && isObject(obj2)) {
                            var arr1 = objects.get(obj1) || [];
                            var arr2 = objects.get(obj2) || [];
                            arr1.push({ obj: one, key: key });
                            arr2.push({ obj: two, key: key });
                            objects.set(obj1, arr1);
                            objects.set(obj2, arr2);
                        }
                        result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
                    }
                }
            }
        }
        else {
            result = two;
        }
    }
    return result;
}
/**
 * Function to check if object has been already reference
 * @param obj
 * @param key
 * @param objects
 */
function wasObjectReferenced(obj, key, objects) {
    var arr = objects.get(obj[key]) || [];
    for (var i = 0, j = arr.length; i < j; i++) {
        var info = arr[i];
        if (info.key === key && info.obj === obj) {
            return true;
        }
    }
    return false;
}
function isArray(value) {
    return Array.isArray(value);
}
function isFunction(value) {
    return typeof value === 'function';
}
function isObject(value) {
    return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === 'object';
}
function isPrimitive(value) {
    return typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean' ||
        typeof value === 'undefined' ||
        value instanceof Date ||
        value instanceof RegExp ||
        value === null;
}
function shouldMerge(one, two) {
    if (!lodash_merge_isPlainObject(one) || !lodash_merge_isPlainObject(two)) {
        return false;
    }
    return true;
}
//# sourceMappingURL=merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/propagation/composite.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var composite_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

/** Combines multiple propagators into a single propagator. */
var CompositePropagator = /** @class */ (function () {
    /**
     * Construct a composite propagator from a list of propagators.
     *
     * @param [config] Configuration object for composite propagator
     */
    function CompositePropagator(config) {
        if (config === void 0) { config = {}; }
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators
            // older propagators may not have fields function, null check to be sure
            .map(function (p) { return (typeof p.fields === 'function' ? p.fields() : []); })
            .reduce(function (x, y) { return x.concat(y); }, [])));
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same carrier key, the propagator later in the list
     * will "win".
     *
     * @param context Context to inject
     * @param carrier Carrier into which context will be injected
     */
    CompositePropagator.prototype.inject = function (context, carrier, setter) {
        var e_1, _a;
        try {
            for (var _b = composite_values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propagator = _c.value;
                try {
                    propagator.inject(context, carrier, setter);
                }
                catch (err) {
                    esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same context key, the propagator later in the list
     * will "win".
     *
     * @param context Context to add values to
     * @param carrier Carrier from which to extract context
     */
    CompositePropagator.prototype.extract = function (context, carrier, getter) {
        return this._propagators.reduce(function (ctx, propagator) {
            try {
                return propagator.extract(ctx, carrier, getter);
            }
            catch (err) {
                esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
            return ctx;
        }, context);
    };
    CompositePropagator.prototype.fields = function () {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
    };
    return CompositePropagator;
}());

//# sourceMappingURL=composite.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/internal/validators.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var validators_VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var validators_VALID_KEY = "[a-z]" + validators_VALID_KEY_CHAR_RANGE + "{0,255}";
var validators_VALID_VENDOR_KEY = "[a-z0-9]" + validators_VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + validators_VALID_KEY_CHAR_RANGE + "{0,13}";
var validators_VALID_KEY_REGEX = new RegExp("^(?:" + validators_VALID_KEY + "|" + validators_VALID_VENDOR_KEY + ")$");
var validators_VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var validators_INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */
function validators_validateKey(key) {
    return validators_VALID_KEY_REGEX.test(key);
}
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */
function validators_validateValue(value) {
    return (validators_VALID_VALUE_BASE_REGEX.test(value) &&
        !validators_INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));
}
//# sourceMappingURL=validators.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/trace/TraceState.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TraceState_MAX_TRACE_STATE_ITEMS = 32;
var TraceState_MAX_TRACE_STATE_LEN = 512;
var TraceState_LIST_MEMBERS_SEPARATOR = ',';
var TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */
var TraceState = /** @class */ (function () {
    function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState)
            this._parse(rawTraceState);
    }
    TraceState.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
            traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceState.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceState.prototype.get = function (key) {
        return this._internalState.get(key);
    };
    TraceState.prototype.serialize = function () {
        var _this = this;
        return this._keys()
            .reduce(function (agg, key) {
            agg.push(key + TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, [])
            .join(TraceState_LIST_MEMBERS_SEPARATOR);
    };
    TraceState.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > TraceState_MAX_TRACE_STATE_LEN)
            return;
        this._internalState = rawTraceState
            .split(TraceState_LIST_MEMBERS_SEPARATOR)
            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
            .reduce(function (agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if (validators_validateKey(key) && validators_validateValue(value)) {
                    agg.set(key, value);
                }
                else {
                    // TODO: Consider to add warning log
                }
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > TraceState_MAX_TRACE_STATE_ITEMS) {
            this._internalState = new Map(Array.from(this._internalState.entries())
                .reverse() // Use reverse same as original tracestate parse chain
                .slice(0, TraceState_MAX_TRACE_STATE_ITEMS));
        }
    };
    TraceState.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceState.prototype._clone = function () {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceState;
}());

//# sourceMappingURL=TraceState.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var TRACE_PARENT_HEADER = 'traceparent';
var TRACE_STATE_HEADER = 'tracestate';
var W3CTraceContextPropagator_VERSION = '00';
var VERSION_PART = '(?!ff)[\\da-f]{2}';
var TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
var PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
var FLAGS_PART = '[\\da-f]{2}';
var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */
function parseTraceParent(traceParent) {
    var match = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
        return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5])
        return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16),
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */
var W3CTraceContextPropagator = /** @class */ (function () {
    function W3CTraceContextPropagator() {
    }
    W3CTraceContextPropagator.prototype.inject = function (context, carrier, setter) {
        var spanContext = trace.getSpanContext(context);
        if (!spanContext ||
            isTracingSuppressed(context) ||
            !isSpanContextValid(spanContext))
            return;
        var traceParent = W3CTraceContextPropagator_VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
            setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
    };
    W3CTraceContextPropagator.prototype.extract = function (context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader)
            return context;
        var traceParent = Array.isArray(traceParentHeader)
            ? traceParentHeader[0]
            : traceParentHeader;
        if (typeof traceParent !== 'string')
            return context;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext)
            return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            var state = Array.isArray(traceStateHeader)
                ? traceStateHeader.join(',')
                : traceStateHeader;
            spanContext.traceState = new TraceState(typeof state === 'string' ? state : undefined);
        }
        return trace.setSpanContext(context, spanContext);
    };
    W3CTraceContextPropagator.prototype.fields = function () {
        return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
    };
    return W3CTraceContextPropagator;
}());

//# sourceMappingURL=W3CTraceContextPropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/baggage/constants.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var BAGGAGE_PROPERTIES_SEPARATOR = ';';
var constants_BAGGAGE_ITEMS_SEPARATOR = ',';
// Name of the http header used to propagate the baggage
var BAGGAGE_HEADER = 'baggage';
// Maximum number of name-value pairs allowed by w3c spec
var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
// Maximum number of bytes per a single name-value pair allowed by w3c spec
var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
// Maximum total length of all name-value pairs allowed by w3c spec
var BAGGAGE_MAX_TOTAL_LENGTH = 8192;
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/baggage/utils.js
var utils_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function (hValue, current) {
        var value = "" + hValue + (hValue !== '' ? constants_BAGGAGE_ITEMS_SEPARATOR : '') + current;
        return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, '');
}
function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function (_a) {
        var _b = utils_read(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) {
            entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
    });
}
function parsePairKeyValue(entry) {
    var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
        return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart)
        return;
    var keyPair = keyPairPart.split(BAGGAGE_KEY_PAIR_SEPARATOR);
    if (keyPair.length !== 2)
        return;
    var key = decodeURIComponent(keyPair[0].trim());
    var value = decodeURIComponent(keyPair[1].trim());
    var metadata;
    if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key: key, value: value, metadata: metadata };
}
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */
function parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0)
        return {};
    return value
        .split(BAGGAGE_ITEMS_SEPARATOR)
        .map(function (entry) {
        return parsePairKeyValue(entry);
    })
        .filter(function (keyPair) { return keyPair !== undefined && keyPair.value.length > 0; })
        .reduce(function (headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Propagates {@link Baggage} through Context format propagation.
 *
 * Based on the Baggage specification:
 * https://w3c.github.io/baggage/
 */
var W3CBaggagePropagator = /** @class */ (function () {
    function W3CBaggagePropagator() {
    }
    W3CBaggagePropagator.prototype.inject = function (context, carrier, setter) {
        var baggage = propagation.getBaggage(context);
        if (!baggage || isTracingSuppressed(context))
            return;
        var keyPairs = getKeyPairs(baggage)
            .filter(function (pair) {
            return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        })
            .slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
            setter.set(carrier, BAGGAGE_HEADER, headerValue);
        }
    };
    W3CBaggagePropagator.prototype.extract = function (context, carrier, getter) {
        var headerValue = getter.get(carrier, BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(constants_BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
            return context;
        var baggage = {};
        if (baggageString.length === 0) {
            return context;
        }
        var pairs = baggageString.split(constants_BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function (entry) {
            var keyPair = parsePairKeyValue(entry);
            if (keyPair) {
                var baggageEntry = { value: keyPair.value };
                if (keyPair.metadata) {
                    baggageEntry.metadata = keyPair.metadata;
                }
                baggage[keyPair.key] = baggageEntry;
            }
        });
        if (Object.entries(baggage).length === 0) {
            return context;
        }
        return propagation.setBaggage(context, propagation.createBaggage(baggage));
    };
    W3CBaggagePropagator.prototype.fields = function () {
        return [BAGGAGE_HEADER];
    };
    return W3CBaggagePropagator;
}());

//# sourceMappingURL=W3CBaggagePropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/common/attributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var attributes_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var attributes_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

function sanitizeAttributes(attributes) {
    var e_1, _a;
    var out = {};
    if (typeof attributes !== 'object' || attributes == null) {
        return out;
    }
    try {
        for (var _b = attributes_values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = attributes_read(_c.value, 2), key = _d[0], val = _d[1];
            if (!isAttributeKey(key)) {
                esm_diag.warn("Invalid attribute key: " + key);
                continue;
            }
            if (!isAttributeValue(val)) {
                esm_diag.warn("Invalid attribute value set for key: " + key);
                continue;
            }
            if (Array.isArray(val)) {
                out[key] = val.slice();
            }
            else {
                out[key] = val;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return out;
}
function isAttributeKey(key) {
    return typeof key === 'string' && key.length > 0;
}
function isAttributeValue(val) {
    if (val == null) {
        return true;
    }
    if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
    }
    return isValidPrimitiveAttributeValue(val);
}
function isHomogeneousAttributeValueArray(arr) {
    var e_2, _a;
    var type;
    try {
        for (var arr_1 = attributes_values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var element = arr_1_1.value;
            // null/undefined elements are allowed
            if (element == null)
                continue;
            if (!type) {
                if (isValidPrimitiveAttributeValue(element)) {
                    type = typeof element;
                    continue;
                }
                // encountered an invalid primitive
                return false;
            }
            if (typeof element === type) {
                continue;
            }
            return false;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return true;
}
function isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
        case 'number':
        case 'boolean':
        case 'string':
            return true;
    }
    return false;
}
//# sourceMappingURL=attributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/platform/browser/performance.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var otperformance = performance;
//# sourceMappingURL=performance.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/core/build/esm/common/time.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var NANOSECOND_DIGITS = 9;
var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
/**
 * Converts a number to HrTime, HrTime = [number, number].
 * The first number is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * numberToHrtime calculates the first number by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * numberToHrtime calculates the second number by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * SECOND_TO_NANOSECONDS = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 * @param epochMillis
 */
function numberToHrtime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Number((epochSeconds - seconds).toFixed(NANOSECOND_DIGITS)) *
        SECOND_TO_NANOSECONDS;
    return [seconds, nanos];
}
function getTimeOrigin() {
    var timeOrigin = otperformance.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function hrTime(performanceNow) {
    var timeOrigin = numberToHrtime(getTimeOrigin());
    var now = numberToHrtime(typeof performanceNow === 'number' ? performanceNow : otperformance.now());
    var seconds = timeOrigin[0] + now[0];
    var nanos = timeOrigin[1] + now[1];
    // Nanoseconds
    if (nanos > SECOND_TO_NANOSECONDS) {
        nanos -= SECOND_TO_NANOSECONDS;
        seconds += 1;
    }
    return [seconds, nanos];
}
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */
function timeInputToHrTime(time) {
    // process.hrtime
    if (isTimeInputHrTime(time)) {
        return time;
    }
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < getTimeOrigin()) {
            return hrTime(time);
        }
        else {
            // epoch milliseconds or performance.timeOrigin
            return numberToHrtime(time);
        }
    }
    else if (time instanceof Date) {
        return numberToHrtime(time.getTime());
    }
    else {
        throw TypeError('Invalid input type');
    }
}
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */
function hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
}
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */
function hrTimeToTimeStamp(time) {
    var precision = NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substr(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */
function time_hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
}
/**
 * Convert hrTime to milliseconds.
 * @param time
 */
function hrTimeToMilliseconds(time) {
    return Math.round(time[0] * 1e3 + time[1] / 1e6);
}
/**
 * Convert hrTime to microseconds.
 * @param time
 */
function hrTimeToMicroseconds(time) {
    return Math.round(time[0] * 1e6 + time[1] / 1e3);
}
/**
 * check if time is HrTime
 * @param value
 */
function isTimeInputHrTime(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        typeof value[0] === 'number' &&
        typeof value[1] === 'number');
}
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */
function isTimeInput(value) {
    return (isTimeInputHrTime(value) ||
        typeof value === 'number' ||
        value instanceof Date);
}
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var SemanticAttributes = {
    /**
    * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
    *
    * Note: This may be different from `faas.id` if an alias is involved.
    */
    AWS_LAMBDA_INVOKED_ARN: 'aws.lambda.invoked_arn',
    /**
    * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
    */
    DB_SYSTEM: 'db.system',
    /**
    * The connection string used to connect to the database. It is recommended to remove embedded credentials.
    */
    DB_CONNECTION_STRING: 'db.connection_string',
    /**
    * Username for accessing the database.
    */
    DB_USER: 'db.user',
    /**
    * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
    */
    DB_JDBC_DRIVER_CLASSNAME: 'db.jdbc.driver_classname',
    /**
    * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
    *
    * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
    */
    DB_NAME: 'db.name',
    /**
    * The database statement being executed.
    *
    * Note: The value may be sanitized to exclude sensitive information.
    */
    DB_STATEMENT: 'db.statement',
    /**
    * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
    *
    * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
    */
    DB_OPERATION: 'db.operation',
    /**
    * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
    *
    * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
    */
    DB_MSSQL_INSTANCE_NAME: 'db.mssql.instance_name',
    /**
    * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_CASSANDRA_KEYSPACE: 'db.cassandra.keyspace',
    /**
    * The fetch size used for paging, i.e. how many rows will be returned at once.
    */
    DB_CASSANDRA_PAGE_SIZE: 'db.cassandra.page_size',
    /**
    * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
    */
    DB_CASSANDRA_CONSISTENCY_LEVEL: 'db.cassandra.consistency_level',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_CASSANDRA_TABLE: 'db.cassandra.table',
    /**
    * Whether or not the query is idempotent.
    */
    DB_CASSANDRA_IDEMPOTENCE: 'db.cassandra.idempotence',
    /**
    * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
    */
    DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: 'db.cassandra.speculative_execution_count',
    /**
    * The ID of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_ID: 'db.cassandra.coordinator.id',
    /**
    * The data center of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_DC: 'db.cassandra.coordinator.dc',
    /**
    * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_HBASE_NAMESPACE: 'db.hbase.namespace',
    /**
    * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
    */
    DB_REDIS_DATABASE_INDEX: 'db.redis.database_index',
    /**
    * The collection being accessed within the database stated in `db.name`.
    */
    DB_MONGODB_COLLECTION: 'db.mongodb.collection',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_SQL_TABLE: 'db.sql.table',
    /**
    * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
    */
    EXCEPTION_TYPE: 'exception.type',
    /**
    * The exception message.
    */
    EXCEPTION_MESSAGE: 'exception.message',
    /**
    * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
    */
    EXCEPTION_STACKTRACE: 'exception.stacktrace',
    /**
    * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
    *
    * Note: An exception is considered to have escaped (or left) the scope of a span,
  if that span is ended while the exception is still logically &#34;in flight&#34;.
  This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
  is passed to a Context manager&#39;s `__exit__` method in Python) but will
  usually be caught at the point of recording the exception in most languages.
  
  It is usually not possible to determine at the point where an exception is thrown
  whether it will escape the scope of a span.
  However, it is trivial to know that an exception
  will escape, if one checks for an active exception just before ending the span,
  as done in the [example above](#exception-end-example).
  
  It follows that an exception may still escape the scope of the span
  even if the `exception.escaped` attribute was not set or set to false,
  since the event might have been recorded at a time where it was not
  clear whether the exception will escape.
    */
    EXCEPTION_ESCAPED: 'exception.escaped',
    /**
    * Type of the trigger on which the function is executed.
    */
    FAAS_TRIGGER: 'faas.trigger',
    /**
    * The execution ID of the current function execution.
    */
    FAAS_EXECUTION: 'faas.execution',
    /**
    * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
    */
    FAAS_DOCUMENT_COLLECTION: 'faas.document.collection',
    /**
    * Describes the type of the operation that was performed on the data.
    */
    FAAS_DOCUMENT_OPERATION: 'faas.document.operation',
    /**
    * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_DOCUMENT_TIME: 'faas.document.time',
    /**
    * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
    */
    FAAS_DOCUMENT_NAME: 'faas.document.name',
    /**
    * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_TIME: 'faas.time',
    /**
    * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
    */
    FAAS_CRON: 'faas.cron',
    /**
    * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
    */
    FAAS_COLDSTART: 'faas.coldstart',
    /**
    * The name of the invoked function.
    *
    * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
    */
    FAAS_INVOKED_NAME: 'faas.invoked_name',
    /**
    * The cloud provider of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
    */
    FAAS_INVOKED_PROVIDER: 'faas.invoked_provider',
    /**
    * The cloud region of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
    */
    FAAS_INVOKED_REGION: 'faas.invoked_region',
    /**
    * Transport protocol used. See note below.
    */
    NET_TRANSPORT: 'net.transport',
    /**
    * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
    */
    NET_PEER_IP: 'net.peer.ip',
    /**
    * Remote port number.
    */
    NET_PEER_PORT: 'net.peer.port',
    /**
    * Remote hostname or similar, see note below.
    */
    NET_PEER_NAME: 'net.peer.name',
    /**
    * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
    */
    NET_HOST_IP: 'net.host.ip',
    /**
    * Like `net.peer.port` but for the host port.
    */
    NET_HOST_PORT: 'net.host.port',
    /**
    * Local hostname or similar, see note below.
    */
    NET_HOST_NAME: 'net.host.name',
    /**
    * The internet connection type currently being used by the host.
    */
    NET_HOST_CONNECTION_TYPE: 'net.host.connection.type',
    /**
    * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
    */
    NET_HOST_CONNECTION_SUBTYPE: 'net.host.connection.subtype',
    /**
    * The name of the mobile carrier.
    */
    NET_HOST_CARRIER_NAME: 'net.host.carrier.name',
    /**
    * The mobile carrier country code.
    */
    NET_HOST_CARRIER_MCC: 'net.host.carrier.mcc',
    /**
    * The mobile carrier network code.
    */
    NET_HOST_CARRIER_MNC: 'net.host.carrier.mnc',
    /**
    * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
    */
    NET_HOST_CARRIER_ICC: 'net.host.carrier.icc',
    /**
    * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
    */
    PEER_SERVICE: 'peer.service',
    /**
    * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
    */
    ENDUSER_ID: 'enduser.id',
    /**
    * Actual/assumed role the client is making the request under extracted from token or application security context.
    */
    ENDUSER_ROLE: 'enduser.role',
    /**
    * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
    */
    ENDUSER_SCOPE: 'enduser.scope',
    /**
    * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
    */
    THREAD_ID: 'thread.id',
    /**
    * Current thread name.
    */
    THREAD_NAME: 'thread.name',
    /**
    * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
    */
    CODE_FUNCTION: 'code.function',
    /**
    * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
    */
    CODE_NAMESPACE: 'code.namespace',
    /**
    * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
    */
    CODE_FILEPATH: 'code.filepath',
    /**
    * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
    */
    CODE_LINENO: 'code.lineno',
    /**
    * HTTP request method.
    */
    HTTP_METHOD: 'http.method',
    /**
    * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
    *
    * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
    */
    HTTP_URL: 'http.url',
    /**
    * The full request target as passed in a HTTP request line or equivalent.
    */
    HTTP_TARGET: 'http.target',
    /**
    * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
    *
    * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
    */
    HTTP_HOST: 'http.host',
    /**
    * The URI scheme identifying the used protocol.
    */
    HTTP_SCHEME: 'http.scheme',
    /**
    * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
    */
    HTTP_STATUS_CODE: 'http.status_code',
    /**
    * Kind of HTTP protocol used.
    *
    * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
    */
    HTTP_FLAVOR: 'http.flavor',
    /**
    * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
    */
    HTTP_USER_AGENT: 'http.user_agent',
    /**
    * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_REQUEST_CONTENT_LENGTH: 'http.request_content_length',
    /**
    * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: 'http.request_content_length_uncompressed',
    /**
    * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_RESPONSE_CONTENT_LENGTH: 'http.response_content_length',
    /**
    * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: 'http.response_content_length_uncompressed',
    /**
    * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
    *
    * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
    */
    HTTP_SERVER_NAME: 'http.server_name',
    /**
    * The matched route (path template).
    */
    HTTP_ROUTE: 'http.route',
    /**
    * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
    *
    * Note: This is not necessarily the same as `net.peer.ip`, which would
  identify the network-level peer, which may be a proxy.
  
  This attribute should be set when a source of information different
  from the one used for `net.peer.ip`, is available even if that other
  source just confirms the same value as `net.peer.ip`.
  Rationale: For `net.peer.ip`, one typically does not know if it
  comes from a proxy, reverse proxy, or the actual client. Setting
  `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
  one is at least somewhat confident that the address is not that of
  the closest proxy.
    */
    HTTP_CLIENT_IP: 'http.client_ip',
    /**
    * The keys in the `RequestItems` object field.
    */
    AWS_DYNAMODB_TABLE_NAMES: 'aws.dynamodb.table_names',
    /**
    * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
    */
    AWS_DYNAMODB_CONSUMED_CAPACITY: 'aws.dynamodb.consumed_capacity',
    /**
    * The JSON-serialized value of the `ItemCollectionMetrics` response field.
    */
    AWS_DYNAMODB_ITEM_COLLECTION_METRICS: 'aws.dynamodb.item_collection_metrics',
    /**
    * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: 'aws.dynamodb.provisioned_read_capacity',
    /**
    * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: 'aws.dynamodb.provisioned_write_capacity',
    /**
    * The value of the `ConsistentRead` request parameter.
    */
    AWS_DYNAMODB_CONSISTENT_READ: 'aws.dynamodb.consistent_read',
    /**
    * The value of the `ProjectionExpression` request parameter.
    */
    AWS_DYNAMODB_PROJECTION: 'aws.dynamodb.projection',
    /**
    * The value of the `Limit` request parameter.
    */
    AWS_DYNAMODB_LIMIT: 'aws.dynamodb.limit',
    /**
    * The value of the `AttributesToGet` request parameter.
    */
    AWS_DYNAMODB_ATTRIBUTES_TO_GET: 'aws.dynamodb.attributes_to_get',
    /**
    * The value of the `IndexName` request parameter.
    */
    AWS_DYNAMODB_INDEX_NAME: 'aws.dynamodb.index_name',
    /**
    * The value of the `Select` request parameter.
    */
    AWS_DYNAMODB_SELECT: 'aws.dynamodb.select',
    /**
    * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: 'aws.dynamodb.global_secondary_indexes',
    /**
    * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: 'aws.dynamodb.local_secondary_indexes',
    /**
    * The value of the `ExclusiveStartTableName` request parameter.
    */
    AWS_DYNAMODB_EXCLUSIVE_START_TABLE: 'aws.dynamodb.exclusive_start_table',
    /**
    * The the number of items in the `TableNames` response parameter.
    */
    AWS_DYNAMODB_TABLE_COUNT: 'aws.dynamodb.table_count',
    /**
    * The value of the `ScanIndexForward` request parameter.
    */
    AWS_DYNAMODB_SCAN_FORWARD: 'aws.dynamodb.scan_forward',
    /**
    * The value of the `Segment` request parameter.
    */
    AWS_DYNAMODB_SEGMENT: 'aws.dynamodb.segment',
    /**
    * The value of the `TotalSegments` request parameter.
    */
    AWS_DYNAMODB_TOTAL_SEGMENTS: 'aws.dynamodb.total_segments',
    /**
    * The value of the `Count` response parameter.
    */
    AWS_DYNAMODB_COUNT: 'aws.dynamodb.count',
    /**
    * The value of the `ScannedCount` response parameter.
    */
    AWS_DYNAMODB_SCANNED_COUNT: 'aws.dynamodb.scanned_count',
    /**
    * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
    */
    AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: 'aws.dynamodb.attribute_definitions',
    /**
    * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: 'aws.dynamodb.global_secondary_index_updates',
    /**
    * A string identifying the messaging system.
    */
    MESSAGING_SYSTEM: 'messaging.system',
    /**
    * The message destination name. This might be equal to the span name but is required nevertheless.
    */
    MESSAGING_DESTINATION: 'messaging.destination',
    /**
    * The kind of message destination.
    */
    MESSAGING_DESTINATION_KIND: 'messaging.destination_kind',
    /**
    * A boolean that is true if the message destination is temporary.
    */
    MESSAGING_TEMP_DESTINATION: 'messaging.temp_destination',
    /**
    * The name of the transport protocol.
    */
    MESSAGING_PROTOCOL: 'messaging.protocol',
    /**
    * The version of the transport protocol.
    */
    MESSAGING_PROTOCOL_VERSION: 'messaging.protocol_version',
    /**
    * Connection string.
    */
    MESSAGING_URL: 'messaging.url',
    /**
    * A value used by the messaging system as an identifier for the message, represented as a string.
    */
    MESSAGING_MESSAGE_ID: 'messaging.message_id',
    /**
    * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
    */
    MESSAGING_CONVERSATION_ID: 'messaging.conversation_id',
    /**
    * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
    */
    MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: 'messaging.message_payload_size_bytes',
    /**
    * The compressed size of the message payload in bytes.
    */
    MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: 'messaging.message_payload_compressed_size_bytes',
    /**
    * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
    */
    MESSAGING_OPERATION: 'messaging.operation',
    /**
    * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
    */
    MESSAGING_CONSUMER_ID: 'messaging.consumer_id',
    /**
    * RabbitMQ message routing key.
    */
    MESSAGING_RABBITMQ_ROUTING_KEY: 'messaging.rabbitmq.routing_key',
    /**
    * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
    *
    * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
    */
    MESSAGING_KAFKA_MESSAGE_KEY: 'messaging.kafka.message_key',
    /**
    * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
    */
    MESSAGING_KAFKA_CONSUMER_GROUP: 'messaging.kafka.consumer_group',
    /**
    * Client Id for the Consumer or Producer that is handling the message.
    */
    MESSAGING_KAFKA_CLIENT_ID: 'messaging.kafka.client_id',
    /**
    * Partition the message is sent to.
    */
    MESSAGING_KAFKA_PARTITION: 'messaging.kafka.partition',
    /**
    * A boolean that is true if the message is a tombstone.
    */
    MESSAGING_KAFKA_TOMBSTONE: 'messaging.kafka.tombstone',
    /**
    * A string identifying the remoting system.
    */
    RPC_SYSTEM: 'rpc.system',
    /**
    * The full (logical) name of the service being called, including its package name, if applicable.
    *
    * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
    */
    RPC_SERVICE: 'rpc.service',
    /**
    * The name of the (logical) method being called, must be equal to the $method part in the span name.
    *
    * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
    */
    RPC_METHOD: 'rpc.method',
    /**
    * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
    */
    RPC_GRPC_STATUS_CODE: 'rpc.grpc.status_code',
    /**
    * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
    */
    RPC_JSONRPC_VERSION: 'rpc.jsonrpc.version',
    /**
    * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
    */
    RPC_JSONRPC_REQUEST_ID: 'rpc.jsonrpc.request_id',
    /**
    * `error.code` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_CODE: 'rpc.jsonrpc.error_code',
    /**
    * `error.message` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_MESSAGE: 'rpc.jsonrpc.error_message',
    /**
    * Whether this is a received or sent message.
    */
    MESSAGE_TYPE: 'message.type',
    /**
    * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
    *
    * Note: This way we guarantee that the values will be consistent between different implementations.
    */
    MESSAGE_ID: 'message.id',
    /**
    * Compressed size of the message in bytes.
    */
    MESSAGE_COMPRESSED_SIZE: 'message.compressed_size',
    /**
    * Uncompressed size of the message in bytes.
    */
    MESSAGE_UNCOMPRESSED_SIZE: 'message.uncompressed_size',
};
var DbSystemValues = {
    /** Some other SQL database. Fallback only. See notes. */
    OTHER_SQL: 'other_sql',
    /** Microsoft SQL Server. */
    MSSQL: 'mssql',
    /** MySQL. */
    MYSQL: 'mysql',
    /** Oracle Database. */
    ORACLE: 'oracle',
    /** IBM Db2. */
    DB2: 'db2',
    /** PostgreSQL. */
    POSTGRESQL: 'postgresql',
    /** Amazon Redshift. */
    REDSHIFT: 'redshift',
    /** Apache Hive. */
    HIVE: 'hive',
    /** Cloudscape. */
    CLOUDSCAPE: 'cloudscape',
    /** HyperSQL DataBase. */
    HSQLDB: 'hsqldb',
    /** Progress Database. */
    PROGRESS: 'progress',
    /** SAP MaxDB. */
    MAXDB: 'maxdb',
    /** SAP HANA. */
    HANADB: 'hanadb',
    /** Ingres. */
    INGRES: 'ingres',
    /** FirstSQL. */
    FIRSTSQL: 'firstsql',
    /** EnterpriseDB. */
    EDB: 'edb',
    /** InterSystems Caché. */
    CACHE: 'cache',
    /** Adabas (Adaptable Database System). */
    ADABAS: 'adabas',
    /** Firebird. */
    FIREBIRD: 'firebird',
    /** Apache Derby. */
    DERBY: 'derby',
    /** FileMaker. */
    FILEMAKER: 'filemaker',
    /** Informix. */
    INFORMIX: 'informix',
    /** InstantDB. */
    INSTANTDB: 'instantdb',
    /** InterBase. */
    INTERBASE: 'interbase',
    /** MariaDB. */
    MARIADB: 'mariadb',
    /** Netezza. */
    NETEZZA: 'netezza',
    /** Pervasive PSQL. */
    PERVASIVE: 'pervasive',
    /** PointBase. */
    POINTBASE: 'pointbase',
    /** SQLite. */
    SQLITE: 'sqlite',
    /** Sybase. */
    SYBASE: 'sybase',
    /** Teradata. */
    TERADATA: 'teradata',
    /** Vertica. */
    VERTICA: 'vertica',
    /** H2. */
    H2: 'h2',
    /** ColdFusion IMQ. */
    COLDFUSION: 'coldfusion',
    /** Apache Cassandra. */
    CASSANDRA: 'cassandra',
    /** Apache HBase. */
    HBASE: 'hbase',
    /** MongoDB. */
    MONGODB: 'mongodb',
    /** Redis. */
    REDIS: 'redis',
    /** Couchbase. */
    COUCHBASE: 'couchbase',
    /** CouchDB. */
    COUCHDB: 'couchdb',
    /** Microsoft Azure Cosmos DB. */
    COSMOSDB: 'cosmosdb',
    /** Amazon DynamoDB. */
    DYNAMODB: 'dynamodb',
    /** Neo4j. */
    NEO4J: 'neo4j',
    /** Apache Geode. */
    GEODE: 'geode',
    /** Elasticsearch. */
    ELASTICSEARCH: 'elasticsearch',
    /** Memcached. */
    MEMCACHED: 'memcached',
    /** CockroachDB. */
    COCKROACHDB: 'cockroachdb',
};
var DbCassandraConsistencyLevelValues = {
    /** all. */
    ALL: 'all',
    /** each_quorum. */
    EACH_QUORUM: 'each_quorum',
    /** quorum. */
    QUORUM: 'quorum',
    /** local_quorum. */
    LOCAL_QUORUM: 'local_quorum',
    /** one. */
    ONE: 'one',
    /** two. */
    TWO: 'two',
    /** three. */
    THREE: 'three',
    /** local_one. */
    LOCAL_ONE: 'local_one',
    /** any. */
    ANY: 'any',
    /** serial. */
    SERIAL: 'serial',
    /** local_serial. */
    LOCAL_SERIAL: 'local_serial',
};
var FaasTriggerValues = {
    /** A response to some data source operation such as a database or filesystem read/write. */
    DATASOURCE: 'datasource',
    /** To provide an answer to an inbound HTTP request. */
    HTTP: 'http',
    /** A function is set to be executed when messages are sent to a messaging system. */
    PUBSUB: 'pubsub',
    /** A function is scheduled to be executed regularly. */
    TIMER: 'timer',
    /** If none of the others apply. */
    OTHER: 'other',
};
var FaasDocumentOperationValues = {
    /** When a new object is created. */
    INSERT: 'insert',
    /** When an object is modified. */
    EDIT: 'edit',
    /** When an object is deleted. */
    DELETE: 'delete',
};
var FaasInvokedProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var NetTransportValues = {
    /** ip_tcp. */
    IP_TCP: 'ip_tcp',
    /** ip_udp. */
    IP_UDP: 'ip_udp',
    /** Another IP-based protocol. */
    IP: 'ip',
    /** Unix Domain socket. See below. */
    UNIX: 'unix',
    /** Named or anonymous pipe. See note below. */
    PIPE: 'pipe',
    /** In-process communication. */
    INPROC: 'inproc',
    /** Something else (non IP-based). */
    OTHER: 'other',
};
var NetHostConnectionTypeValues = {
    /** wifi. */
    WIFI: 'wifi',
    /** wired. */
    WIRED: 'wired',
    /** cell. */
    CELL: 'cell',
    /** unavailable. */
    UNAVAILABLE: 'unavailable',
    /** unknown. */
    UNKNOWN: 'unknown',
};
var NetHostConnectionSubtypeValues = {
    /** GPRS. */
    GPRS: 'gprs',
    /** EDGE. */
    EDGE: 'edge',
    /** UMTS. */
    UMTS: 'umts',
    /** CDMA. */
    CDMA: 'cdma',
    /** EVDO Rel. 0. */
    EVDO_0: 'evdo_0',
    /** EVDO Rev. A. */
    EVDO_A: 'evdo_a',
    /** CDMA2000 1XRTT. */
    CDMA2000_1XRTT: 'cdma2000_1xrtt',
    /** HSDPA. */
    HSDPA: 'hsdpa',
    /** HSUPA. */
    HSUPA: 'hsupa',
    /** HSPA. */
    HSPA: 'hspa',
    /** IDEN. */
    IDEN: 'iden',
    /** EVDO Rev. B. */
    EVDO_B: 'evdo_b',
    /** LTE. */
    LTE: 'lte',
    /** EHRPD. */
    EHRPD: 'ehrpd',
    /** HSPAP. */
    HSPAP: 'hspap',
    /** GSM. */
    GSM: 'gsm',
    /** TD-SCDMA. */
    TD_SCDMA: 'td_scdma',
    /** IWLAN. */
    IWLAN: 'iwlan',
    /** 5G NR (New Radio). */
    NR: 'nr',
    /** 5G NRNSA (New Radio Non-Standalone). */
    NRNSA: 'nrnsa',
    /** LTE CA. */
    LTE_CA: 'lte_ca',
};
var HttpFlavorValues = {
    /** HTTP 1.0. */
    HTTP_1_0: '1.0',
    /** HTTP 1.1. */
    HTTP_1_1: '1.1',
    /** HTTP 2. */
    HTTP_2_0: '2.0',
    /** SPDY protocol. */
    SPDY: 'SPDY',
    /** QUIC protocol. */
    QUIC: 'QUIC',
};
var MessagingDestinationKindValues = {
    /** A message sent to a queue. */
    QUEUE: 'queue',
    /** A message sent to a topic. */
    TOPIC: 'topic',
};
var MessagingOperationValues = {
    /** receive. */
    RECEIVE: 'receive',
    /** process. */
    PROCESS: 'process',
};
var RpcGrpcStatusCodeValues = {
    /** OK. */
    OK: 0,
    /** CANCELLED. */
    CANCELLED: 1,
    /** UNKNOWN. */
    UNKNOWN: 2,
    /** INVALID_ARGUMENT. */
    INVALID_ARGUMENT: 3,
    /** DEADLINE_EXCEEDED. */
    DEADLINE_EXCEEDED: 4,
    /** NOT_FOUND. */
    NOT_FOUND: 5,
    /** ALREADY_EXISTS. */
    ALREADY_EXISTS: 6,
    /** PERMISSION_DENIED. */
    PERMISSION_DENIED: 7,
    /** RESOURCE_EXHAUSTED. */
    RESOURCE_EXHAUSTED: 8,
    /** FAILED_PRECONDITION. */
    FAILED_PRECONDITION: 9,
    /** ABORTED. */
    ABORTED: 10,
    /** OUT_OF_RANGE. */
    OUT_OF_RANGE: 11,
    /** UNIMPLEMENTED. */
    UNIMPLEMENTED: 12,
    /** INTERNAL. */
    INTERNAL: 13,
    /** UNAVAILABLE. */
    UNAVAILABLE: 14,
    /** DATA_LOSS. */
    DATA_LOSS: 15,
    /** UNAUTHENTICATED. */
    UNAUTHENTICATED: 16,
};
var MessageTypeValues = {
    /** sent. */
    SENT: 'SENT',
    /** received. */
    RECEIVED: 'RECEIVED',
};
//# sourceMappingURL=SemanticAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/enums.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Event name definitions
var ExceptionEventName = 'exception';
//# sourceMappingURL=enums.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Span_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Span_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};




/**
 * This class represents a span.
 */
var Span = /** @class */ (function () {
    /**
     * Constructs a new Span instance.
     *
     * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.
     * */
    function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, clock) {
        if (links === void 0) { links = []; }
        if (clock === void 0) { clock = otperformance; }
        this.attributes = {};
        this.links = [];
        this.events = [];
        this.status = {
            code: SpanStatusCode.UNSET,
        };
        this.endTime = [0, 0];
        this._ended = false;
        this._duration = [-1, -1];
        this._clock = clock;
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        this.startTime = timeInputToHrTime(startTime !== null && startTime !== void 0 ? startTime : clock.now());
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context);
        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
    }
    Span.prototype.spanContext = function () {
        return this._spanContext;
    };
    Span.prototype.setAttribute = function (key, value) {
        if (value == null || this._isSpanEnded())
            return this;
        if (key.length === 0) {
            esm_diag.warn("Invalid attribute key: " + key);
            return this;
        }
        if (!isAttributeValue(value)) {
            esm_diag.warn("Invalid attribute value set for key: " + key);
            return this;
        }
        if (Object.keys(this.attributes).length >=
            this._spanLimits.attributeCountLimit &&
            !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
            return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
    };
    Span.prototype.setAttributes = function (attributes) {
        var e_1, _a;
        try {
            for (var _b = Span_values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = Span_read(_c.value, 2), k = _d[0], v = _d[1];
                this.setAttribute(k, v);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    /**
     *
     * @param name Span Name
     * @param [attributesOrStartTime] Span attributes or start time
     *     if type is {@type TimeInput} and 3rd param is undefined
     * @param [startTime] Specified start time for the event
     */
    Span.prototype.addEvent = function (name, attributesOrStartTime, startTime) {
        if (this._isSpanEnded())
            return this;
        if (this._spanLimits.eventCountLimit === 0) {
            esm_diag.warn('No events allowed.');
            return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
            esm_diag.warn('Dropping extra events.');
            this.events.shift();
        }
        if (isTimeInput(attributesOrStartTime)) {
            if (typeof startTime === 'undefined') {
                startTime = attributesOrStartTime;
            }
            attributesOrStartTime = undefined;
        }
        if (typeof startTime === 'undefined') {
            startTime = this._clock.now();
        }
        var attributes = sanitizeAttributes(attributesOrStartTime);
        this.events.push({
            name: name,
            attributes: attributes,
            time: timeInputToHrTime(startTime),
        });
        return this;
    };
    Span.prototype.setStatus = function (status) {
        if (this._isSpanEnded())
            return this;
        this.status = status;
        return this;
    };
    Span.prototype.updateName = function (name) {
        if (this._isSpanEnded())
            return this;
        this.name = name;
        return this;
    };
    Span.prototype.end = function (endTime) {
        if (this._isSpanEnded()) {
            esm_diag.error('You can only call end() on a span once.');
            return;
        }
        this._ended = true;
        this.endTime = timeInputToHrTime(endTime !== null && endTime !== void 0 ? endTime : this._clock.now());
        this._duration = hrTimeDuration(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
            esm_diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);
            this.endTime = this.startTime.slice();
            this._duration = [0, 0];
        }
        this._spanProcessor.onEnd(this);
    };
    Span.prototype.isRecording = function () {
        return this._ended === false;
    };
    Span.prototype.recordException = function (exception, time) {
        if (time === void 0) { time = this._clock.now(); }
        var attributes = {};
        if (typeof exception === 'string') {
            attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;
        }
        else if (exception) {
            if (exception.code) {
                attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();
            }
            else if (exception.name) {
                attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;
            }
            if (exception.message) {
                attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;
            }
            if (exception.stack) {
                attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;
            }
        }
        // these are minimum requirements from spec
        if (attributes[SemanticAttributes.EXCEPTION_TYPE] ||
            attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {
            this.addEvent(ExceptionEventName, attributes, time);
        }
        else {
            esm_diag.warn("Failed to record an exception " + exception);
        }
    };
    Object.defineProperty(Span.prototype, "duration", {
        get: function () {
            return this._duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "ended", {
        get: function () {
            return this._ended;
        },
        enumerable: false,
        configurable: true
    });
    Span.prototype._isSpanEnded = function () {
        if (this._ended) {
            esm_diag.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
        }
        return this._ended;
    };
    // Utility function to truncate given value within size
    // for value type of string, will truncate to given limit
    // for type of non-string, will return same value
    Span.prototype._truncateToLimitUtil = function (value, limit) {
        if (value.length <= limit) {
            return value;
        }
        return value.substr(0, limit);
    };
    /**
     * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then
     * return string with trucated to {@code attributeValueLengthLimit} characters
     *
     * If the given attribute value is array of strings then
     * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters
     *
     * Otherwise return same Attribute {@code value}
     *
     * @param value Attribute value
     * @returns truncated attribute value if required, otherwise same value
     */
    Span.prototype._truncateToSize = function (value) {
        var _this = this;
        var limit = this._attributeValueLengthLimit;
        // Check limit
        if (limit <= 0) {
            // Negative values are invalid, so do not truncate
            esm_diag.warn("Attribute value limit must be positive, got " + limit);
            return value;
        }
        // String
        if (typeof value === 'string') {
            return this._truncateToLimitUtil(value, limit);
        }
        // Array of strings
        if (Array.isArray(value)) {
            return value.map(function (val) { return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val; });
        }
        // Other types, no need to apply value length limit
        return value;
    };
    return Span;
}());

//# sourceMappingURL=Span.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/Sampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */
var Sampler_SamplingDecision;
(function (SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */
    SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */
    SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */
    SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(Sampler_SamplingDecision || (Sampler_SamplingDecision = {}));
//# sourceMappingURL=Sampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOffSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Sampler that samples no traces. */
var AlwaysOffSampler = /** @class */ (function () {
    function AlwaysOffSampler() {
    }
    AlwaysOffSampler.prototype.shouldSample = function () {
        return {
            decision: Sampler_SamplingDecision.NOT_RECORD,
        };
    };
    AlwaysOffSampler.prototype.toString = function () {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}());

//# sourceMappingURL=AlwaysOffSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOnSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Sampler that samples all traces. */
var AlwaysOnSampler = /** @class */ (function () {
    function AlwaysOnSampler() {
    }
    AlwaysOnSampler.prototype.shouldSample = function () {
        return {
            decision: Sampler_SamplingDecision.RECORD_AND_SAMPLED,
        };
    };
    AlwaysOnSampler.prototype.toString = function () {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}());

//# sourceMappingURL=AlwaysOnSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/ParentBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */
var ParentBasedSampler = /** @class */ (function () {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new AlwaysOnSampler();
        }
        this._remoteParentSampled =
            (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler();
        this._remoteParentNotSampled =
            (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler();
        this._localParentSampled =
            (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler();
        this._localParentNotSampled =
            (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler();
    }
    ParentBasedSampler.prototype.shouldSample = function (context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
            return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & TraceFlags.SAMPLED) {
                return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            }
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function () {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}());

//# sourceMappingURL=ParentBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/TraceIdRatioBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/** Sampler that samples a given fraction of traces based of trace id deterministically. */
var TraceIdRatioBasedSampler = /** @class */ (function () {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) { _ratio = 0; }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function (context, traceId) {
        return {
            decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound
                ? Sampler_SamplingDecision.RECORD_AND_SAMPLED
                : Sampler_SamplingDecision.NOT_RECORD,
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function () {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function (ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio))
            return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function (traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}());

//# sourceMappingURL=TraceIdRatioBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/config.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var env = getEnv();
var FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;
var DEFAULT_RATIO = 1;
/**
 * Load default configuration. For fields with primitive values, any user-provided
 * value will override the corresponding default value. For fields with
 * non-primitive values (like `spanLimits`), the user-provided value will be
 * used to extend the default value.
 */
// object needs to be wrapped in this function and called when needed otherwise
// envs are parsed before tests are ran - causes tests using these envs to fail
function loadDefaultConfig() {
    return {
        sampler: buildSamplerFromEnv(env),
        forceFlushTimeoutMillis: 30000,
        generalLimits: {
            attributeValueLengthLimit: getEnv().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            attributeCountLimit: getEnv().OTEL_ATTRIBUTE_COUNT_LIMIT,
        },
        spanLimits: {
            attributeValueLengthLimit: getEnv().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            attributeCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
            linkCountLimit: getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,
            eventCountLimit: getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT,
        },
    };
}
/**
 * Based on environment, builds a sampler, complies with specification.
 * @param environment optional, by default uses getEnv(), but allows passing a value to reuse parsed environment
 */
function buildSamplerFromEnv(environment) {
    if (environment === void 0) { environment = getEnv(); }
    switch (environment.OTEL_TRACES_SAMPLER) {
        case TracesSamplerValues.AlwaysOn:
            return new AlwaysOnSampler();
        case TracesSamplerValues.AlwaysOff:
            return new AlwaysOffSampler();
        case TracesSamplerValues.ParentBasedAlwaysOn:
            return new ParentBasedSampler({
                root: new AlwaysOnSampler(),
            });
        case TracesSamplerValues.ParentBasedAlwaysOff:
            return new ParentBasedSampler({
                root: new AlwaysOffSampler(),
            });
        case TracesSamplerValues.TraceIdRatio:
            return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
        case TracesSamplerValues.ParentBasedTraceIdRatio:
            return new ParentBasedSampler({
                root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment)),
            });
        default:
            esm_diag.error("OTEL_TRACES_SAMPLER value \"" + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + "\".");
            return new AlwaysOnSampler();
    }
}
function getSamplerProbabilityFromEnv(environment) {
    if (environment.OTEL_TRACES_SAMPLER_ARG === undefined ||
        environment.OTEL_TRACES_SAMPLER_ARG === '') {
        esm_diag.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
    }
    var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
    if (isNaN(probability)) {
        esm_diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
    }
    if (probability < 0 || probability > 1) {
        esm_diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
    }
    return probability;
}
//# sourceMappingURL=config.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/utility.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Function to merge Default configuration (as specified in './config') with
 * user provided configurations.
 */
function mergeConfig(userConfig) {
    var perInstanceDefaults = {
        sampler: buildSamplerFromEnv(),
    };
    var DEFAULT_CONFIG = loadDefaultConfig();
    var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
    target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
    target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
    return target;
}
/**
 * When general limits are provided and model specific limits are not,
 * configures the model specific limits by using the values from the general ones.
 * @param userConfig User provided tracer configuration
 */
function reconfigureLimits(userConfig) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var spanLimits = Object.assign({}, userConfig.spanLimits);
    var parsedEnvConfig = getEnvWithoutDefaults();
    /**
     * Reassign span attribute count limit to use first non null value defined by user or use default value
     */
    spanLimits.attributeCountLimit =
        (_f = (_e = (_d = (_b = (_a = userConfig.spanLimits) === null || _a === void 0 ? void 0 : _a.attributeCountLimit) !== null && _b !== void 0 ? _b : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;
    /**
     * Reassign span attribute value length limit to use first non null value defined by user or use default value
     */
    spanLimits.attributeValueLengthLimit =
        (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
    return Object.assign({}, userConfig, { spanLimits: spanLimits });
}
//# sourceMappingURL=utility.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/browser/RandomIdGenerator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SPAN_ID_BYTES = 8;
var TRACE_ID_BYTES = 16;
var RandomIdGenerator = /** @class */ (function () {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
    return RandomIdGenerator;
}());

var SHARED_CHAR_CODES_ARRAY = Array(32);
function getIdGenerator(bytes) {
    return function generateId() {
        for (var i = 0; i < bytes * 2; i++) {
            SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
            // valid hex characters in the range 48-57 and 97-102
            if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
                SHARED_CHAR_CODES_ARRAY[i] += 39;
            }
        }
        return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
    };
}
//# sourceMappingURL=RandomIdGenerator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * This class represents a basic tracer.
 */
var Tracer = /** @class */ (function () {
    /**
     * Constructs a new Tracer instance.
     */
    function Tracer(instrumentationLibrary, config, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        var localConfig = mergeConfig(config);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config.idGenerator || new RandomIdGenerator();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
    }
    /**
     * Starts a new Span or returns the default NoopSpan based on the sampling
     * decision.
     */
    Tracer.prototype.startSpan = function (name, options, context) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        if (context === void 0) { context = esm_context.active(); }
        // remove span from context in case a root span is requested via options
        if (options.root) {
            context = trace.deleteSpan(context);
        }
        var parentSpan = trace.getSpan(context);
        if (isTracingSuppressed(context)) {
            esm_diag.debug('Instrumentation suppressed, returning Noop Span');
            var nonRecordingSpan = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
            return nonRecordingSpan;
        }
        var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
        var spanId = this._idGenerator.generateSpanId();
        var traceId;
        var traceState;
        var parentSpanId;
        if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {
            // New root span.
            traceId = this._idGenerator.generateTraceId();
        }
        else {
            // New child span.
            traceId = parentSpanContext.traceId;
            traceState = parentSpanContext.traceState;
            parentSpanId = parentSpanContext.spanId;
        }
        var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : SpanKind.INTERNAL;
        var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function (link) {
            return {
                context: link.context,
                attributes: sanitizeAttributes(link.attributes),
            };
        });
        var attributes = sanitizeAttributes(options.attributes);
        // make sampling decision
        var samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);
        var traceFlags = samplingResult.decision === SamplingDecision.RECORD_AND_SAMPLED
            ? TraceFlags.SAMPLED
            : TraceFlags.NONE;
        var spanContext = { traceId: traceId, spanId: spanId, traceFlags: traceFlags, traceState: traceState };
        if (samplingResult.decision === SamplingDecision.NOT_RECORD) {
            esm_diag.debug('Recording is off, propagating context in a non-recording span');
            var nonRecordingSpan = trace.wrapSpanContext(spanContext);
            return nonRecordingSpan;
        }
        var span = new Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime);
        // Set initial span attributes. The attributes object may have been mutated
        // by the sampler, so we sanitize the merged attributes before setting them.
        var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
        span.setAttributes(initAttributes);
        return span;
    };
    Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        }
        else if (arguments.length === 2) {
            fn = arg2;
        }
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        }
        else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : esm_context.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = trace.setSpan(parentContext, span);
        return esm_context["with"](contextWithSpanSet, fn, undefined, span);
    };
    /** Returns the active {@link GeneralLimits}. */
    Tracer.prototype.getGeneralLimits = function () {
        return this._generalLimits;
    };
    /** Returns the active {@link SpanLimits}. */
    Tracer.prototype.getSpanLimits = function () {
        return this._spanLimits;
    };
    Tracer.prototype.getActiveSpanProcessor = function () {
        return this._tracerProvider.getActiveSpanProcessor();
    };
    return Tracer;
}());

//# sourceMappingURL=Tracer.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/MultiSpanProcessor.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MultiSpanProcessor_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

/**
 * Implementation of the {@link SpanProcessor} that simply forwards all
 * received events to a list of {@link SpanProcessor}s.
 */
var MultiSpanProcessor = /** @class */ (function () {
    function MultiSpanProcessor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
    }
    MultiSpanProcessor.prototype.forceFlush = function () {
        var e_1, _a;
        var promises = [];
        try {
            for (var _b = MultiSpanProcessor_values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
                var spanProcessor = _c.value;
                promises.push(spanProcessor.forceFlush());
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return new Promise(function (resolve) {
            Promise.all(promises)
                .then(function () {
                resolve();
            })
                .catch(function (error) {
                globalErrorHandler(error || new Error('MultiSpanProcessor: forceFlush failed'));
                resolve();
            });
        });
    };
    MultiSpanProcessor.prototype.onStart = function (span, context) {
        var e_2, _a;
        try {
            for (var _b = MultiSpanProcessor_values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
                var spanProcessor = _c.value;
                spanProcessor.onStart(span, context);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    MultiSpanProcessor.prototype.onEnd = function (span) {
        var e_3, _a;
        try {
            for (var _b = MultiSpanProcessor_values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
                var spanProcessor = _c.value;
                spanProcessor.onEnd(span);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    MultiSpanProcessor.prototype.shutdown = function () {
        var e_4, _a;
        var promises = [];
        try {
            for (var _b = MultiSpanProcessor_values(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
                var spanProcessor = _c.value;
                promises.push(spanProcessor.shutdown());
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return new Promise(function (resolve, reject) {
            Promise.all(promises).then(function () {
                resolve();
            }, reject);
        });
    };
    return MultiSpanProcessor;
}());

//# sourceMappingURL=MultiSpanProcessor.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/export/NoopSpanProcessor.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** No-op implementation of SpanProcessor */
var NoopSpanProcessor = /** @class */ (function () {
    function NoopSpanProcessor() {
    }
    NoopSpanProcessor.prototype.onStart = function (_span, _context) { };
    NoopSpanProcessor.prototype.onEnd = function (_span) { };
    NoopSpanProcessor.prototype.shutdown = function () {
        return Promise.resolve();
    };
    NoopSpanProcessor.prototype.forceFlush = function () {
        return Promise.resolve();
    };
    return NoopSpanProcessor;
}());

//# sourceMappingURL=NoopSpanProcessor.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var ForceFlushState;
(function (ForceFlushState) {
    ForceFlushState[ForceFlushState["resolved"] = 0] = "resolved";
    ForceFlushState[ForceFlushState["timeout"] = 1] = "timeout";
    ForceFlushState[ForceFlushState["error"] = 2] = "error";
    ForceFlushState[ForceFlushState["unresolved"] = 3] = "unresolved";
})(ForceFlushState || (ForceFlushState = {}));
/**
 * This class represents a basic tracer provider which platform libraries can extend
 */
var BasicTracerProvider = /** @class */ (function () {
    function BasicTracerProvider(config) {
        if (config === void 0) { config = {}; }
        var _a;
        this._registeredSpanProcessors = [];
        this._tracers = new Map();
        var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));
        this.resource = (_a = mergedConfig.resource) !== null && _a !== void 0 ? _a : Resource_Resource.empty();
        this.resource = Resource_Resource["default"]().merge(this.resource);
        this._config = Object.assign({}, mergedConfig, {
            resource: this.resource,
        });
        var defaultExporter = this._buildExporterFromEnv();
        if (defaultExporter !== undefined) {
            var batchProcessor = new BatchSpanProcessor(defaultExporter);
            this.activeSpanProcessor = batchProcessor;
        }
        else {
            this.activeSpanProcessor = new NoopSpanProcessor();
        }
    }
    BasicTracerProvider.prototype.getTracer = function (name, version, options) {
        var key = name + "@" + (version || '') + ":" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || '');
        if (!this._tracers.has(key)) {
            this._tracers.set(key, new Tracer({ name: name, version: version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._tracers.get(key);
    };
    /**
     * Adds a new {@link SpanProcessor} to this tracer.
     * @param spanProcessor the new SpanProcessor to be added.
     */
    BasicTracerProvider.prototype.addSpanProcessor = function (spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) {
            // since we might have enabled by default a batchProcessor, we disable it
            // before adding the new one
            this.activeSpanProcessor
                .shutdown()
                .catch(function (err) {
                return esm_diag.error('Error while trying to shutdown current span processor', err);
            });
        }
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
    };
    BasicTracerProvider.prototype.getActiveSpanProcessor = function () {
        return this.activeSpanProcessor;
    };
    /**
     * Register this TracerProvider for use with the OpenTelemetry API.
     * Undefined values may be replaced with defaults, and
     * null values will be skipped.
     *
     * @param config Configuration object for SDK registration
     */
    BasicTracerProvider.prototype.register = function (config) {
        if (config === void 0) { config = {}; }
        trace.setGlobalTracerProvider(this);
        if (config.propagator === undefined) {
            config.propagator = this._buildPropagatorFromEnv();
        }
        if (config.contextManager) {
            esm_context.setGlobalContextManager(config.contextManager);
        }
        if (config.propagator) {
            propagation.setGlobalPropagator(config.propagator);
        }
    };
    BasicTracerProvider.prototype.forceFlush = function () {
        var timeout = this._config.forceFlushTimeoutMillis;
        var promises = this._registeredSpanProcessors.map(function (spanProcessor) {
            return new Promise(function (resolve) {
                var state;
                var timeoutInterval = setTimeout(function () {
                    resolve(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
                    state = ForceFlushState.timeout;
                }, timeout);
                spanProcessor
                    .forceFlush()
                    .then(function () {
                    clearTimeout(timeoutInterval);
                    if (state !== ForceFlushState.timeout) {
                        state = ForceFlushState.resolved;
                        resolve(state);
                    }
                })
                    .catch(function (error) {
                    clearTimeout(timeoutInterval);
                    state = ForceFlushState.error;
                    resolve(error);
                });
            });
        });
        return new Promise(function (resolve, reject) {
            Promise.all(promises)
                .then(function (results) {
                var errors = results.filter(function (result) { return result !== ForceFlushState.resolved; });
                if (errors.length > 0) {
                    reject(errors);
                }
                else {
                    resolve();
                }
            })
                .catch(function (error) { return reject([error]); });
        });
    };
    BasicTracerProvider.prototype.shutdown = function () {
        return this.activeSpanProcessor.shutdown();
    };
    /**
     * TS cannot yet infer the type of this.constructor:
     * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146
     * There is no need to override either of the getters in your child class.
     * The type of the registered component maps should be the same across all
     * classes in the inheritance tree.
     */
    BasicTracerProvider.prototype._getPropagator = function (name) {
        var _a;
        return (_a = (this.constructor._registeredPropagators).get(name)) === null || _a === void 0 ? void 0 : _a();
    };
    BasicTracerProvider.prototype._getSpanExporter = function (name) {
        var _a;
        return (_a = (this.constructor._registeredExporters).get(name)) === null || _a === void 0 ? void 0 : _a();
    };
    BasicTracerProvider.prototype._buildPropagatorFromEnv = function () {
        var _this = this;
        // per spec, propagators from env must be deduplicated
        var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));
        var propagators = uniquePropagatorNames.map(function (name) {
            var propagator = _this._getPropagator(name);
            if (!propagator) {
                esm_diag.warn("Propagator \"" + name + "\" requested through environment variable is unavailable.");
            }
            return propagator;
        });
        var validPropagators = propagators.reduce(function (list, item) {
            if (item) {
                list.push(item);
            }
            return list;
        }, []);
        if (validPropagators.length === 0) {
            return;
        }
        else if (uniquePropagatorNames.length === 1) {
            return validPropagators[0];
        }
        else {
            return new CompositePropagator({
                propagators: validPropagators,
            });
        }
    };
    BasicTracerProvider.prototype._buildExporterFromEnv = function () {
        var exporterName = getEnv().OTEL_TRACES_EXPORTER;
        if (exporterName === 'none')
            return;
        var exporter = this._getSpanExporter(exporterName);
        if (!exporter) {
            esm_diag.error("Exporter \"" + exporterName + "\" requested through environment variable is unavailable.");
        }
        return exporter;
    };
    BasicTracerProvider._registeredPropagators = new Map([
        ['tracecontext', function () { return new W3CTraceContextPropagator(); }],
        ['baggage', function () { return new W3CBaggagePropagator(); }],
    ]);
    BasicTracerProvider._registeredExporters = new Map();
    return BasicTracerProvider;
}());

//# sourceMappingURL=BasicTracerProvider.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-web/build/esm/StackContextManager.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var StackContextManager_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var StackContextManager_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

/**
 * Stack Context Manager for managing the state in web
 * it doesn't fully support the async calls though
 */
var StackContextManager = /** @class */ (function () {
    function StackContextManager() {
        /**
         * whether the context manager is enabled or not
         */
        this._enabled = false;
        /**
         * Keeps the reference to current context
         */
        this._currentContext = ROOT_CONTEXT;
    }
    /**
     *
     * @param context
     * @param target Function to be executed within the context
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    StackContextManager.prototype._bindFunction = function (context, target) {
        if (context === void 0) { context = ROOT_CONTEXT; }
        var manager = this;
        var contextWrapper = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return manager.with(context, function () { return target.apply(_this, args); });
        };
        Object.defineProperty(contextWrapper, 'length', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: target.length,
        });
        return contextWrapper;
    };
    /**
     * Returns the active context
     */
    StackContextManager.prototype.active = function () {
        return this._currentContext;
    };
    /**
     * Binds a the certain context or the active one to the target function and then returns the target
     * @param context A context (span) to be bind to target
     * @param target a function or event emitter. When target or one of its callbacks is called,
     *  the provided context will be used as the active context for the duration of the call.
     */
    StackContextManager.prototype.bind = function (context, target) {
        // if no specific context to propagate is given, we use the current one
        if (context === undefined) {
            context = this.active();
        }
        if (typeof target === 'function') {
            return this._bindFunction(context, target);
        }
        return target;
    };
    /**
     * Disable the context manager (clears the current context)
     */
    StackContextManager.prototype.disable = function () {
        this._currentContext = ROOT_CONTEXT;
        this._enabled = false;
        return this;
    };
    /**
     * Enables the context manager and creates a default(root) context
     */
    StackContextManager.prototype.enable = function () {
        if (this._enabled) {
            return this;
        }
        this._enabled = true;
        this._currentContext = ROOT_CONTEXT;
        return this;
    };
    /**
     * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.
     * The context will be set as active
     * @param context
     * @param fn Callback function
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */
    StackContextManager.prototype.with = function (context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        var previousContext = this._currentContext;
        this._currentContext = context || ROOT_CONTEXT;
        try {
            return fn.call.apply(fn, StackContextManager_spreadArray([thisArg], StackContextManager_read(args), false));
        }
        finally {
            this._currentContext = previousContext;
        }
    };
    return StackContextManager;
}());

//# sourceMappingURL=StackContextManager.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-trace-web/build/esm/WebTracerProvider.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var WebTracerProvider_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * This class represents a web tracer with {@link StackContextManager}
 */
var WebTracerProvider = /** @class */ (function (_super) {
    WebTracerProvider_extends(WebTracerProvider, _super);
    /**
     * Constructs a new Tracer instance.
     * @param config Web Tracer config
     */
    function WebTracerProvider(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, config) || this;
        if (config.contextManager) {
            throw ('contextManager should be defined in register method not in' +
                ' constructor');
        }
        if (config.propagator) {
            throw 'propagator should be defined in register method not in constructor';
        }
        return _this;
    }
    /**
     * Register this TracerProvider for use with the OpenTelemetry API.
     * Undefined values may be replaced with defaults, and
     * null values will be skipped.
     *
     * @param config Configuration object for SDK registration
     */
    WebTracerProvider.prototype.register = function (config) {
        if (config === void 0) { config = {}; }
        if (config.contextManager === undefined) {
            config.contextManager = new StackContextManager();
        }
        if (config.contextManager) {
            config.contextManager.enable();
        }
        _super.prototype.register.call(this, config);
    };
    return WebTracerProvider;
}(BasicTracerProvider));

//# sourceMappingURL=WebTracerProvider.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var suppress_tracing_SUPPRESS_TRACING_KEY = createContextKey('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function suppress_tracing_suppressTracing(context) {
    return context.setValue(suppress_tracing_SUPPRESS_TRACING_KEY, true);
}
function suppress_tracing_unsuppressTracing(context) {
    return context.deleteValue(suppress_tracing_SUPPRESS_TRACING_KEY);
}
function suppress_tracing_isTracingSuppressed(context) {
    return context.getValue(suppress_tracing_SUPPRESS_TRACING_KEY) === true;
}
//# sourceMappingURL=suppress-tracing.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/baggage/constants.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var constants_BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var constants_BAGGAGE_PROPERTIES_SEPARATOR = ';';
var baggage_constants_BAGGAGE_ITEMS_SEPARATOR = ',';
// Name of the http header used to propagate the baggage
var constants_BAGGAGE_HEADER = 'baggage';
// Maximum number of name-value pairs allowed by w3c spec
var constants_BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
// Maximum number of bytes per a single name-value pair allowed by w3c spec
var constants_BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
// Maximum total length of all name-value pairs allowed by w3c spec
var constants_BAGGAGE_MAX_TOTAL_LENGTH = 8192;
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/baggage/utils.js
var baggage_utils_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function utils_serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function (hValue, current) {
        var value = "" + hValue + (hValue !== '' ? baggage_constants_BAGGAGE_ITEMS_SEPARATOR : '') + current;
        return value.length > constants_BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, '');
}
function utils_getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function (_a) {
        var _b = baggage_utils_read(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) {
            entry += constants_BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
    });
}
function utils_parsePairKeyValue(entry) {
    var valueProps = entry.split(constants_BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
        return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart)
        return;
    var keyPair = keyPairPart.split(constants_BAGGAGE_KEY_PAIR_SEPARATOR);
    if (keyPair.length !== 2)
        return;
    var key = decodeURIComponent(keyPair[0].trim());
    var value = decodeURIComponent(keyPair[1].trim());
    var metadata;
    if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(constants_BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key: key, value: value, metadata: metadata };
}
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */
function utils_parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0)
        return {};
    return value
        .split(baggage_constants_BAGGAGE_ITEMS_SEPARATOR)
        .map(function (entry) {
        return utils_parsePairKeyValue(entry);
    })
        .filter(function (keyPair) { return keyPair !== undefined && keyPair.value.length > 0; })
        .reduce(function (headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Propagates {@link Baggage} through Context format propagation.
 *
 * Based on the Baggage specification:
 * https://w3c.github.io/baggage/
 */
var W3CBaggagePropagator_W3CBaggagePropagator = /** @class */ (function () {
    function W3CBaggagePropagator() {
    }
    W3CBaggagePropagator.prototype.inject = function (context, carrier, setter) {
        var baggage = propagation.getBaggage(context);
        if (!baggage || suppress_tracing_isTracingSuppressed(context))
            return;
        var keyPairs = utils_getKeyPairs(baggage)
            .filter(function (pair) {
            return pair.length <= constants_BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        })
            .slice(0, constants_BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = utils_serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
            setter.set(carrier, constants_BAGGAGE_HEADER, headerValue);
        }
    };
    W3CBaggagePropagator.prototype.extract = function (context, carrier, getter) {
        var headerValue = getter.get(carrier, constants_BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(baggage_constants_BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
            return context;
        var baggage = {};
        if (baggageString.length === 0) {
            return context;
        }
        var pairs = baggageString.split(baggage_constants_BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function (entry) {
            var keyPair = utils_parsePairKeyValue(entry);
            if (keyPair) {
                var baggageEntry = { value: keyPair.value };
                if (keyPair.metadata) {
                    baggageEntry.metadata = keyPair.metadata;
                }
                baggage[keyPair.key] = baggageEntry;
            }
        });
        if (Object.entries(baggage).length === 0) {
            return context;
        }
        return propagation.setBaggage(context, propagation.createBaggage(baggage));
    };
    W3CBaggagePropagator.prototype.fields = function () {
        return [constants_BAGGAGE_HEADER];
    };
    return W3CBaggagePropagator;
}());

//# sourceMappingURL=W3CBaggagePropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/common/anchored-clock.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A utility for returning wall times anchored to a given point in time. Wall time measurements will
 * not be taken from the system, but instead are computed by adding a monotonic clock time
 * to the anchor point.
 *
 * This is needed because the system time can change and result in unexpected situations like
 * spans ending before they are started. Creating an anchored clock for each local root span
 * ensures that span timings and durations are accurate while preventing span times from drifting
 * too far from the system clock.
 *
 * Only creating an anchored clock once per local trace ensures span times are correct relative
 * to each other. For example, a child span will never have a start time before its parent even
 * if the system clock is corrected during the local trace.
 *
 * Heavily inspired by the OTel Java anchored clock
 * https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk/trace/src/main/java/io/opentelemetry/sdk/trace/AnchoredClock.java
 */
var AnchoredClock = /** @class */ (function () {
    /**
     * Create a new AnchoredClock anchored to the current time returned by systemClock.
     *
     * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
     * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
     */
    function AnchoredClock(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
    }
    /**
     * Returns the current time by adding the number of milliseconds since the
     * AnchoredClock was created to the creation epoch time
     */
    AnchoredClock.prototype.now = function () {
        var delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
    };
    return AnchoredClock;
}());

//# sourceMappingURL=anchored-clock.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/common/attributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var common_attributes_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var common_attributes_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

function attributes_sanitizeAttributes(attributes) {
    var e_1, _a;
    var out = {};
    if (typeof attributes !== 'object' || attributes == null) {
        return out;
    }
    try {
        for (var _b = common_attributes_values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = common_attributes_read(_c.value, 2), key = _d[0], val = _d[1];
            if (!attributes_isAttributeKey(key)) {
                diag.warn("Invalid attribute key: " + key);
                continue;
            }
            if (!attributes_isAttributeValue(val)) {
                diag.warn("Invalid attribute value set for key: " + key);
                continue;
            }
            if (Array.isArray(val)) {
                out[key] = val.slice();
            }
            else {
                out[key] = val;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return out;
}
function attributes_isAttributeKey(key) {
    return typeof key === 'string' && key.length > 0;
}
function attributes_isAttributeValue(val) {
    if (val == null) {
        return true;
    }
    if (Array.isArray(val)) {
        return attributes_isHomogeneousAttributeValueArray(val);
    }
    return attributes_isValidPrimitiveAttributeValue(val);
}
function attributes_isHomogeneousAttributeValueArray(arr) {
    var e_2, _a;
    var type;
    try {
        for (var arr_1 = common_attributes_values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var element = arr_1_1.value;
            // null/undefined elements are allowed
            if (element == null)
                continue;
            if (!type) {
                if (attributes_isValidPrimitiveAttributeValue(element)) {
                    type = typeof element;
                    continue;
                }
                // encountered an invalid primitive
                return false;
            }
            if (typeof element === type) {
                continue;
            }
            return false;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return true;
}
function attributes_isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
        case 'number':
        case 'boolean':
        case 'string':
            return true;
    }
    return false;
}
//# sourceMappingURL=attributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */
function logging_error_handler_loggingErrorHandler() {
    return function (ex) {
        esm_diag.error(logging_error_handler_stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */
function logging_error_handler_stringifyException(ex) {
    if (typeof ex === 'string') {
        return ex;
    }
    else {
        return JSON.stringify(logging_error_handler_flattenException(ex));
    }
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */
function logging_error_handler_flattenException(ex) {
    var result = {};
    var current = ex;
    while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function (propertyName) {
            if (result[propertyName])
                return;
            var value = current[propertyName];
            if (value) {
                result[propertyName] = String(value);
            }
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}
//# sourceMappingURL=logging-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** The global error handler delegate */
var global_error_handler_delegateHandler = logging_error_handler_loggingErrorHandler();
/**
 * Set the global error handler
 * @param {ErrorHandler} handler
 */
function global_error_handler_setGlobalErrorHandler(handler) {
    global_error_handler_delegateHandler = handler;
}
/**
 * Return the global error handler
 * @param {Exception} ex
 */
function global_error_handler_globalErrorHandler(ex) {
    try {
        global_error_handler_delegateHandler(ex);
    }
    catch (_a) { } // eslint-disable-line no-empty
}
//# sourceMappingURL=global-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/sampling.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var sampling_TracesSamplerValues;
(function (TracesSamplerValues) {
    TracesSamplerValues["AlwaysOff"] = "always_off";
    TracesSamplerValues["AlwaysOn"] = "always_on";
    TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues["TraceIdRatio"] = "traceidratio";
})(sampling_TracesSamplerValues || (sampling_TracesSamplerValues = {}));
//# sourceMappingURL=sampling.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/platform/browser/globalThis.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/api-metrics too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var platform_browser_globalThis_globalThis = typeof globalThis === 'object' ? globalThis :
    typeof self === 'object' ? self :
        typeof window === 'object' ? window :
            typeof __webpack_require__.g === 'object' ? __webpack_require__.g :
                {};
//# sourceMappingURL=globalThis.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var environment_DEFAULT_LIST_SEPARATOR = ',';
/**
 * Environment interface to define all names
 */
var environment_ENVIRONMENT_NUMBERS_KEYS = [
    'OTEL_BSP_EXPORT_TIMEOUT',
    'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BSP_MAX_QUEUE_SIZE',
    'OTEL_BSP_SCHEDULE_DELAY',
    'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_LINK_COUNT_LIMIT',
    'OTEL_EXPORTER_OTLP_TIMEOUT',
    'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
    'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
    'OTEL_EXPORTER_JAEGER_AGENT_PORT',
];
function environment_isEnvVarANumber(key) {
    return (environment_ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1);
}
var environment_ENVIRONMENT_LISTS_KEYS = [
    'OTEL_NO_PATCH_MODULES',
    'OTEL_PROPAGATORS',
];
function environment_isEnvVarAList(key) {
    return environment_ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
/**
 * Default environment variables
 */
var utils_environment_DEFAULT_ENVIRONMENT = {
    CONTAINER_NAME: '',
    ECS_CONTAINER_METADATA_URI_V4: '',
    ECS_CONTAINER_METADATA_URI: '',
    HOSTNAME: '',
    KUBERNETES_SERVICE_HOST: '',
    NAMESPACE: '',
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: '',
    OTEL_EXPORTER_JAEGER_PASSWORD: '',
    OTEL_EXPORTER_JAEGER_USER: '',
    OTEL_EXPORTER_OTLP_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_HEADERS: '',
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
    OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
    OTEL_LOG_LEVEL: DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
    OTEL_RESOURCE_ATTRIBUTES: '',
    OTEL_SERVICE_NAME: '',
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_TRACES_EXPORTER: 'none',
    OTEL_TRACES_SAMPLER: sampling_TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: '',
    OTEL_EXPORTER_OTLP_INSECURE: '',
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
    OTEL_EXPORTER_OTLP_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: ''
};
/**
 * Parses a variable as number with number validation
 * @param name
 * @param environment
 * @param values
 * @param min
 * @param max
 */
function environment_parseNumber(name, environment, values, min, max) {
    if (min === void 0) { min = -Infinity; }
    if (max === void 0) { max = Infinity; }
    if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
            if (value < min) {
                environment[name] = min;
            }
            else if (value > max) {
                environment[name] = max;
            }
            else {
                environment[name] = value;
            }
        }
    }
}
/**
 * Parses list-like strings from input into output.
 * @param name
 * @param environment
 * @param values
 * @param separator
 */
function environment_parseStringList(name, output, input, separator) {
    if (separator === void 0) { separator = environment_DEFAULT_LIST_SEPARATOR; }
    var givenValue = input[name];
    if (typeof givenValue === 'string') {
        output[name] = givenValue.split(separator).map(function (v) { return v.trim(); });
    }
}
// The support string -> DiagLogLevel mappings
var environment_logLevelMap = {
    ALL: DiagLogLevel.ALL,
    VERBOSE: DiagLogLevel.VERBOSE,
    DEBUG: DiagLogLevel.DEBUG,
    INFO: DiagLogLevel.INFO,
    WARN: DiagLogLevel.WARN,
    ERROR: DiagLogLevel.ERROR,
    NONE: DiagLogLevel.NONE,
};
/**
 * Environmentally sets log level if valid log level string is provided
 * @param key
 * @param environment
 * @param values
 */
function environment_setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if (typeof value === 'string') {
        var theLevel = environment_logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
            environment[key] = theLevel;
        }
    }
}
/**
 * Parses environment values
 * @param values
 */
function utils_environment_parseEnvironment(values) {
    var environment = {};
    for (var env in utils_environment_DEFAULT_ENVIRONMENT) {
        var key = env;
        switch (key) {
            case 'OTEL_LOG_LEVEL':
                environment_setLogLevelFromEnv(key, environment, values);
                break;
            default:
                if (environment_isEnvVarANumber(key)) {
                    environment_parseNumber(key, environment, values);
                }
                else if (environment_isEnvVarAList(key)) {
                    environment_parseStringList(key, environment, values);
                }
                else {
                    var value = values[key];
                    if (typeof value !== 'undefined' && value !== null) {
                        environment[key] = String(value);
                    }
                }
        }
    }
    return environment;
}
/**
 * Get environment in node or browser without
 * populating default values.
 */
function environment_getEnvWithoutDefaults() {
    return typeof process !== 'undefined' ?
        utils_environment_parseEnvironment("MISSING_ENV_VAR") :
        utils_environment_parseEnvironment(_globalThis);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/platform/browser/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Gets the environment variables
 */
function environment_getEnv() {
    var globalEnv = utils_environment_parseEnvironment(platform_browser_globalThis_globalThis);
    return Object.assign({}, utils_environment_DEFAULT_ENVIRONMENT, globalEnv);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/platform/browser/RandomIdGenerator.js
var RandomIdGenerator_SPAN_ID_BYTES = 8;
var RandomIdGenerator_TRACE_ID_BYTES = 16;
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 */
var RandomIdGenerator_RandomIdGenerator = /** @class */ (function () {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */
        this.generateTraceId = RandomIdGenerator_getIdGenerator(RandomIdGenerator_TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */
        this.generateSpanId = RandomIdGenerator_getIdGenerator(RandomIdGenerator_SPAN_ID_BYTES);
    }
    return RandomIdGenerator;
}());

var RandomIdGenerator_SHARED_CHAR_CODES_ARRAY = Array(32);
function RandomIdGenerator_getIdGenerator(bytes) {
    return function generateId() {
        for (var i = 0; i < bytes * 2; i++) {
            RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
            // valid hex characters in the range 48-57 and 97-102
            if (RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] >= 58) {
                RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] += 39;
            }
        }
        return String.fromCharCode.apply(null, RandomIdGenerator_SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
    };
}
//# sourceMappingURL=RandomIdGenerator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/platform/browser/performance.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var performance_otperformance = performance;
//# sourceMappingURL=performance.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/version.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var esm_version_VERSION = '1.7.0';
//# sourceMappingURL=version.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var SemanticAttributes_SemanticAttributes = {
    /**
    * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
    *
    * Note: This may be different from `faas.id` if an alias is involved.
    */
    AWS_LAMBDA_INVOKED_ARN: 'aws.lambda.invoked_arn',
    /**
    * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
    */
    DB_SYSTEM: 'db.system',
    /**
    * The connection string used to connect to the database. It is recommended to remove embedded credentials.
    */
    DB_CONNECTION_STRING: 'db.connection_string',
    /**
    * Username for accessing the database.
    */
    DB_USER: 'db.user',
    /**
    * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
    */
    DB_JDBC_DRIVER_CLASSNAME: 'db.jdbc.driver_classname',
    /**
    * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
    *
    * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
    */
    DB_NAME: 'db.name',
    /**
    * The database statement being executed.
    *
    * Note: The value may be sanitized to exclude sensitive information.
    */
    DB_STATEMENT: 'db.statement',
    /**
    * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
    *
    * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
    */
    DB_OPERATION: 'db.operation',
    /**
    * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
    *
    * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
    */
    DB_MSSQL_INSTANCE_NAME: 'db.mssql.instance_name',
    /**
    * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_CASSANDRA_KEYSPACE: 'db.cassandra.keyspace',
    /**
    * The fetch size used for paging, i.e. how many rows will be returned at once.
    */
    DB_CASSANDRA_PAGE_SIZE: 'db.cassandra.page_size',
    /**
    * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
    */
    DB_CASSANDRA_CONSISTENCY_LEVEL: 'db.cassandra.consistency_level',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_CASSANDRA_TABLE: 'db.cassandra.table',
    /**
    * Whether or not the query is idempotent.
    */
    DB_CASSANDRA_IDEMPOTENCE: 'db.cassandra.idempotence',
    /**
    * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
    */
    DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: 'db.cassandra.speculative_execution_count',
    /**
    * The ID of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_ID: 'db.cassandra.coordinator.id',
    /**
    * The data center of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_DC: 'db.cassandra.coordinator.dc',
    /**
    * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_HBASE_NAMESPACE: 'db.hbase.namespace',
    /**
    * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
    */
    DB_REDIS_DATABASE_INDEX: 'db.redis.database_index',
    /**
    * The collection being accessed within the database stated in `db.name`.
    */
    DB_MONGODB_COLLECTION: 'db.mongodb.collection',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_SQL_TABLE: 'db.sql.table',
    /**
    * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
    */
    EXCEPTION_TYPE: 'exception.type',
    /**
    * The exception message.
    */
    EXCEPTION_MESSAGE: 'exception.message',
    /**
    * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
    */
    EXCEPTION_STACKTRACE: 'exception.stacktrace',
    /**
    * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
    *
    * Note: An exception is considered to have escaped (or left) the scope of a span,
  if that span is ended while the exception is still logically &#34;in flight&#34;.
  This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
  is passed to a Context manager&#39;s `__exit__` method in Python) but will
  usually be caught at the point of recording the exception in most languages.
  
  It is usually not possible to determine at the point where an exception is thrown
  whether it will escape the scope of a span.
  However, it is trivial to know that an exception
  will escape, if one checks for an active exception just before ending the span,
  as done in the [example above](#exception-end-example).
  
  It follows that an exception may still escape the scope of the span
  even if the `exception.escaped` attribute was not set or set to false,
  since the event might have been recorded at a time where it was not
  clear whether the exception will escape.
    */
    EXCEPTION_ESCAPED: 'exception.escaped',
    /**
    * Type of the trigger on which the function is executed.
    */
    FAAS_TRIGGER: 'faas.trigger',
    /**
    * The execution ID of the current function execution.
    */
    FAAS_EXECUTION: 'faas.execution',
    /**
    * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
    */
    FAAS_DOCUMENT_COLLECTION: 'faas.document.collection',
    /**
    * Describes the type of the operation that was performed on the data.
    */
    FAAS_DOCUMENT_OPERATION: 'faas.document.operation',
    /**
    * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_DOCUMENT_TIME: 'faas.document.time',
    /**
    * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
    */
    FAAS_DOCUMENT_NAME: 'faas.document.name',
    /**
    * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_TIME: 'faas.time',
    /**
    * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
    */
    FAAS_CRON: 'faas.cron',
    /**
    * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
    */
    FAAS_COLDSTART: 'faas.coldstart',
    /**
    * The name of the invoked function.
    *
    * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
    */
    FAAS_INVOKED_NAME: 'faas.invoked_name',
    /**
    * The cloud provider of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
    */
    FAAS_INVOKED_PROVIDER: 'faas.invoked_provider',
    /**
    * The cloud region of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
    */
    FAAS_INVOKED_REGION: 'faas.invoked_region',
    /**
    * Transport protocol used. See note below.
    */
    NET_TRANSPORT: 'net.transport',
    /**
    * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
    */
    NET_PEER_IP: 'net.peer.ip',
    /**
    * Remote port number.
    */
    NET_PEER_PORT: 'net.peer.port',
    /**
    * Remote hostname or similar, see note below.
    */
    NET_PEER_NAME: 'net.peer.name',
    /**
    * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
    */
    NET_HOST_IP: 'net.host.ip',
    /**
    * Like `net.peer.port` but for the host port.
    */
    NET_HOST_PORT: 'net.host.port',
    /**
    * Local hostname or similar, see note below.
    */
    NET_HOST_NAME: 'net.host.name',
    /**
    * The internet connection type currently being used by the host.
    */
    NET_HOST_CONNECTION_TYPE: 'net.host.connection.type',
    /**
    * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
    */
    NET_HOST_CONNECTION_SUBTYPE: 'net.host.connection.subtype',
    /**
    * The name of the mobile carrier.
    */
    NET_HOST_CARRIER_NAME: 'net.host.carrier.name',
    /**
    * The mobile carrier country code.
    */
    NET_HOST_CARRIER_MCC: 'net.host.carrier.mcc',
    /**
    * The mobile carrier network code.
    */
    NET_HOST_CARRIER_MNC: 'net.host.carrier.mnc',
    /**
    * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
    */
    NET_HOST_CARRIER_ICC: 'net.host.carrier.icc',
    /**
    * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
    */
    PEER_SERVICE: 'peer.service',
    /**
    * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
    */
    ENDUSER_ID: 'enduser.id',
    /**
    * Actual/assumed role the client is making the request under extracted from token or application security context.
    */
    ENDUSER_ROLE: 'enduser.role',
    /**
    * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
    */
    ENDUSER_SCOPE: 'enduser.scope',
    /**
    * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
    */
    THREAD_ID: 'thread.id',
    /**
    * Current thread name.
    */
    THREAD_NAME: 'thread.name',
    /**
    * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
    */
    CODE_FUNCTION: 'code.function',
    /**
    * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
    */
    CODE_NAMESPACE: 'code.namespace',
    /**
    * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
    */
    CODE_FILEPATH: 'code.filepath',
    /**
    * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
    */
    CODE_LINENO: 'code.lineno',
    /**
    * HTTP request method.
    */
    HTTP_METHOD: 'http.method',
    /**
    * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
    *
    * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
    */
    HTTP_URL: 'http.url',
    /**
    * The full request target as passed in a HTTP request line or equivalent.
    */
    HTTP_TARGET: 'http.target',
    /**
    * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
    *
    * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
    */
    HTTP_HOST: 'http.host',
    /**
    * The URI scheme identifying the used protocol.
    */
    HTTP_SCHEME: 'http.scheme',
    /**
    * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
    */
    HTTP_STATUS_CODE: 'http.status_code',
    /**
    * Kind of HTTP protocol used.
    *
    * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
    */
    HTTP_FLAVOR: 'http.flavor',
    /**
    * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
    */
    HTTP_USER_AGENT: 'http.user_agent',
    /**
    * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_REQUEST_CONTENT_LENGTH: 'http.request_content_length',
    /**
    * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: 'http.request_content_length_uncompressed',
    /**
    * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_RESPONSE_CONTENT_LENGTH: 'http.response_content_length',
    /**
    * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: 'http.response_content_length_uncompressed',
    /**
    * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
    *
    * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
    */
    HTTP_SERVER_NAME: 'http.server_name',
    /**
    * The matched route (path template).
    */
    HTTP_ROUTE: 'http.route',
    /**
    * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
    *
    * Note: This is not necessarily the same as `net.peer.ip`, which would
  identify the network-level peer, which may be a proxy.
  
  This attribute should be set when a source of information different
  from the one used for `net.peer.ip`, is available even if that other
  source just confirms the same value as `net.peer.ip`.
  Rationale: For `net.peer.ip`, one typically does not know if it
  comes from a proxy, reverse proxy, or the actual client. Setting
  `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
  one is at least somewhat confident that the address is not that of
  the closest proxy.
    */
    HTTP_CLIENT_IP: 'http.client_ip',
    /**
    * The keys in the `RequestItems` object field.
    */
    AWS_DYNAMODB_TABLE_NAMES: 'aws.dynamodb.table_names',
    /**
    * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
    */
    AWS_DYNAMODB_CONSUMED_CAPACITY: 'aws.dynamodb.consumed_capacity',
    /**
    * The JSON-serialized value of the `ItemCollectionMetrics` response field.
    */
    AWS_DYNAMODB_ITEM_COLLECTION_METRICS: 'aws.dynamodb.item_collection_metrics',
    /**
    * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: 'aws.dynamodb.provisioned_read_capacity',
    /**
    * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: 'aws.dynamodb.provisioned_write_capacity',
    /**
    * The value of the `ConsistentRead` request parameter.
    */
    AWS_DYNAMODB_CONSISTENT_READ: 'aws.dynamodb.consistent_read',
    /**
    * The value of the `ProjectionExpression` request parameter.
    */
    AWS_DYNAMODB_PROJECTION: 'aws.dynamodb.projection',
    /**
    * The value of the `Limit` request parameter.
    */
    AWS_DYNAMODB_LIMIT: 'aws.dynamodb.limit',
    /**
    * The value of the `AttributesToGet` request parameter.
    */
    AWS_DYNAMODB_ATTRIBUTES_TO_GET: 'aws.dynamodb.attributes_to_get',
    /**
    * The value of the `IndexName` request parameter.
    */
    AWS_DYNAMODB_INDEX_NAME: 'aws.dynamodb.index_name',
    /**
    * The value of the `Select` request parameter.
    */
    AWS_DYNAMODB_SELECT: 'aws.dynamodb.select',
    /**
    * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: 'aws.dynamodb.global_secondary_indexes',
    /**
    * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: 'aws.dynamodb.local_secondary_indexes',
    /**
    * The value of the `ExclusiveStartTableName` request parameter.
    */
    AWS_DYNAMODB_EXCLUSIVE_START_TABLE: 'aws.dynamodb.exclusive_start_table',
    /**
    * The the number of items in the `TableNames` response parameter.
    */
    AWS_DYNAMODB_TABLE_COUNT: 'aws.dynamodb.table_count',
    /**
    * The value of the `ScanIndexForward` request parameter.
    */
    AWS_DYNAMODB_SCAN_FORWARD: 'aws.dynamodb.scan_forward',
    /**
    * The value of the `Segment` request parameter.
    */
    AWS_DYNAMODB_SEGMENT: 'aws.dynamodb.segment',
    /**
    * The value of the `TotalSegments` request parameter.
    */
    AWS_DYNAMODB_TOTAL_SEGMENTS: 'aws.dynamodb.total_segments',
    /**
    * The value of the `Count` response parameter.
    */
    AWS_DYNAMODB_COUNT: 'aws.dynamodb.count',
    /**
    * The value of the `ScannedCount` response parameter.
    */
    AWS_DYNAMODB_SCANNED_COUNT: 'aws.dynamodb.scanned_count',
    /**
    * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
    */
    AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: 'aws.dynamodb.attribute_definitions',
    /**
    * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: 'aws.dynamodb.global_secondary_index_updates',
    /**
    * A string identifying the messaging system.
    */
    MESSAGING_SYSTEM: 'messaging.system',
    /**
    * The message destination name. This might be equal to the span name but is required nevertheless.
    */
    MESSAGING_DESTINATION: 'messaging.destination',
    /**
    * The kind of message destination.
    */
    MESSAGING_DESTINATION_KIND: 'messaging.destination_kind',
    /**
    * A boolean that is true if the message destination is temporary.
    */
    MESSAGING_TEMP_DESTINATION: 'messaging.temp_destination',
    /**
    * The name of the transport protocol.
    */
    MESSAGING_PROTOCOL: 'messaging.protocol',
    /**
    * The version of the transport protocol.
    */
    MESSAGING_PROTOCOL_VERSION: 'messaging.protocol_version',
    /**
    * Connection string.
    */
    MESSAGING_URL: 'messaging.url',
    /**
    * A value used by the messaging system as an identifier for the message, represented as a string.
    */
    MESSAGING_MESSAGE_ID: 'messaging.message_id',
    /**
    * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
    */
    MESSAGING_CONVERSATION_ID: 'messaging.conversation_id',
    /**
    * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
    */
    MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: 'messaging.message_payload_size_bytes',
    /**
    * The compressed size of the message payload in bytes.
    */
    MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: 'messaging.message_payload_compressed_size_bytes',
    /**
    * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
    */
    MESSAGING_OPERATION: 'messaging.operation',
    /**
    * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
    */
    MESSAGING_CONSUMER_ID: 'messaging.consumer_id',
    /**
    * RabbitMQ message routing key.
    */
    MESSAGING_RABBITMQ_ROUTING_KEY: 'messaging.rabbitmq.routing_key',
    /**
    * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
    *
    * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
    */
    MESSAGING_KAFKA_MESSAGE_KEY: 'messaging.kafka.message_key',
    /**
    * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
    */
    MESSAGING_KAFKA_CONSUMER_GROUP: 'messaging.kafka.consumer_group',
    /**
    * Client Id for the Consumer or Producer that is handling the message.
    */
    MESSAGING_KAFKA_CLIENT_ID: 'messaging.kafka.client_id',
    /**
    * Partition the message is sent to.
    */
    MESSAGING_KAFKA_PARTITION: 'messaging.kafka.partition',
    /**
    * A boolean that is true if the message is a tombstone.
    */
    MESSAGING_KAFKA_TOMBSTONE: 'messaging.kafka.tombstone',
    /**
    * A string identifying the remoting system.
    */
    RPC_SYSTEM: 'rpc.system',
    /**
    * The full (logical) name of the service being called, including its package name, if applicable.
    *
    * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
    */
    RPC_SERVICE: 'rpc.service',
    /**
    * The name of the (logical) method being called, must be equal to the $method part in the span name.
    *
    * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
    */
    RPC_METHOD: 'rpc.method',
    /**
    * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
    */
    RPC_GRPC_STATUS_CODE: 'rpc.grpc.status_code',
    /**
    * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
    */
    RPC_JSONRPC_VERSION: 'rpc.jsonrpc.version',
    /**
    * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
    */
    RPC_JSONRPC_REQUEST_ID: 'rpc.jsonrpc.request_id',
    /**
    * `error.code` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_CODE: 'rpc.jsonrpc.error_code',
    /**
    * `error.message` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_MESSAGE: 'rpc.jsonrpc.error_message',
    /**
    * Whether this is a received or sent message.
    */
    MESSAGE_TYPE: 'message.type',
    /**
    * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
    *
    * Note: This way we guarantee that the values will be consistent between different implementations.
    */
    MESSAGE_ID: 'message.id',
    /**
    * Compressed size of the message in bytes.
    */
    MESSAGE_COMPRESSED_SIZE: 'message.compressed_size',
    /**
    * Uncompressed size of the message in bytes.
    */
    MESSAGE_UNCOMPRESSED_SIZE: 'message.uncompressed_size',
};
var SemanticAttributes_DbSystemValues = {
    /** Some other SQL database. Fallback only. See notes. */
    OTHER_SQL: 'other_sql',
    /** Microsoft SQL Server. */
    MSSQL: 'mssql',
    /** MySQL. */
    MYSQL: 'mysql',
    /** Oracle Database. */
    ORACLE: 'oracle',
    /** IBM Db2. */
    DB2: 'db2',
    /** PostgreSQL. */
    POSTGRESQL: 'postgresql',
    /** Amazon Redshift. */
    REDSHIFT: 'redshift',
    /** Apache Hive. */
    HIVE: 'hive',
    /** Cloudscape. */
    CLOUDSCAPE: 'cloudscape',
    /** HyperSQL DataBase. */
    HSQLDB: 'hsqldb',
    /** Progress Database. */
    PROGRESS: 'progress',
    /** SAP MaxDB. */
    MAXDB: 'maxdb',
    /** SAP HANA. */
    HANADB: 'hanadb',
    /** Ingres. */
    INGRES: 'ingres',
    /** FirstSQL. */
    FIRSTSQL: 'firstsql',
    /** EnterpriseDB. */
    EDB: 'edb',
    /** InterSystems Caché. */
    CACHE: 'cache',
    /** Adabas (Adaptable Database System). */
    ADABAS: 'adabas',
    /** Firebird. */
    FIREBIRD: 'firebird',
    /** Apache Derby. */
    DERBY: 'derby',
    /** FileMaker. */
    FILEMAKER: 'filemaker',
    /** Informix. */
    INFORMIX: 'informix',
    /** InstantDB. */
    INSTANTDB: 'instantdb',
    /** InterBase. */
    INTERBASE: 'interbase',
    /** MariaDB. */
    MARIADB: 'mariadb',
    /** Netezza. */
    NETEZZA: 'netezza',
    /** Pervasive PSQL. */
    PERVASIVE: 'pervasive',
    /** PointBase. */
    POINTBASE: 'pointbase',
    /** SQLite. */
    SQLITE: 'sqlite',
    /** Sybase. */
    SYBASE: 'sybase',
    /** Teradata. */
    TERADATA: 'teradata',
    /** Vertica. */
    VERTICA: 'vertica',
    /** H2. */
    H2: 'h2',
    /** ColdFusion IMQ. */
    COLDFUSION: 'coldfusion',
    /** Apache Cassandra. */
    CASSANDRA: 'cassandra',
    /** Apache HBase. */
    HBASE: 'hbase',
    /** MongoDB. */
    MONGODB: 'mongodb',
    /** Redis. */
    REDIS: 'redis',
    /** Couchbase. */
    COUCHBASE: 'couchbase',
    /** CouchDB. */
    COUCHDB: 'couchdb',
    /** Microsoft Azure Cosmos DB. */
    COSMOSDB: 'cosmosdb',
    /** Amazon DynamoDB. */
    DYNAMODB: 'dynamodb',
    /** Neo4j. */
    NEO4J: 'neo4j',
    /** Apache Geode. */
    GEODE: 'geode',
    /** Elasticsearch. */
    ELASTICSEARCH: 'elasticsearch',
    /** Memcached. */
    MEMCACHED: 'memcached',
    /** CockroachDB. */
    COCKROACHDB: 'cockroachdb',
};
var SemanticAttributes_DbCassandraConsistencyLevelValues = {
    /** all. */
    ALL: 'all',
    /** each_quorum. */
    EACH_QUORUM: 'each_quorum',
    /** quorum. */
    QUORUM: 'quorum',
    /** local_quorum. */
    LOCAL_QUORUM: 'local_quorum',
    /** one. */
    ONE: 'one',
    /** two. */
    TWO: 'two',
    /** three. */
    THREE: 'three',
    /** local_one. */
    LOCAL_ONE: 'local_one',
    /** any. */
    ANY: 'any',
    /** serial. */
    SERIAL: 'serial',
    /** local_serial. */
    LOCAL_SERIAL: 'local_serial',
};
var SemanticAttributes_FaasTriggerValues = {
    /** A response to some data source operation such as a database or filesystem read/write. */
    DATASOURCE: 'datasource',
    /** To provide an answer to an inbound HTTP request. */
    HTTP: 'http',
    /** A function is set to be executed when messages are sent to a messaging system. */
    PUBSUB: 'pubsub',
    /** A function is scheduled to be executed regularly. */
    TIMER: 'timer',
    /** If none of the others apply. */
    OTHER: 'other',
};
var SemanticAttributes_FaasDocumentOperationValues = {
    /** When a new object is created. */
    INSERT: 'insert',
    /** When an object is modified. */
    EDIT: 'edit',
    /** When an object is deleted. */
    DELETE: 'delete',
};
var SemanticAttributes_FaasInvokedProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var SemanticAttributes_NetTransportValues = {
    /** ip_tcp. */
    IP_TCP: 'ip_tcp',
    /** ip_udp. */
    IP_UDP: 'ip_udp',
    /** Another IP-based protocol. */
    IP: 'ip',
    /** Unix Domain socket. See below. */
    UNIX: 'unix',
    /** Named or anonymous pipe. See note below. */
    PIPE: 'pipe',
    /** In-process communication. */
    INPROC: 'inproc',
    /** Something else (non IP-based). */
    OTHER: 'other',
};
var SemanticAttributes_NetHostConnectionTypeValues = {
    /** wifi. */
    WIFI: 'wifi',
    /** wired. */
    WIRED: 'wired',
    /** cell. */
    CELL: 'cell',
    /** unavailable. */
    UNAVAILABLE: 'unavailable',
    /** unknown. */
    UNKNOWN: 'unknown',
};
var SemanticAttributes_NetHostConnectionSubtypeValues = {
    /** GPRS. */
    GPRS: 'gprs',
    /** EDGE. */
    EDGE: 'edge',
    /** UMTS. */
    UMTS: 'umts',
    /** CDMA. */
    CDMA: 'cdma',
    /** EVDO Rel. 0. */
    EVDO_0: 'evdo_0',
    /** EVDO Rev. A. */
    EVDO_A: 'evdo_a',
    /** CDMA2000 1XRTT. */
    CDMA2000_1XRTT: 'cdma2000_1xrtt',
    /** HSDPA. */
    HSDPA: 'hsdpa',
    /** HSUPA. */
    HSUPA: 'hsupa',
    /** HSPA. */
    HSPA: 'hspa',
    /** IDEN. */
    IDEN: 'iden',
    /** EVDO Rev. B. */
    EVDO_B: 'evdo_b',
    /** LTE. */
    LTE: 'lte',
    /** EHRPD. */
    EHRPD: 'ehrpd',
    /** HSPAP. */
    HSPAP: 'hspap',
    /** GSM. */
    GSM: 'gsm',
    /** TD-SCDMA. */
    TD_SCDMA: 'td_scdma',
    /** IWLAN. */
    IWLAN: 'iwlan',
    /** 5G NR (New Radio). */
    NR: 'nr',
    /** 5G NRNSA (New Radio Non-Standalone). */
    NRNSA: 'nrnsa',
    /** LTE CA. */
    LTE_CA: 'lte_ca',
};
var SemanticAttributes_HttpFlavorValues = {
    /** HTTP 1.0. */
    HTTP_1_0: '1.0',
    /** HTTP 1.1. */
    HTTP_1_1: '1.1',
    /** HTTP 2. */
    HTTP_2_0: '2.0',
    /** SPDY protocol. */
    SPDY: 'SPDY',
    /** QUIC protocol. */
    QUIC: 'QUIC',
};
var SemanticAttributes_MessagingDestinationKindValues = {
    /** A message sent to a queue. */
    QUEUE: 'queue',
    /** A message sent to a topic. */
    TOPIC: 'topic',
};
var SemanticAttributes_MessagingOperationValues = {
    /** receive. */
    RECEIVE: 'receive',
    /** process. */
    PROCESS: 'process',
};
var SemanticAttributes_RpcGrpcStatusCodeValues = {
    /** OK. */
    OK: 0,
    /** CANCELLED. */
    CANCELLED: 1,
    /** UNKNOWN. */
    UNKNOWN: 2,
    /** INVALID_ARGUMENT. */
    INVALID_ARGUMENT: 3,
    /** DEADLINE_EXCEEDED. */
    DEADLINE_EXCEEDED: 4,
    /** NOT_FOUND. */
    NOT_FOUND: 5,
    /** ALREADY_EXISTS. */
    ALREADY_EXISTS: 6,
    /** PERMISSION_DENIED. */
    PERMISSION_DENIED: 7,
    /** RESOURCE_EXHAUSTED. */
    RESOURCE_EXHAUSTED: 8,
    /** FAILED_PRECONDITION. */
    FAILED_PRECONDITION: 9,
    /** ABORTED. */
    ABORTED: 10,
    /** OUT_OF_RANGE. */
    OUT_OF_RANGE: 11,
    /** UNIMPLEMENTED. */
    UNIMPLEMENTED: 12,
    /** INTERNAL. */
    INTERNAL: 13,
    /** UNAVAILABLE. */
    UNAVAILABLE: 14,
    /** DATA_LOSS. */
    DATA_LOSS: 15,
    /** UNAUTHENTICATED. */
    UNAUTHENTICATED: 16,
};
var SemanticAttributes_MessageTypeValues = {
    /** sent. */
    SENT: 'SENT',
    /** received. */
    RECEIVED: 'RECEIVED',
};
//# sourceMappingURL=SemanticAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var SemanticResourceAttributes_SemanticResourceAttributes = {
    /**
    * Name of the cloud provider.
    */
    CLOUD_PROVIDER: 'cloud.provider',
    /**
    * The cloud account ID the resource is assigned to.
    */
    CLOUD_ACCOUNT_ID: 'cloud.account.id',
    /**
    * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
    */
    CLOUD_REGION: 'cloud.region',
    /**
    * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
    *
    * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
    */
    CLOUD_AVAILABILITY_ZONE: 'cloud.availability_zone',
    /**
    * The cloud platform in use.
    *
    * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
    */
    CLOUD_PLATFORM: 'cloud.platform',
    /**
    * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
    */
    AWS_ECS_CONTAINER_ARN: 'aws.ecs.container.arn',
    /**
    * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
    */
    AWS_ECS_CLUSTER_ARN: 'aws.ecs.cluster.arn',
    /**
    * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
    */
    AWS_ECS_LAUNCHTYPE: 'aws.ecs.launchtype',
    /**
    * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
    */
    AWS_ECS_TASK_ARN: 'aws.ecs.task.arn',
    /**
    * The task definition family this task definition is a member of.
    */
    AWS_ECS_TASK_FAMILY: 'aws.ecs.task.family',
    /**
    * The revision for this task definition.
    */
    AWS_ECS_TASK_REVISION: 'aws.ecs.task.revision',
    /**
    * The ARN of an EKS cluster.
    */
    AWS_EKS_CLUSTER_ARN: 'aws.eks.cluster.arn',
    /**
    * The name(s) of the AWS log group(s) an application is writing to.
    *
    * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
    */
    AWS_LOG_GROUP_NAMES: 'aws.log.group.names',
    /**
    * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
    *
    * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
    */
    AWS_LOG_GROUP_ARNS: 'aws.log.group.arns',
    /**
    * The name(s) of the AWS log stream(s) an application is writing to.
    */
    AWS_LOG_STREAM_NAMES: 'aws.log.stream.names',
    /**
    * The ARN(s) of the AWS log stream(s).
    *
    * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
    */
    AWS_LOG_STREAM_ARNS: 'aws.log.stream.arns',
    /**
    * Container name.
    */
    CONTAINER_NAME: 'container.name',
    /**
    * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
    */
    CONTAINER_ID: 'container.id',
    /**
    * The container runtime managing this container.
    */
    CONTAINER_RUNTIME: 'container.runtime',
    /**
    * Name of the image the container was built on.
    */
    CONTAINER_IMAGE_NAME: 'container.image.name',
    /**
    * Container image tag.
    */
    CONTAINER_IMAGE_TAG: 'container.image.tag',
    /**
    * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
    */
    DEPLOYMENT_ENVIRONMENT: 'deployment.environment',
    /**
    * A unique identifier representing the device.
    *
    * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
    */
    DEVICE_ID: 'device.id',
    /**
    * The model identifier for the device.
    *
    * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
    */
    DEVICE_MODEL_IDENTIFIER: 'device.model.identifier',
    /**
    * The marketing name for the device model.
    *
    * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
    */
    DEVICE_MODEL_NAME: 'device.model.name',
    /**
    * The name of the single function that this runtime instance executes.
    *
    * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
    */
    FAAS_NAME: 'faas.name',
    /**
    * The unique ID of the single function that this runtime instance executes.
    *
    * Note: Depending on the cloud provider, use:
  
  * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
  Take care not to use the &#34;invoked ARN&#34; directly but replace any
  [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
  different aliases.
  * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
  * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
  
  On some providers, it may not be possible to determine the full ID at startup,
  which is why this field cannot be made required. For example, on AWS the account ID
  part of the ARN is not available without calling another AWS API
  which may be deemed too slow for a short-running lambda function.
  As an alternative, consider setting `faas.id` as a span attribute instead.
    */
    FAAS_ID: 'faas.id',
    /**
    * The immutable version of the function being executed.
    *
    * Note: Depending on the cloud provider and platform, use:
  
  * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
    (an integer represented as a decimal string).
  * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
    (i.e., the function name plus the revision suffix).
  * **Google Cloud Functions:** The value of the
    [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
  * **Azure Functions:** Not applicable. Do not set this attribute.
    */
    FAAS_VERSION: 'faas.version',
    /**
    * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
    *
    * Note: * **AWS Lambda:** Use the (full) log stream name.
    */
    FAAS_INSTANCE: 'faas.instance',
    /**
    * The amount of memory available to the serverless function in MiB.
    *
    * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
    */
    FAAS_MAX_MEMORY: 'faas.max_memory',
    /**
    * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
    */
    HOST_ID: 'host.id',
    /**
    * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
    */
    HOST_NAME: 'host.name',
    /**
    * Type of host. For Cloud, this must be the machine type.
    */
    HOST_TYPE: 'host.type',
    /**
    * The CPU architecture the host system is running on.
    */
    HOST_ARCH: 'host.arch',
    /**
    * Name of the VM image or OS install the host was instantiated from.
    */
    HOST_IMAGE_NAME: 'host.image.name',
    /**
    * VM image ID. For Cloud, this value is from the provider.
    */
    HOST_IMAGE_ID: 'host.image.id',
    /**
    * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
    */
    HOST_IMAGE_VERSION: 'host.image.version',
    /**
    * The name of the cluster.
    */
    K8S_CLUSTER_NAME: 'k8s.cluster.name',
    /**
    * The name of the Node.
    */
    K8S_NODE_NAME: 'k8s.node.name',
    /**
    * The UID of the Node.
    */
    K8S_NODE_UID: 'k8s.node.uid',
    /**
    * The name of the namespace that the pod is running in.
    */
    K8S_NAMESPACE_NAME: 'k8s.namespace.name',
    /**
    * The UID of the Pod.
    */
    K8S_POD_UID: 'k8s.pod.uid',
    /**
    * The name of the Pod.
    */
    K8S_POD_NAME: 'k8s.pod.name',
    /**
    * The name of the Container in a Pod template.
    */
    K8S_CONTAINER_NAME: 'k8s.container.name',
    /**
    * The UID of the ReplicaSet.
    */
    K8S_REPLICASET_UID: 'k8s.replicaset.uid',
    /**
    * The name of the ReplicaSet.
    */
    K8S_REPLICASET_NAME: 'k8s.replicaset.name',
    /**
    * The UID of the Deployment.
    */
    K8S_DEPLOYMENT_UID: 'k8s.deployment.uid',
    /**
    * The name of the Deployment.
    */
    K8S_DEPLOYMENT_NAME: 'k8s.deployment.name',
    /**
    * The UID of the StatefulSet.
    */
    K8S_STATEFULSET_UID: 'k8s.statefulset.uid',
    /**
    * The name of the StatefulSet.
    */
    K8S_STATEFULSET_NAME: 'k8s.statefulset.name',
    /**
    * The UID of the DaemonSet.
    */
    K8S_DAEMONSET_UID: 'k8s.daemonset.uid',
    /**
    * The name of the DaemonSet.
    */
    K8S_DAEMONSET_NAME: 'k8s.daemonset.name',
    /**
    * The UID of the Job.
    */
    K8S_JOB_UID: 'k8s.job.uid',
    /**
    * The name of the Job.
    */
    K8S_JOB_NAME: 'k8s.job.name',
    /**
    * The UID of the CronJob.
    */
    K8S_CRONJOB_UID: 'k8s.cronjob.uid',
    /**
    * The name of the CronJob.
    */
    K8S_CRONJOB_NAME: 'k8s.cronjob.name',
    /**
    * The operating system type.
    */
    OS_TYPE: 'os.type',
    /**
    * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
    */
    OS_DESCRIPTION: 'os.description',
    /**
    * Human readable operating system name.
    */
    OS_NAME: 'os.name',
    /**
    * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
    */
    OS_VERSION: 'os.version',
    /**
    * Process identifier (PID).
    */
    PROCESS_PID: 'process.pid',
    /**
    * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_NAME: 'process.executable.name',
    /**
    * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_PATH: 'process.executable.path',
    /**
    * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
    */
    PROCESS_COMMAND: 'process.command',
    /**
    * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
    */
    PROCESS_COMMAND_LINE: 'process.command_line',
    /**
    * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
    */
    PROCESS_COMMAND_ARGS: 'process.command_args',
    /**
    * The username of the user that owns the process.
    */
    PROCESS_OWNER: 'process.owner',
    /**
    * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
    */
    PROCESS_RUNTIME_NAME: 'process.runtime.name',
    /**
    * The version of the runtime of this process, as returned by the runtime without modification.
    */
    PROCESS_RUNTIME_VERSION: 'process.runtime.version',
    /**
    * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
    */
    PROCESS_RUNTIME_DESCRIPTION: 'process.runtime.description',
    /**
    * Logical name of the service.
    *
    * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
    */
    SERVICE_NAME: 'service.name',
    /**
    * A namespace for `service.name`.
    *
    * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
    */
    SERVICE_NAMESPACE: 'service.namespace',
    /**
    * The string ID of the service instance.
    *
    * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
    */
    SERVICE_INSTANCE_ID: 'service.instance.id',
    /**
    * The version string of the service API or implementation.
    */
    SERVICE_VERSION: 'service.version',
    /**
    * The name of the telemetry SDK as defined above.
    */
    TELEMETRY_SDK_NAME: 'telemetry.sdk.name',
    /**
    * The language of the telemetry SDK.
    */
    TELEMETRY_SDK_LANGUAGE: 'telemetry.sdk.language',
    /**
    * The version string of the telemetry SDK.
    */
    TELEMETRY_SDK_VERSION: 'telemetry.sdk.version',
    /**
    * The version string of the auto instrumentation agent, if used.
    */
    TELEMETRY_AUTO_VERSION: 'telemetry.auto.version',
    /**
    * The name of the web engine.
    */
    WEBENGINE_NAME: 'webengine.name',
    /**
    * The version of the web engine.
    */
    WEBENGINE_VERSION: 'webengine.version',
    /**
    * Additional description of the web engine (e.g. detailed version and edition information).
    */
    WEBENGINE_DESCRIPTION: 'webengine.description',
};
var SemanticResourceAttributes_CloudProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var SemanticResourceAttributes_CloudPlatformValues = {
    /** Alibaba Cloud Elastic Compute Service. */
    ALIBABA_CLOUD_ECS: 'alibaba_cloud_ecs',
    /** Alibaba Cloud Function Compute. */
    ALIBABA_CLOUD_FC: 'alibaba_cloud_fc',
    /** AWS Elastic Compute Cloud. */
    AWS_EC2: 'aws_ec2',
    /** AWS Elastic Container Service. */
    AWS_ECS: 'aws_ecs',
    /** AWS Elastic Kubernetes Service. */
    AWS_EKS: 'aws_eks',
    /** AWS Lambda. */
    AWS_LAMBDA: 'aws_lambda',
    /** AWS Elastic Beanstalk. */
    AWS_ELASTIC_BEANSTALK: 'aws_elastic_beanstalk',
    /** Azure Virtual Machines. */
    AZURE_VM: 'azure_vm',
    /** Azure Container Instances. */
    AZURE_CONTAINER_INSTANCES: 'azure_container_instances',
    /** Azure Kubernetes Service. */
    AZURE_AKS: 'azure_aks',
    /** Azure Functions. */
    AZURE_FUNCTIONS: 'azure_functions',
    /** Azure App Service. */
    AZURE_APP_SERVICE: 'azure_app_service',
    /** Google Cloud Compute Engine (GCE). */
    GCP_COMPUTE_ENGINE: 'gcp_compute_engine',
    /** Google Cloud Run. */
    GCP_CLOUD_RUN: 'gcp_cloud_run',
    /** Google Cloud Kubernetes Engine (GKE). */
    GCP_KUBERNETES_ENGINE: 'gcp_kubernetes_engine',
    /** Google Cloud Functions (GCF). */
    GCP_CLOUD_FUNCTIONS: 'gcp_cloud_functions',
    /** Google Cloud App Engine (GAE). */
    GCP_APP_ENGINE: 'gcp_app_engine',
};
var SemanticResourceAttributes_AwsEcsLaunchtypeValues = {
    /** ec2. */
    EC2: 'ec2',
    /** fargate. */
    FARGATE: 'fargate',
};
var SemanticResourceAttributes_HostArchValues = {
    /** AMD64. */
    AMD64: 'amd64',
    /** ARM32. */
    ARM32: 'arm32',
    /** ARM64. */
    ARM64: 'arm64',
    /** Itanium. */
    IA64: 'ia64',
    /** 32-bit PowerPC. */
    PPC32: 'ppc32',
    /** 64-bit PowerPC. */
    PPC64: 'ppc64',
    /** 32-bit x86. */
    X86: 'x86',
};
var SemanticResourceAttributes_OsTypeValues = {
    /** Microsoft Windows. */
    WINDOWS: 'windows',
    /** Linux. */
    LINUX: 'linux',
    /** Apple Darwin. */
    DARWIN: 'darwin',
    /** FreeBSD. */
    FREEBSD: 'freebsd',
    /** NetBSD. */
    NETBSD: 'netbsd',
    /** OpenBSD. */
    OPENBSD: 'openbsd',
    /** DragonFly BSD. */
    DRAGONFLYBSD: 'dragonflybsd',
    /** HP-UX (Hewlett Packard Unix). */
    HPUX: 'hpux',
    /** AIX (Advanced Interactive eXecutive). */
    AIX: 'aix',
    /** Oracle Solaris. */
    SOLARIS: 'solaris',
    /** IBM z/OS. */
    Z_OS: 'z_os',
};
var SemanticResourceAttributes_TelemetrySdkLanguageValues = {
    /** cpp. */
    CPP: 'cpp',
    /** dotnet. */
    DOTNET: 'dotnet',
    /** erlang. */
    ERLANG: 'erlang',
    /** go. */
    GO: 'go',
    /** java. */
    JAVA: 'java',
    /** nodejs. */
    NODEJS: 'nodejs',
    /** php. */
    PHP: 'php',
    /** python. */
    PYTHON: 'python',
    /** ruby. */
    RUBY: 'ruby',
    /** webjs. */
    WEBJS: 'webjs',
};
//# sourceMappingURL=SemanticResourceAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/platform/browser/sdk-info.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var sdk_info_a;


/** Constants describing the SDK in use */
var sdk_info_SDK_INFO = (sdk_info_a = {},
    sdk_info_a[SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_NAME] = 'opentelemetry',
    sdk_info_a[SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = 'browser',
    sdk_info_a[SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = SemanticResourceAttributes_TelemetrySdkLanguageValues.WEBJS,
    sdk_info_a[SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = esm_version_VERSION,
    sdk_info_a);
//# sourceMappingURL=sdk-info.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/platform/browser/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/common/time.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var time_NANOSECOND_DIGITS = 9;
var time_SECOND_TO_NANOSECONDS = Math.pow(10, time_NANOSECOND_DIGITS);
/**
 * Converts a number to HrTime, HrTime = [number, number].
 * The first number is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * numberToHrtime calculates the first number by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * numberToHrtime calculates the second number by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * SECOND_TO_NANOSECONDS = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 * @param epochMillis
 */
function time_numberToHrtime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Number((epochSeconds - seconds).toFixed(time_NANOSECOND_DIGITS)) *
        time_SECOND_TO_NANOSECONDS;
    return [seconds, nanos];
}
function time_getTimeOrigin() {
    var timeOrigin = performance.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = performance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function time_hrTime(performanceNow) {
    var timeOrigin = time_numberToHrtime(time_getTimeOrigin());
    var now = time_numberToHrtime(typeof performanceNow === 'number' ? performanceNow : performance.now());
    var seconds = timeOrigin[0] + now[0];
    var nanos = timeOrigin[1] + now[1];
    // Nanoseconds
    if (nanos > time_SECOND_TO_NANOSECONDS) {
        nanos -= time_SECOND_TO_NANOSECONDS;
        seconds += 1;
    }
    return [seconds, nanos];
}
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */
function time_timeInputToHrTime(time) {
    // process.hrtime
    if (time_isTimeInputHrTime(time)) {
        return time;
    }
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < time_getTimeOrigin()) {
            return time_hrTime(time);
        }
        else {
            // epoch milliseconds or performance.timeOrigin
            return time_numberToHrtime(time);
        }
    }
    else if (time instanceof Date) {
        return time_numberToHrtime(time.getTime());
    }
    else {
        throw TypeError('Invalid input type');
    }
}
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */
function time_hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += time_SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
}
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */
function time_hrTimeToTimeStamp(time) {
    var precision = time_NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substr(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */
function common_time_hrTimeToNanoseconds(time) {
    return time[0] * time_SECOND_TO_NANOSECONDS + time[1];
}
/**
 * Convert hrTime to milliseconds.
 * @param time
 */
function time_hrTimeToMilliseconds(time) {
    return Math.round(time[0] * 1e3 + time[1] / 1e6);
}
/**
 * Convert hrTime to microseconds.
 * @param time
 */
function time_hrTimeToMicroseconds(time) {
    return Math.round(time[0] * 1e6 + time[1] / 1e3);
}
/**
 * check if time is HrTime
 * @param value
 */
function time_isTimeInputHrTime(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        typeof value[0] === 'number' &&
        typeof value[1] === 'number');
}
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */
function time_isTimeInput(value) {
    return (time_isTimeInputHrTime(value) ||
        typeof value === 'number' ||
        value instanceof Date);
}
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/ExportResult.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ExportResult_ExportResultCode;
(function (ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(ExportResult_ExportResultCode || (ExportResult_ExportResultCode = {}));
//# sourceMappingURL=ExportResult.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/propagation/composite.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var propagation_composite_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

/** Combines multiple propagators into a single propagator. */
var composite_CompositePropagator = /** @class */ (function () {
    /**
     * Construct a composite propagator from a list of propagators.
     *
     * @param [config] Configuration object for composite propagator
     */
    function CompositePropagator(config) {
        if (config === void 0) { config = {}; }
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators
            // older propagators may not have fields function, null check to be sure
            .map(function (p) { return (typeof p.fields === 'function' ? p.fields() : []); })
            .reduce(function (x, y) { return x.concat(y); }, [])));
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same carrier key, the propagator later in the list
     * will "win".
     *
     * @param context Context to inject
     * @param carrier Carrier into which context will be injected
     */
    CompositePropagator.prototype.inject = function (context, carrier, setter) {
        var e_1, _a;
        try {
            for (var _b = propagation_composite_values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propagator = _c.value;
                try {
                    propagator.inject(context, carrier, setter);
                }
                catch (err) {
                    esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same context key, the propagator later in the list
     * will "win".
     *
     * @param context Context to add values to
     * @param carrier Carrier from which to extract context
     */
    CompositePropagator.prototype.extract = function (context, carrier, getter) {
        return this._propagators.reduce(function (ctx, propagator) {
            try {
                return propagator.extract(ctx, carrier, getter);
            }
            catch (err) {
                esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
            return ctx;
        }, context);
    };
    CompositePropagator.prototype.fields = function () {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
    };
    return CompositePropagator;
}());

//# sourceMappingURL=composite.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/internal/validators.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var internal_validators_VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var internal_validators_VALID_KEY = "[a-z]" + internal_validators_VALID_KEY_CHAR_RANGE + "{0,255}";
var internal_validators_VALID_VENDOR_KEY = "[a-z0-9]" + internal_validators_VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + internal_validators_VALID_KEY_CHAR_RANGE + "{0,13}";
var internal_validators_VALID_KEY_REGEX = new RegExp("^(?:" + internal_validators_VALID_KEY + "|" + internal_validators_VALID_VENDOR_KEY + ")$");
var internal_validators_VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var internal_validators_INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */
function internal_validators_validateKey(key) {
    return internal_validators_VALID_KEY_REGEX.test(key);
}
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */
function internal_validators_validateValue(value) {
    return (internal_validators_VALID_VALUE_BASE_REGEX.test(value) &&
        !internal_validators_INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));
}
//# sourceMappingURL=validators.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/trace/TraceState.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var trace_TraceState_MAX_TRACE_STATE_ITEMS = 32;
var trace_TraceState_MAX_TRACE_STATE_LEN = 512;
var trace_TraceState_LIST_MEMBERS_SEPARATOR = ',';
var trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */
var TraceState_TraceState = /** @class */ (function () {
    function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState)
            this._parse(rawTraceState);
    }
    TraceState.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
            traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceState.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceState.prototype.get = function (key) {
        return this._internalState.get(key);
    };
    TraceState.prototype.serialize = function () {
        var _this = this;
        return this._keys()
            .reduce(function (agg, key) {
            agg.push(key + trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, [])
            .join(trace_TraceState_LIST_MEMBERS_SEPARATOR);
    };
    TraceState.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > trace_TraceState_MAX_TRACE_STATE_LEN)
            return;
        this._internalState = rawTraceState
            .split(trace_TraceState_LIST_MEMBERS_SEPARATOR)
            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
            .reduce(function (agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if (internal_validators_validateKey(key) && internal_validators_validateValue(value)) {
                    agg.set(key, value);
                }
                else {
                    // TODO: Consider to add warning log
                }
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > trace_TraceState_MAX_TRACE_STATE_ITEMS) {
            this._internalState = new Map(Array.from(this._internalState.entries())
                .reverse() // Use reverse same as original tracestate parse chain
                .slice(0, trace_TraceState_MAX_TRACE_STATE_ITEMS));
        }
    };
    TraceState.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceState.prototype._clone = function () {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceState;
}());

//# sourceMappingURL=TraceState.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var W3CTraceContextPropagator_TRACE_PARENT_HEADER = 'traceparent';
var W3CTraceContextPropagator_TRACE_STATE_HEADER = 'tracestate';
var trace_W3CTraceContextPropagator_VERSION = '00';
var W3CTraceContextPropagator_VERSION_PART = '(?!ff)[\\da-f]{2}';
var W3CTraceContextPropagator_TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
var W3CTraceContextPropagator_PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
var W3CTraceContextPropagator_FLAGS_PART = '[\\da-f]{2}';
var W3CTraceContextPropagator_TRACE_PARENT_REGEX = new RegExp("^\\s?(" + W3CTraceContextPropagator_VERSION_PART + ")-(" + W3CTraceContextPropagator_TRACE_ID_PART + ")-(" + W3CTraceContextPropagator_PARENT_ID_PART + ")-(" + W3CTraceContextPropagator_FLAGS_PART + ")(-.*)?\\s?$");
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */
function W3CTraceContextPropagator_parseTraceParent(traceParent) {
    var match = W3CTraceContextPropagator_TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
        return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5])
        return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16),
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */
var W3CTraceContextPropagator_W3CTraceContextPropagator = /** @class */ (function () {
    function W3CTraceContextPropagator() {
    }
    W3CTraceContextPropagator.prototype.inject = function (context, carrier, setter) {
        var spanContext = trace.getSpanContext(context);
        if (!spanContext ||
            suppress_tracing_isTracingSuppressed(context) ||
            !isSpanContextValid(spanContext))
            return;
        var traceParent = trace_W3CTraceContextPropagator_VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, W3CTraceContextPropagator_TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
            setter.set(carrier, W3CTraceContextPropagator_TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
    };
    W3CTraceContextPropagator.prototype.extract = function (context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, W3CTraceContextPropagator_TRACE_PARENT_HEADER);
        if (!traceParentHeader)
            return context;
        var traceParent = Array.isArray(traceParentHeader)
            ? traceParentHeader[0]
            : traceParentHeader;
        if (typeof traceParent !== 'string')
            return context;
        var spanContext = W3CTraceContextPropagator_parseTraceParent(traceParent);
        if (!spanContext)
            return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, W3CTraceContextPropagator_TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            var state = Array.isArray(traceStateHeader)
                ? traceStateHeader.join(',')
                : traceStateHeader;
            spanContext.traceState = new TraceState_TraceState(typeof state === 'string' ? state : undefined);
        }
        return trace.setSpanContext(context, spanContext);
    };
    W3CTraceContextPropagator.prototype.fields = function () {
        return [W3CTraceContextPropagator_TRACE_PARENT_HEADER, W3CTraceContextPropagator_TRACE_STATE_HEADER];
    };
    return W3CTraceContextPropagator;
}());

//# sourceMappingURL=W3CTraceContextPropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var RPC_METADATA_KEY = createContextKey('OpenTelemetry SDK Context Key RPC_METADATA');
var RPCType;
(function (RPCType) {
    RPCType["HTTP"] = "http";
})(RPCType || (RPCType = {}));
function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
}
function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
}
function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
}
//# sourceMappingURL=rpc-metadata.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples no traces.
 */
var AlwaysOffSampler_AlwaysOffSampler = /** @class */ (function () {
    function AlwaysOffSampler() {
    }
    AlwaysOffSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.NOT_RECORD,
        };
    };
    AlwaysOffSampler.prototype.toString = function () {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}());

//# sourceMappingURL=AlwaysOffSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples all traces.
 */
var AlwaysOnSampler_AlwaysOnSampler = /** @class */ (function () {
    function AlwaysOnSampler() {
    }
    AlwaysOnSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.RECORD_AND_SAMPLED,
        };
    };
    AlwaysOnSampler.prototype.toString = function () {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}());

//# sourceMappingURL=AlwaysOnSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */
var ParentBasedSampler_ParentBasedSampler = /** @class */ (function () {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            global_error_handler_globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new AlwaysOnSampler_AlwaysOnSampler();
        }
        this._remoteParentSampled =
            (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_AlwaysOnSampler();
        this._remoteParentNotSampled =
            (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_AlwaysOffSampler();
        this._localParentSampled =
            (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_AlwaysOnSampler();
        this._localParentNotSampled =
            (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_AlwaysOffSampler();
    }
    ParentBasedSampler.prototype.shouldSample = function (context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
            return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & TraceFlags.SAMPLED) {
                return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            }
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function () {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}());

//# sourceMappingURL=ParentBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples a given fraction of traces based of trace id deterministically.
 */
var TraceIdRatioBasedSampler_TraceIdRatioBasedSampler = /** @class */ (function () {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) { _ratio = 0; }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function (context, traceId) {
        return {
            decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound
                ? SamplingDecision.RECORD_AND_SAMPLED
                : SamplingDecision.NOT_RECORD,
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function () {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function (ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio))
            return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function (traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}());

//# sourceMappingURL=TraceIdRatioBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * based on lodash in order to support esm builds without esModuleInterop.
 * lodash is using MIT License.
 **/
var lodash_merge_objectTag = '[object Object]';
var lodash_merge_nullTag = '[object Null]';
var lodash_merge_undefinedTag = '[object Undefined]';
var lodash_merge_funcProto = Function.prototype;
var lodash_merge_funcToString = lodash_merge_funcProto.toString;
var lodash_merge_objectCtorString = lodash_merge_funcToString.call(Object);
var lodash_merge_getPrototype = lodash_merge_overArg(Object.getPrototypeOf, Object);
var lodash_merge_objectProto = Object.prototype;
var utils_lodash_merge_hasOwnProperty = lodash_merge_objectProto.hasOwnProperty;
var lodash_merge_symToStringTag = Symbol ? Symbol.toStringTag : undefined;
var lodash_merge_nativeObjectToString = lodash_merge_objectProto.toString;
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function lodash_merge_overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function utils_lodash_merge_isPlainObject(value) {
    if (!lodash_merge_isObjectLike(value) || lodash_merge_baseGetTag(value) !== lodash_merge_objectTag) {
        return false;
    }
    var proto = lodash_merge_getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = utils_lodash_merge_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        lodash_merge_funcToString.call(Ctor) === lodash_merge_objectCtorString;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function lodash_merge_isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function lodash_merge_baseGetTag(value) {
    if (value == null) {
        return value === undefined ? lodash_merge_undefinedTag : lodash_merge_nullTag;
    }
    return (lodash_merge_symToStringTag && lodash_merge_symToStringTag in Object(value))
        ? lodash_merge_getRawTag(value)
        : lodash_merge_objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function lodash_merge_getRawTag(value) {
    var isOwn = utils_lodash_merge_hasOwnProperty.call(value, lodash_merge_symToStringTag), tag = value[lodash_merge_symToStringTag];
    var unmasked = false;
    try {
        value[lodash_merge_symToStringTag] = undefined;
        unmasked = true;
    }
    catch (e) {
        // silence
    }
    var result = lodash_merge_nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[lodash_merge_symToStringTag] = tag;
        }
        else {
            delete value[lodash_merge_symToStringTag];
        }
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function lodash_merge_objectToString(value) {
    return lodash_merge_nativeObjectToString.call(value);
}
//# sourceMappingURL=lodash.merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */

var merge_MAX_LEVEL = 20;
/**
 * Merges objects together
 * @param args - objects / values to be merged
 */
function merge_merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var result = args.shift();
    var objects = new WeakMap();
    while (args.length > 0) {
        result = merge_mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
}
function merge_takeValue(value) {
    if (merge_isArray(value)) {
        return value.slice();
    }
    return value;
}
/**
 * Merges two objects
 * @param one - first object
 * @param two - second object
 * @param level - current deep level
 * @param objects - objects holder that has been already referenced - to prevent
 * cyclic dependency
 */
function merge_mergeTwoObjects(one, two, level, objects) {
    if (level === void 0) { level = 0; }
    var result;
    if (level > merge_MAX_LEVEL) {
        return undefined;
    }
    level++;
    if (merge_isPrimitive(one) || merge_isPrimitive(two) || merge_isFunction(two)) {
        result = merge_takeValue(two);
    }
    else if (merge_isArray(one)) {
        result = one.slice();
        if (merge_isArray(two)) {
            for (var i = 0, j = two.length; i < j; i++) {
                result.push(merge_takeValue(two[i]));
            }
        }
        else if (merge_isObject(two)) {
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                result[key] = merge_takeValue(two[key]);
            }
        }
    }
    else if (merge_isObject(one)) {
        if (merge_isObject(two)) {
            if (!merge_shouldMerge(one, two)) {
                return two;
            }
            result = Object.assign({}, one);
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                var twoValue = two[key];
                if (merge_isPrimitive(twoValue)) {
                    if (typeof twoValue === 'undefined') {
                        delete result[key];
                    }
                    else {
                        // result[key] = takeValue(twoValue);
                        result[key] = twoValue;
                    }
                }
                else {
                    var obj1 = result[key];
                    var obj2 = twoValue;
                    if (merge_wasObjectReferenced(one, key, objects) ||
                        merge_wasObjectReferenced(two, key, objects)) {
                        delete result[key];
                    }
                    else {
                        if (merge_isObject(obj1) && merge_isObject(obj2)) {
                            var arr1 = objects.get(obj1) || [];
                            var arr2 = objects.get(obj2) || [];
                            arr1.push({ obj: one, key: key });
                            arr2.push({ obj: two, key: key });
                            objects.set(obj1, arr1);
                            objects.set(obj2, arr2);
                        }
                        result[key] = merge_mergeTwoObjects(result[key], twoValue, level, objects);
                    }
                }
            }
        }
        else {
            result = two;
        }
    }
    return result;
}
/**
 * Function to check if object has been already reference
 * @param obj
 * @param key
 * @param objects
 */
function merge_wasObjectReferenced(obj, key, objects) {
    var arr = objects.get(obj[key]) || [];
    for (var i = 0, j = arr.length; i < j; i++) {
        var info = arr[i];
        if (info.key === key && info.obj === obj) {
            return true;
        }
    }
    return false;
}
function merge_isArray(value) {
    return Array.isArray(value);
}
function merge_isFunction(value) {
    return typeof value === 'function';
}
function merge_isObject(value) {
    return !merge_isPrimitive(value) && !merge_isArray(value) && !merge_isFunction(value) && typeof value === 'object';
}
function merge_isPrimitive(value) {
    return typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean' ||
        typeof value === 'undefined' ||
        value instanceof Date ||
        value instanceof RegExp ||
        value === null;
}
function merge_shouldMerge(one, two) {
    if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
    }
    return true;
}
//# sourceMappingURL=merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/url.js
var url_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === 'string') {
        return url === urlToMatch;
    }
    else {
        return !!url.match(urlToMatch);
    }
}
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */
function isUrlIgnored(url, ignoredUrls) {
    var e_1, _a;
    if (!ignoredUrls) {
        return false;
    }
    try {
        for (var ignoredUrls_1 = url_values(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
            var ignoreUrl = ignoredUrls_1_1.value;
            if (urlMatches(url, ignoreUrl)) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return)) _a.call(ignoredUrls_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}
//# sourceMappingURL=url.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/promise.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var utils_promise_Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function (val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function (err) {
        this._reject(err);
    };
    return Deferred;
}());

//# sourceMappingURL=promise.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/utils/callback.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var utils_callback_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var utils_callback_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */
var callback_BindOnceFuture = /** @class */ (function () {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new utils_promise_Deferred();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function () {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function () {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, utils_callback_spreadArray([this._that], utils_callback_read(args), false)))
                    .then(function (val) { return _this._deferred.resolve(val); }, function (err) { return _this._deferred.reject(err); });
            }
            catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}());

//# sourceMappingURL=callback.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/node_modules/@opentelemetry/core/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





























//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var trace_suppress_tracing_SUPPRESS_TRACING_KEY = createContextKey('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function trace_suppress_tracing_suppressTracing(context) {
    return context.setValue(trace_suppress_tracing_SUPPRESS_TRACING_KEY, true);
}
function trace_suppress_tracing_unsuppressTracing(context) {
    return context.deleteValue(trace_suppress_tracing_SUPPRESS_TRACING_KEY);
}
function trace_suppress_tracing_isTracingSuppressed(context) {
    return context.getValue(trace_suppress_tracing_SUPPRESS_TRACING_KEY) === true;
}
//# sourceMappingURL=suppress-tracing.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/baggage/constants.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var baggage_constants_BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR = ';';
var esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR = ',';
// Name of the http header used to propagate the baggage
var baggage_constants_BAGGAGE_HEADER = 'baggage';
// Maximum number of name-value pairs allowed by w3c spec
var baggage_constants_BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
// Maximum number of bytes per a single name-value pair allowed by w3c spec
var baggage_constants_BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
// Maximum total length of all name-value pairs allowed by w3c spec
var baggage_constants_BAGGAGE_MAX_TOTAL_LENGTH = 8192;
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/baggage/utils.js
var esm_baggage_utils_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function baggage_utils_serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function (hValue, current) {
        var value = "" + hValue + (hValue !== '' ? esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR : '') + current;
        return value.length > baggage_constants_BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, '');
}
function baggage_utils_getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function (_a) {
        var _b = esm_baggage_utils_read(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) {
            entry += baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
    });
}
function baggage_utils_parsePairKeyValue(entry) {
    var valueProps = entry.split(baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
        return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart)
        return;
    var keyPair = keyPairPart.split(baggage_constants_BAGGAGE_KEY_PAIR_SEPARATOR);
    if (keyPair.length !== 2)
        return;
    var key = decodeURIComponent(keyPair[0].trim());
    var value = decodeURIComponent(keyPair[1].trim());
    var metadata;
    if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key: key, value: value, metadata: metadata };
}
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */
function baggage_utils_parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0)
        return {};
    return value
        .split(esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR)
        .map(function (entry) {
        return baggage_utils_parsePairKeyValue(entry);
    })
        .filter(function (keyPair) { return keyPair !== undefined && keyPair.value.length > 0; })
        .reduce(function (headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Propagates {@link Baggage} through Context format propagation.
 *
 * Based on the Baggage specification:
 * https://w3c.github.io/baggage/
 */
var propagation_W3CBaggagePropagator_W3CBaggagePropagator = /** @class */ (function () {
    function W3CBaggagePropagator() {
    }
    W3CBaggagePropagator.prototype.inject = function (context, carrier, setter) {
        var baggage = propagation.getBaggage(context);
        if (!baggage || trace_suppress_tracing_isTracingSuppressed(context))
            return;
        var keyPairs = baggage_utils_getKeyPairs(baggage)
            .filter(function (pair) {
            return pair.length <= baggage_constants_BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        })
            .slice(0, baggage_constants_BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = baggage_utils_serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
            setter.set(carrier, baggage_constants_BAGGAGE_HEADER, headerValue);
        }
    };
    W3CBaggagePropagator.prototype.extract = function (context, carrier, getter) {
        var headerValue = getter.get(carrier, baggage_constants_BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
            return context;
        var baggage = {};
        if (baggageString.length === 0) {
            return context;
        }
        var pairs = baggageString.split(esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function (entry) {
            var keyPair = baggage_utils_parsePairKeyValue(entry);
            if (keyPair) {
                var baggageEntry = { value: keyPair.value };
                if (keyPair.metadata) {
                    baggageEntry.metadata = keyPair.metadata;
                }
                baggage[keyPair.key] = baggageEntry;
            }
        });
        if (Object.entries(baggage).length === 0) {
            return context;
        }
        return propagation.setBaggage(context, propagation.createBaggage(baggage));
    };
    W3CBaggagePropagator.prototype.fields = function () {
        return [baggage_constants_BAGGAGE_HEADER];
    };
    return W3CBaggagePropagator;
}());

//# sourceMappingURL=W3CBaggagePropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/common/anchored-clock.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A utility for returning wall times anchored to a given point in time. Wall time measurements will
 * not be taken from the system, but instead are computed by adding a monotonic clock time
 * to the anchor point.
 *
 * This is needed because the system time can change and result in unexpected situations like
 * spans ending before they are started. Creating an anchored clock for each local root span
 * ensures that span timings and durations are accurate while preventing span times from drifting
 * too far from the system clock.
 *
 * Only creating an anchored clock once per local trace ensures span times are correct relative
 * to each other. For example, a child span will never have a start time before its parent even
 * if the system clock is corrected during the local trace.
 *
 * Heavily inspired by the OTel Java anchored clock
 * https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk/trace/src/main/java/io/opentelemetry/sdk/trace/AnchoredClock.java
 */
var anchored_clock_AnchoredClock = /** @class */ (function () {
    /**
     * Create a new AnchoredClock anchored to the current time returned by systemClock.
     *
     * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
     * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
     */
    function AnchoredClock(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
    }
    /**
     * Returns the current time by adding the number of milliseconds since the
     * AnchoredClock was created to the creation epoch time
     */
    AnchoredClock.prototype.now = function () {
        var delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
    };
    return AnchoredClock;
}());

//# sourceMappingURL=anchored-clock.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/common/attributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_common_attributes_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var esm_common_attributes_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

function common_attributes_sanitizeAttributes(attributes) {
    var e_1, _a;
    var out = {};
    if (typeof attributes !== 'object' || attributes == null) {
        return out;
    }
    try {
        for (var _b = esm_common_attributes_values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = esm_common_attributes_read(_c.value, 2), key = _d[0], val = _d[1];
            if (!common_attributes_isAttributeKey(key)) {
                diag.warn("Invalid attribute key: " + key);
                continue;
            }
            if (!common_attributes_isAttributeValue(val)) {
                diag.warn("Invalid attribute value set for key: " + key);
                continue;
            }
            if (Array.isArray(val)) {
                out[key] = val.slice();
            }
            else {
                out[key] = val;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return out;
}
function common_attributes_isAttributeKey(key) {
    return typeof key === 'string' && key.length > 0;
}
function common_attributes_isAttributeValue(val) {
    if (val == null) {
        return true;
    }
    if (Array.isArray(val)) {
        return common_attributes_isHomogeneousAttributeValueArray(val);
    }
    return common_attributes_isValidPrimitiveAttributeValue(val);
}
function common_attributes_isHomogeneousAttributeValueArray(arr) {
    var e_2, _a;
    var type;
    try {
        for (var arr_1 = esm_common_attributes_values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var element = arr_1_1.value;
            // null/undefined elements are allowed
            if (element == null)
                continue;
            if (!type) {
                if (common_attributes_isValidPrimitiveAttributeValue(element)) {
                    type = typeof element;
                    continue;
                }
                // encountered an invalid primitive
                return false;
            }
            if (typeof element === type) {
                continue;
            }
            return false;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return true;
}
function common_attributes_isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
        case 'number':
        case 'boolean':
        case 'string':
            return true;
    }
    return false;
}
//# sourceMappingURL=attributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */
function common_logging_error_handler_loggingErrorHandler() {
    return function (ex) {
        esm_diag.error(common_logging_error_handler_stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */
function common_logging_error_handler_stringifyException(ex) {
    if (typeof ex === 'string') {
        return ex;
    }
    else {
        return JSON.stringify(common_logging_error_handler_flattenException(ex));
    }
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */
function common_logging_error_handler_flattenException(ex) {
    var result = {};
    var current = ex;
    while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function (propertyName) {
            if (result[propertyName])
                return;
            var value = current[propertyName];
            if (value) {
                result[propertyName] = String(value);
            }
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}
//# sourceMappingURL=logging-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** The global error handler delegate */
var common_global_error_handler_delegateHandler = common_logging_error_handler_loggingErrorHandler();
/**
 * Set the global error handler
 * @param {ErrorHandler} handler
 */
function common_global_error_handler_setGlobalErrorHandler(handler) {
    common_global_error_handler_delegateHandler = handler;
}
/**
 * Return the global error handler
 * @param {Exception} ex
 */
function common_global_error_handler_globalErrorHandler(ex) {
    try {
        common_global_error_handler_delegateHandler(ex);
    }
    catch (_a) { } // eslint-disable-line no-empty
}
//# sourceMappingURL=global-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/sampling.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var utils_sampling_TracesSamplerValues;
(function (TracesSamplerValues) {
    TracesSamplerValues["AlwaysOff"] = "always_off";
    TracesSamplerValues["AlwaysOn"] = "always_on";
    TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues["TraceIdRatio"] = "traceidratio";
})(utils_sampling_TracesSamplerValues || (utils_sampling_TracesSamplerValues = {}));
//# sourceMappingURL=sampling.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/platform/browser/globalThis.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/api-metrics too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var esm_platform_browser_globalThis_globalThis = typeof globalThis === 'object' ? globalThis :
    typeof self === 'object' ? self :
        typeof window === 'object' ? window :
            typeof __webpack_require__.g === 'object' ? __webpack_require__.g :
                {};
//# sourceMappingURL=globalThis.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var utils_environment_DEFAULT_LIST_SEPARATOR = ',';
/**
 * Environment interface to define all names
 */
var utils_environment_ENVIRONMENT_NUMBERS_KEYS = [
    'OTEL_BSP_EXPORT_TIMEOUT',
    'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BSP_MAX_QUEUE_SIZE',
    'OTEL_BSP_SCHEDULE_DELAY',
    'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_LINK_COUNT_LIMIT',
    'OTEL_EXPORTER_OTLP_TIMEOUT',
    'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
    'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
    'OTEL_EXPORTER_JAEGER_AGENT_PORT',
];
function utils_environment_isEnvVarANumber(key) {
    return (utils_environment_ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1);
}
var utils_environment_ENVIRONMENT_LISTS_KEYS = [
    'OTEL_NO_PATCH_MODULES',
    'OTEL_PROPAGATORS',
];
function utils_environment_isEnvVarAList(key) {
    return utils_environment_ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var utils_environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var utils_environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
/**
 * Default environment variables
 */
var esm_utils_environment_DEFAULT_ENVIRONMENT = {
    CONTAINER_NAME: '',
    ECS_CONTAINER_METADATA_URI_V4: '',
    ECS_CONTAINER_METADATA_URI: '',
    HOSTNAME: '',
    KUBERNETES_SERVICE_HOST: '',
    NAMESPACE: '',
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: '',
    OTEL_EXPORTER_JAEGER_PASSWORD: '',
    OTEL_EXPORTER_JAEGER_USER: '',
    OTEL_EXPORTER_OTLP_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_HEADERS: '',
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
    OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
    OTEL_LOG_LEVEL: DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
    OTEL_RESOURCE_ATTRIBUTES: '',
    OTEL_SERVICE_NAME: '',
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: utils_environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: utils_environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: utils_environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: utils_environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_TRACES_EXPORTER: 'none',
    OTEL_TRACES_SAMPLER: utils_sampling_TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: '',
    OTEL_EXPORTER_OTLP_INSECURE: '',
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
    OTEL_EXPORTER_OTLP_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: ''
};
/**
 * Parses a variable as number with number validation
 * @param name
 * @param environment
 * @param values
 * @param min
 * @param max
 */
function utils_environment_parseNumber(name, environment, values, min, max) {
    if (min === void 0) { min = -Infinity; }
    if (max === void 0) { max = Infinity; }
    if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
            if (value < min) {
                environment[name] = min;
            }
            else if (value > max) {
                environment[name] = max;
            }
            else {
                environment[name] = value;
            }
        }
    }
}
/**
 * Parses list-like strings from input into output.
 * @param name
 * @param environment
 * @param values
 * @param separator
 */
function utils_environment_parseStringList(name, output, input, separator) {
    if (separator === void 0) { separator = utils_environment_DEFAULT_LIST_SEPARATOR; }
    var givenValue = input[name];
    if (typeof givenValue === 'string') {
        output[name] = givenValue.split(separator).map(function (v) { return v.trim(); });
    }
}
// The support string -> DiagLogLevel mappings
var utils_environment_logLevelMap = {
    ALL: DiagLogLevel.ALL,
    VERBOSE: DiagLogLevel.VERBOSE,
    DEBUG: DiagLogLevel.DEBUG,
    INFO: DiagLogLevel.INFO,
    WARN: DiagLogLevel.WARN,
    ERROR: DiagLogLevel.ERROR,
    NONE: DiagLogLevel.NONE,
};
/**
 * Environmentally sets log level if valid log level string is provided
 * @param key
 * @param environment
 * @param values
 */
function utils_environment_setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if (typeof value === 'string') {
        var theLevel = utils_environment_logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
            environment[key] = theLevel;
        }
    }
}
/**
 * Parses environment values
 * @param values
 */
function esm_utils_environment_parseEnvironment(values) {
    var environment = {};
    for (var env in esm_utils_environment_DEFAULT_ENVIRONMENT) {
        var key = env;
        switch (key) {
            case 'OTEL_LOG_LEVEL':
                utils_environment_setLogLevelFromEnv(key, environment, values);
                break;
            default:
                if (utils_environment_isEnvVarANumber(key)) {
                    utils_environment_parseNumber(key, environment, values);
                }
                else if (utils_environment_isEnvVarAList(key)) {
                    utils_environment_parseStringList(key, environment, values);
                }
                else {
                    var value = values[key];
                    if (typeof value !== 'undefined' && value !== null) {
                        environment[key] = String(value);
                    }
                }
        }
    }
    return environment;
}
/**
 * Get environment in node or browser without
 * populating default values.
 */
function utils_environment_getEnvWithoutDefaults() {
    return typeof process !== 'undefined' ?
        esm_utils_environment_parseEnvironment("MISSING_ENV_VAR") :
        esm_utils_environment_parseEnvironment(_globalThis);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/platform/browser/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Gets the environment variables
 */
function browser_environment_getEnv() {
    var globalEnv = esm_utils_environment_parseEnvironment(esm_platform_browser_globalThis_globalThis);
    return Object.assign({}, esm_utils_environment_DEFAULT_ENVIRONMENT, globalEnv);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/platform/browser/RandomIdGenerator.js
var browser_RandomIdGenerator_SPAN_ID_BYTES = 8;
var browser_RandomIdGenerator_TRACE_ID_BYTES = 16;
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 */
var browser_RandomIdGenerator_RandomIdGenerator = /** @class */ (function () {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */
        this.generateTraceId = browser_RandomIdGenerator_getIdGenerator(browser_RandomIdGenerator_TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */
        this.generateSpanId = browser_RandomIdGenerator_getIdGenerator(browser_RandomIdGenerator_SPAN_ID_BYTES);
    }
    return RandomIdGenerator;
}());

var browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY = Array(32);
function browser_RandomIdGenerator_getIdGenerator(bytes) {
    return function generateId() {
        for (var i = 0; i < bytes * 2; i++) {
            browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
            // valid hex characters in the range 48-57 and 97-102
            if (browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] >= 58) {
                browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] += 39;
            }
        }
        return String.fromCharCode.apply(null, browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
    };
}
//# sourceMappingURL=RandomIdGenerator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/platform/browser/performance.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var browser_performance_otperformance = performance;
//# sourceMappingURL=performance.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/version.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var build_esm_version_VERSION = '1.7.0';
//# sourceMappingURL=version.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var trace_SemanticAttributes_SemanticAttributes = {
    /**
    * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
    *
    * Note: This may be different from `faas.id` if an alias is involved.
    */
    AWS_LAMBDA_INVOKED_ARN: 'aws.lambda.invoked_arn',
    /**
    * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
    */
    DB_SYSTEM: 'db.system',
    /**
    * The connection string used to connect to the database. It is recommended to remove embedded credentials.
    */
    DB_CONNECTION_STRING: 'db.connection_string',
    /**
    * Username for accessing the database.
    */
    DB_USER: 'db.user',
    /**
    * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
    */
    DB_JDBC_DRIVER_CLASSNAME: 'db.jdbc.driver_classname',
    /**
    * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
    *
    * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
    */
    DB_NAME: 'db.name',
    /**
    * The database statement being executed.
    *
    * Note: The value may be sanitized to exclude sensitive information.
    */
    DB_STATEMENT: 'db.statement',
    /**
    * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
    *
    * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
    */
    DB_OPERATION: 'db.operation',
    /**
    * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
    *
    * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
    */
    DB_MSSQL_INSTANCE_NAME: 'db.mssql.instance_name',
    /**
    * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_CASSANDRA_KEYSPACE: 'db.cassandra.keyspace',
    /**
    * The fetch size used for paging, i.e. how many rows will be returned at once.
    */
    DB_CASSANDRA_PAGE_SIZE: 'db.cassandra.page_size',
    /**
    * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
    */
    DB_CASSANDRA_CONSISTENCY_LEVEL: 'db.cassandra.consistency_level',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_CASSANDRA_TABLE: 'db.cassandra.table',
    /**
    * Whether or not the query is idempotent.
    */
    DB_CASSANDRA_IDEMPOTENCE: 'db.cassandra.idempotence',
    /**
    * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
    */
    DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: 'db.cassandra.speculative_execution_count',
    /**
    * The ID of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_ID: 'db.cassandra.coordinator.id',
    /**
    * The data center of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_DC: 'db.cassandra.coordinator.dc',
    /**
    * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_HBASE_NAMESPACE: 'db.hbase.namespace',
    /**
    * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
    */
    DB_REDIS_DATABASE_INDEX: 'db.redis.database_index',
    /**
    * The collection being accessed within the database stated in `db.name`.
    */
    DB_MONGODB_COLLECTION: 'db.mongodb.collection',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_SQL_TABLE: 'db.sql.table',
    /**
    * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
    */
    EXCEPTION_TYPE: 'exception.type',
    /**
    * The exception message.
    */
    EXCEPTION_MESSAGE: 'exception.message',
    /**
    * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
    */
    EXCEPTION_STACKTRACE: 'exception.stacktrace',
    /**
    * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
    *
    * Note: An exception is considered to have escaped (or left) the scope of a span,
  if that span is ended while the exception is still logically &#34;in flight&#34;.
  This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
  is passed to a Context manager&#39;s `__exit__` method in Python) but will
  usually be caught at the point of recording the exception in most languages.
  
  It is usually not possible to determine at the point where an exception is thrown
  whether it will escape the scope of a span.
  However, it is trivial to know that an exception
  will escape, if one checks for an active exception just before ending the span,
  as done in the [example above](#exception-end-example).
  
  It follows that an exception may still escape the scope of the span
  even if the `exception.escaped` attribute was not set or set to false,
  since the event might have been recorded at a time where it was not
  clear whether the exception will escape.
    */
    EXCEPTION_ESCAPED: 'exception.escaped',
    /**
    * Type of the trigger on which the function is executed.
    */
    FAAS_TRIGGER: 'faas.trigger',
    /**
    * The execution ID of the current function execution.
    */
    FAAS_EXECUTION: 'faas.execution',
    /**
    * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
    */
    FAAS_DOCUMENT_COLLECTION: 'faas.document.collection',
    /**
    * Describes the type of the operation that was performed on the data.
    */
    FAAS_DOCUMENT_OPERATION: 'faas.document.operation',
    /**
    * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_DOCUMENT_TIME: 'faas.document.time',
    /**
    * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
    */
    FAAS_DOCUMENT_NAME: 'faas.document.name',
    /**
    * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_TIME: 'faas.time',
    /**
    * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
    */
    FAAS_CRON: 'faas.cron',
    /**
    * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
    */
    FAAS_COLDSTART: 'faas.coldstart',
    /**
    * The name of the invoked function.
    *
    * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
    */
    FAAS_INVOKED_NAME: 'faas.invoked_name',
    /**
    * The cloud provider of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
    */
    FAAS_INVOKED_PROVIDER: 'faas.invoked_provider',
    /**
    * The cloud region of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
    */
    FAAS_INVOKED_REGION: 'faas.invoked_region',
    /**
    * Transport protocol used. See note below.
    */
    NET_TRANSPORT: 'net.transport',
    /**
    * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
    */
    NET_PEER_IP: 'net.peer.ip',
    /**
    * Remote port number.
    */
    NET_PEER_PORT: 'net.peer.port',
    /**
    * Remote hostname or similar, see note below.
    */
    NET_PEER_NAME: 'net.peer.name',
    /**
    * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
    */
    NET_HOST_IP: 'net.host.ip',
    /**
    * Like `net.peer.port` but for the host port.
    */
    NET_HOST_PORT: 'net.host.port',
    /**
    * Local hostname or similar, see note below.
    */
    NET_HOST_NAME: 'net.host.name',
    /**
    * The internet connection type currently being used by the host.
    */
    NET_HOST_CONNECTION_TYPE: 'net.host.connection.type',
    /**
    * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
    */
    NET_HOST_CONNECTION_SUBTYPE: 'net.host.connection.subtype',
    /**
    * The name of the mobile carrier.
    */
    NET_HOST_CARRIER_NAME: 'net.host.carrier.name',
    /**
    * The mobile carrier country code.
    */
    NET_HOST_CARRIER_MCC: 'net.host.carrier.mcc',
    /**
    * The mobile carrier network code.
    */
    NET_HOST_CARRIER_MNC: 'net.host.carrier.mnc',
    /**
    * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
    */
    NET_HOST_CARRIER_ICC: 'net.host.carrier.icc',
    /**
    * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
    */
    PEER_SERVICE: 'peer.service',
    /**
    * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
    */
    ENDUSER_ID: 'enduser.id',
    /**
    * Actual/assumed role the client is making the request under extracted from token or application security context.
    */
    ENDUSER_ROLE: 'enduser.role',
    /**
    * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
    */
    ENDUSER_SCOPE: 'enduser.scope',
    /**
    * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
    */
    THREAD_ID: 'thread.id',
    /**
    * Current thread name.
    */
    THREAD_NAME: 'thread.name',
    /**
    * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
    */
    CODE_FUNCTION: 'code.function',
    /**
    * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
    */
    CODE_NAMESPACE: 'code.namespace',
    /**
    * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
    */
    CODE_FILEPATH: 'code.filepath',
    /**
    * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
    */
    CODE_LINENO: 'code.lineno',
    /**
    * HTTP request method.
    */
    HTTP_METHOD: 'http.method',
    /**
    * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
    *
    * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
    */
    HTTP_URL: 'http.url',
    /**
    * The full request target as passed in a HTTP request line or equivalent.
    */
    HTTP_TARGET: 'http.target',
    /**
    * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
    *
    * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
    */
    HTTP_HOST: 'http.host',
    /**
    * The URI scheme identifying the used protocol.
    */
    HTTP_SCHEME: 'http.scheme',
    /**
    * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
    */
    HTTP_STATUS_CODE: 'http.status_code',
    /**
    * Kind of HTTP protocol used.
    *
    * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
    */
    HTTP_FLAVOR: 'http.flavor',
    /**
    * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
    */
    HTTP_USER_AGENT: 'http.user_agent',
    /**
    * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_REQUEST_CONTENT_LENGTH: 'http.request_content_length',
    /**
    * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: 'http.request_content_length_uncompressed',
    /**
    * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_RESPONSE_CONTENT_LENGTH: 'http.response_content_length',
    /**
    * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: 'http.response_content_length_uncompressed',
    /**
    * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
    *
    * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
    */
    HTTP_SERVER_NAME: 'http.server_name',
    /**
    * The matched route (path template).
    */
    HTTP_ROUTE: 'http.route',
    /**
    * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
    *
    * Note: This is not necessarily the same as `net.peer.ip`, which would
  identify the network-level peer, which may be a proxy.
  
  This attribute should be set when a source of information different
  from the one used for `net.peer.ip`, is available even if that other
  source just confirms the same value as `net.peer.ip`.
  Rationale: For `net.peer.ip`, one typically does not know if it
  comes from a proxy, reverse proxy, or the actual client. Setting
  `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
  one is at least somewhat confident that the address is not that of
  the closest proxy.
    */
    HTTP_CLIENT_IP: 'http.client_ip',
    /**
    * The keys in the `RequestItems` object field.
    */
    AWS_DYNAMODB_TABLE_NAMES: 'aws.dynamodb.table_names',
    /**
    * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
    */
    AWS_DYNAMODB_CONSUMED_CAPACITY: 'aws.dynamodb.consumed_capacity',
    /**
    * The JSON-serialized value of the `ItemCollectionMetrics` response field.
    */
    AWS_DYNAMODB_ITEM_COLLECTION_METRICS: 'aws.dynamodb.item_collection_metrics',
    /**
    * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: 'aws.dynamodb.provisioned_read_capacity',
    /**
    * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: 'aws.dynamodb.provisioned_write_capacity',
    /**
    * The value of the `ConsistentRead` request parameter.
    */
    AWS_DYNAMODB_CONSISTENT_READ: 'aws.dynamodb.consistent_read',
    /**
    * The value of the `ProjectionExpression` request parameter.
    */
    AWS_DYNAMODB_PROJECTION: 'aws.dynamodb.projection',
    /**
    * The value of the `Limit` request parameter.
    */
    AWS_DYNAMODB_LIMIT: 'aws.dynamodb.limit',
    /**
    * The value of the `AttributesToGet` request parameter.
    */
    AWS_DYNAMODB_ATTRIBUTES_TO_GET: 'aws.dynamodb.attributes_to_get',
    /**
    * The value of the `IndexName` request parameter.
    */
    AWS_DYNAMODB_INDEX_NAME: 'aws.dynamodb.index_name',
    /**
    * The value of the `Select` request parameter.
    */
    AWS_DYNAMODB_SELECT: 'aws.dynamodb.select',
    /**
    * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: 'aws.dynamodb.global_secondary_indexes',
    /**
    * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: 'aws.dynamodb.local_secondary_indexes',
    /**
    * The value of the `ExclusiveStartTableName` request parameter.
    */
    AWS_DYNAMODB_EXCLUSIVE_START_TABLE: 'aws.dynamodb.exclusive_start_table',
    /**
    * The the number of items in the `TableNames` response parameter.
    */
    AWS_DYNAMODB_TABLE_COUNT: 'aws.dynamodb.table_count',
    /**
    * The value of the `ScanIndexForward` request parameter.
    */
    AWS_DYNAMODB_SCAN_FORWARD: 'aws.dynamodb.scan_forward',
    /**
    * The value of the `Segment` request parameter.
    */
    AWS_DYNAMODB_SEGMENT: 'aws.dynamodb.segment',
    /**
    * The value of the `TotalSegments` request parameter.
    */
    AWS_DYNAMODB_TOTAL_SEGMENTS: 'aws.dynamodb.total_segments',
    /**
    * The value of the `Count` response parameter.
    */
    AWS_DYNAMODB_COUNT: 'aws.dynamodb.count',
    /**
    * The value of the `ScannedCount` response parameter.
    */
    AWS_DYNAMODB_SCANNED_COUNT: 'aws.dynamodb.scanned_count',
    /**
    * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
    */
    AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: 'aws.dynamodb.attribute_definitions',
    /**
    * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: 'aws.dynamodb.global_secondary_index_updates',
    /**
    * A string identifying the messaging system.
    */
    MESSAGING_SYSTEM: 'messaging.system',
    /**
    * The message destination name. This might be equal to the span name but is required nevertheless.
    */
    MESSAGING_DESTINATION: 'messaging.destination',
    /**
    * The kind of message destination.
    */
    MESSAGING_DESTINATION_KIND: 'messaging.destination_kind',
    /**
    * A boolean that is true if the message destination is temporary.
    */
    MESSAGING_TEMP_DESTINATION: 'messaging.temp_destination',
    /**
    * The name of the transport protocol.
    */
    MESSAGING_PROTOCOL: 'messaging.protocol',
    /**
    * The version of the transport protocol.
    */
    MESSAGING_PROTOCOL_VERSION: 'messaging.protocol_version',
    /**
    * Connection string.
    */
    MESSAGING_URL: 'messaging.url',
    /**
    * A value used by the messaging system as an identifier for the message, represented as a string.
    */
    MESSAGING_MESSAGE_ID: 'messaging.message_id',
    /**
    * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
    */
    MESSAGING_CONVERSATION_ID: 'messaging.conversation_id',
    /**
    * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
    */
    MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: 'messaging.message_payload_size_bytes',
    /**
    * The compressed size of the message payload in bytes.
    */
    MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: 'messaging.message_payload_compressed_size_bytes',
    /**
    * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
    */
    MESSAGING_OPERATION: 'messaging.operation',
    /**
    * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
    */
    MESSAGING_CONSUMER_ID: 'messaging.consumer_id',
    /**
    * RabbitMQ message routing key.
    */
    MESSAGING_RABBITMQ_ROUTING_KEY: 'messaging.rabbitmq.routing_key',
    /**
    * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
    *
    * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
    */
    MESSAGING_KAFKA_MESSAGE_KEY: 'messaging.kafka.message_key',
    /**
    * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
    */
    MESSAGING_KAFKA_CONSUMER_GROUP: 'messaging.kafka.consumer_group',
    /**
    * Client Id for the Consumer or Producer that is handling the message.
    */
    MESSAGING_KAFKA_CLIENT_ID: 'messaging.kafka.client_id',
    /**
    * Partition the message is sent to.
    */
    MESSAGING_KAFKA_PARTITION: 'messaging.kafka.partition',
    /**
    * A boolean that is true if the message is a tombstone.
    */
    MESSAGING_KAFKA_TOMBSTONE: 'messaging.kafka.tombstone',
    /**
    * A string identifying the remoting system.
    */
    RPC_SYSTEM: 'rpc.system',
    /**
    * The full (logical) name of the service being called, including its package name, if applicable.
    *
    * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
    */
    RPC_SERVICE: 'rpc.service',
    /**
    * The name of the (logical) method being called, must be equal to the $method part in the span name.
    *
    * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
    */
    RPC_METHOD: 'rpc.method',
    /**
    * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
    */
    RPC_GRPC_STATUS_CODE: 'rpc.grpc.status_code',
    /**
    * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
    */
    RPC_JSONRPC_VERSION: 'rpc.jsonrpc.version',
    /**
    * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
    */
    RPC_JSONRPC_REQUEST_ID: 'rpc.jsonrpc.request_id',
    /**
    * `error.code` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_CODE: 'rpc.jsonrpc.error_code',
    /**
    * `error.message` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_MESSAGE: 'rpc.jsonrpc.error_message',
    /**
    * Whether this is a received or sent message.
    */
    MESSAGE_TYPE: 'message.type',
    /**
    * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
    *
    * Note: This way we guarantee that the values will be consistent between different implementations.
    */
    MESSAGE_ID: 'message.id',
    /**
    * Compressed size of the message in bytes.
    */
    MESSAGE_COMPRESSED_SIZE: 'message.compressed_size',
    /**
    * Uncompressed size of the message in bytes.
    */
    MESSAGE_UNCOMPRESSED_SIZE: 'message.uncompressed_size',
};
var trace_SemanticAttributes_DbSystemValues = {
    /** Some other SQL database. Fallback only. See notes. */
    OTHER_SQL: 'other_sql',
    /** Microsoft SQL Server. */
    MSSQL: 'mssql',
    /** MySQL. */
    MYSQL: 'mysql',
    /** Oracle Database. */
    ORACLE: 'oracle',
    /** IBM Db2. */
    DB2: 'db2',
    /** PostgreSQL. */
    POSTGRESQL: 'postgresql',
    /** Amazon Redshift. */
    REDSHIFT: 'redshift',
    /** Apache Hive. */
    HIVE: 'hive',
    /** Cloudscape. */
    CLOUDSCAPE: 'cloudscape',
    /** HyperSQL DataBase. */
    HSQLDB: 'hsqldb',
    /** Progress Database. */
    PROGRESS: 'progress',
    /** SAP MaxDB. */
    MAXDB: 'maxdb',
    /** SAP HANA. */
    HANADB: 'hanadb',
    /** Ingres. */
    INGRES: 'ingres',
    /** FirstSQL. */
    FIRSTSQL: 'firstsql',
    /** EnterpriseDB. */
    EDB: 'edb',
    /** InterSystems Caché. */
    CACHE: 'cache',
    /** Adabas (Adaptable Database System). */
    ADABAS: 'adabas',
    /** Firebird. */
    FIREBIRD: 'firebird',
    /** Apache Derby. */
    DERBY: 'derby',
    /** FileMaker. */
    FILEMAKER: 'filemaker',
    /** Informix. */
    INFORMIX: 'informix',
    /** InstantDB. */
    INSTANTDB: 'instantdb',
    /** InterBase. */
    INTERBASE: 'interbase',
    /** MariaDB. */
    MARIADB: 'mariadb',
    /** Netezza. */
    NETEZZA: 'netezza',
    /** Pervasive PSQL. */
    PERVASIVE: 'pervasive',
    /** PointBase. */
    POINTBASE: 'pointbase',
    /** SQLite. */
    SQLITE: 'sqlite',
    /** Sybase. */
    SYBASE: 'sybase',
    /** Teradata. */
    TERADATA: 'teradata',
    /** Vertica. */
    VERTICA: 'vertica',
    /** H2. */
    H2: 'h2',
    /** ColdFusion IMQ. */
    COLDFUSION: 'coldfusion',
    /** Apache Cassandra. */
    CASSANDRA: 'cassandra',
    /** Apache HBase. */
    HBASE: 'hbase',
    /** MongoDB. */
    MONGODB: 'mongodb',
    /** Redis. */
    REDIS: 'redis',
    /** Couchbase. */
    COUCHBASE: 'couchbase',
    /** CouchDB. */
    COUCHDB: 'couchdb',
    /** Microsoft Azure Cosmos DB. */
    COSMOSDB: 'cosmosdb',
    /** Amazon DynamoDB. */
    DYNAMODB: 'dynamodb',
    /** Neo4j. */
    NEO4J: 'neo4j',
    /** Apache Geode. */
    GEODE: 'geode',
    /** Elasticsearch. */
    ELASTICSEARCH: 'elasticsearch',
    /** Memcached. */
    MEMCACHED: 'memcached',
    /** CockroachDB. */
    COCKROACHDB: 'cockroachdb',
};
var trace_SemanticAttributes_DbCassandraConsistencyLevelValues = {
    /** all. */
    ALL: 'all',
    /** each_quorum. */
    EACH_QUORUM: 'each_quorum',
    /** quorum. */
    QUORUM: 'quorum',
    /** local_quorum. */
    LOCAL_QUORUM: 'local_quorum',
    /** one. */
    ONE: 'one',
    /** two. */
    TWO: 'two',
    /** three. */
    THREE: 'three',
    /** local_one. */
    LOCAL_ONE: 'local_one',
    /** any. */
    ANY: 'any',
    /** serial. */
    SERIAL: 'serial',
    /** local_serial. */
    LOCAL_SERIAL: 'local_serial',
};
var trace_SemanticAttributes_FaasTriggerValues = {
    /** A response to some data source operation such as a database or filesystem read/write. */
    DATASOURCE: 'datasource',
    /** To provide an answer to an inbound HTTP request. */
    HTTP: 'http',
    /** A function is set to be executed when messages are sent to a messaging system. */
    PUBSUB: 'pubsub',
    /** A function is scheduled to be executed regularly. */
    TIMER: 'timer',
    /** If none of the others apply. */
    OTHER: 'other',
};
var trace_SemanticAttributes_FaasDocumentOperationValues = {
    /** When a new object is created. */
    INSERT: 'insert',
    /** When an object is modified. */
    EDIT: 'edit',
    /** When an object is deleted. */
    DELETE: 'delete',
};
var trace_SemanticAttributes_FaasInvokedProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var trace_SemanticAttributes_NetTransportValues = {
    /** ip_tcp. */
    IP_TCP: 'ip_tcp',
    /** ip_udp. */
    IP_UDP: 'ip_udp',
    /** Another IP-based protocol. */
    IP: 'ip',
    /** Unix Domain socket. See below. */
    UNIX: 'unix',
    /** Named or anonymous pipe. See note below. */
    PIPE: 'pipe',
    /** In-process communication. */
    INPROC: 'inproc',
    /** Something else (non IP-based). */
    OTHER: 'other',
};
var trace_SemanticAttributes_NetHostConnectionTypeValues = {
    /** wifi. */
    WIFI: 'wifi',
    /** wired. */
    WIRED: 'wired',
    /** cell. */
    CELL: 'cell',
    /** unavailable. */
    UNAVAILABLE: 'unavailable',
    /** unknown. */
    UNKNOWN: 'unknown',
};
var trace_SemanticAttributes_NetHostConnectionSubtypeValues = {
    /** GPRS. */
    GPRS: 'gprs',
    /** EDGE. */
    EDGE: 'edge',
    /** UMTS. */
    UMTS: 'umts',
    /** CDMA. */
    CDMA: 'cdma',
    /** EVDO Rel. 0. */
    EVDO_0: 'evdo_0',
    /** EVDO Rev. A. */
    EVDO_A: 'evdo_a',
    /** CDMA2000 1XRTT. */
    CDMA2000_1XRTT: 'cdma2000_1xrtt',
    /** HSDPA. */
    HSDPA: 'hsdpa',
    /** HSUPA. */
    HSUPA: 'hsupa',
    /** HSPA. */
    HSPA: 'hspa',
    /** IDEN. */
    IDEN: 'iden',
    /** EVDO Rev. B. */
    EVDO_B: 'evdo_b',
    /** LTE. */
    LTE: 'lte',
    /** EHRPD. */
    EHRPD: 'ehrpd',
    /** HSPAP. */
    HSPAP: 'hspap',
    /** GSM. */
    GSM: 'gsm',
    /** TD-SCDMA. */
    TD_SCDMA: 'td_scdma',
    /** IWLAN. */
    IWLAN: 'iwlan',
    /** 5G NR (New Radio). */
    NR: 'nr',
    /** 5G NRNSA (New Radio Non-Standalone). */
    NRNSA: 'nrnsa',
    /** LTE CA. */
    LTE_CA: 'lte_ca',
};
var trace_SemanticAttributes_HttpFlavorValues = {
    /** HTTP 1.0. */
    HTTP_1_0: '1.0',
    /** HTTP 1.1. */
    HTTP_1_1: '1.1',
    /** HTTP 2. */
    HTTP_2_0: '2.0',
    /** SPDY protocol. */
    SPDY: 'SPDY',
    /** QUIC protocol. */
    QUIC: 'QUIC',
};
var trace_SemanticAttributes_MessagingDestinationKindValues = {
    /** A message sent to a queue. */
    QUEUE: 'queue',
    /** A message sent to a topic. */
    TOPIC: 'topic',
};
var trace_SemanticAttributes_MessagingOperationValues = {
    /** receive. */
    RECEIVE: 'receive',
    /** process. */
    PROCESS: 'process',
};
var trace_SemanticAttributes_RpcGrpcStatusCodeValues = {
    /** OK. */
    OK: 0,
    /** CANCELLED. */
    CANCELLED: 1,
    /** UNKNOWN. */
    UNKNOWN: 2,
    /** INVALID_ARGUMENT. */
    INVALID_ARGUMENT: 3,
    /** DEADLINE_EXCEEDED. */
    DEADLINE_EXCEEDED: 4,
    /** NOT_FOUND. */
    NOT_FOUND: 5,
    /** ALREADY_EXISTS. */
    ALREADY_EXISTS: 6,
    /** PERMISSION_DENIED. */
    PERMISSION_DENIED: 7,
    /** RESOURCE_EXHAUSTED. */
    RESOURCE_EXHAUSTED: 8,
    /** FAILED_PRECONDITION. */
    FAILED_PRECONDITION: 9,
    /** ABORTED. */
    ABORTED: 10,
    /** OUT_OF_RANGE. */
    OUT_OF_RANGE: 11,
    /** UNIMPLEMENTED. */
    UNIMPLEMENTED: 12,
    /** INTERNAL. */
    INTERNAL: 13,
    /** UNAVAILABLE. */
    UNAVAILABLE: 14,
    /** DATA_LOSS. */
    DATA_LOSS: 15,
    /** UNAUTHENTICATED. */
    UNAUTHENTICATED: 16,
};
var trace_SemanticAttributes_MessageTypeValues = {
    /** sent. */
    SENT: 'SENT',
    /** received. */
    RECEIVED: 'RECEIVED',
};
//# sourceMappingURL=SemanticAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var resource_SemanticResourceAttributes_SemanticResourceAttributes = {
    /**
    * Name of the cloud provider.
    */
    CLOUD_PROVIDER: 'cloud.provider',
    /**
    * The cloud account ID the resource is assigned to.
    */
    CLOUD_ACCOUNT_ID: 'cloud.account.id',
    /**
    * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
    */
    CLOUD_REGION: 'cloud.region',
    /**
    * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
    *
    * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
    */
    CLOUD_AVAILABILITY_ZONE: 'cloud.availability_zone',
    /**
    * The cloud platform in use.
    *
    * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
    */
    CLOUD_PLATFORM: 'cloud.platform',
    /**
    * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
    */
    AWS_ECS_CONTAINER_ARN: 'aws.ecs.container.arn',
    /**
    * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
    */
    AWS_ECS_CLUSTER_ARN: 'aws.ecs.cluster.arn',
    /**
    * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
    */
    AWS_ECS_LAUNCHTYPE: 'aws.ecs.launchtype',
    /**
    * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
    */
    AWS_ECS_TASK_ARN: 'aws.ecs.task.arn',
    /**
    * The task definition family this task definition is a member of.
    */
    AWS_ECS_TASK_FAMILY: 'aws.ecs.task.family',
    /**
    * The revision for this task definition.
    */
    AWS_ECS_TASK_REVISION: 'aws.ecs.task.revision',
    /**
    * The ARN of an EKS cluster.
    */
    AWS_EKS_CLUSTER_ARN: 'aws.eks.cluster.arn',
    /**
    * The name(s) of the AWS log group(s) an application is writing to.
    *
    * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
    */
    AWS_LOG_GROUP_NAMES: 'aws.log.group.names',
    /**
    * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
    *
    * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
    */
    AWS_LOG_GROUP_ARNS: 'aws.log.group.arns',
    /**
    * The name(s) of the AWS log stream(s) an application is writing to.
    */
    AWS_LOG_STREAM_NAMES: 'aws.log.stream.names',
    /**
    * The ARN(s) of the AWS log stream(s).
    *
    * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
    */
    AWS_LOG_STREAM_ARNS: 'aws.log.stream.arns',
    /**
    * Container name.
    */
    CONTAINER_NAME: 'container.name',
    /**
    * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
    */
    CONTAINER_ID: 'container.id',
    /**
    * The container runtime managing this container.
    */
    CONTAINER_RUNTIME: 'container.runtime',
    /**
    * Name of the image the container was built on.
    */
    CONTAINER_IMAGE_NAME: 'container.image.name',
    /**
    * Container image tag.
    */
    CONTAINER_IMAGE_TAG: 'container.image.tag',
    /**
    * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
    */
    DEPLOYMENT_ENVIRONMENT: 'deployment.environment',
    /**
    * A unique identifier representing the device.
    *
    * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
    */
    DEVICE_ID: 'device.id',
    /**
    * The model identifier for the device.
    *
    * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
    */
    DEVICE_MODEL_IDENTIFIER: 'device.model.identifier',
    /**
    * The marketing name for the device model.
    *
    * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
    */
    DEVICE_MODEL_NAME: 'device.model.name',
    /**
    * The name of the single function that this runtime instance executes.
    *
    * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
    */
    FAAS_NAME: 'faas.name',
    /**
    * The unique ID of the single function that this runtime instance executes.
    *
    * Note: Depending on the cloud provider, use:
  
  * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
  Take care not to use the &#34;invoked ARN&#34; directly but replace any
  [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
  different aliases.
  * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
  * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
  
  On some providers, it may not be possible to determine the full ID at startup,
  which is why this field cannot be made required. For example, on AWS the account ID
  part of the ARN is not available without calling another AWS API
  which may be deemed too slow for a short-running lambda function.
  As an alternative, consider setting `faas.id` as a span attribute instead.
    */
    FAAS_ID: 'faas.id',
    /**
    * The immutable version of the function being executed.
    *
    * Note: Depending on the cloud provider and platform, use:
  
  * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
    (an integer represented as a decimal string).
  * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
    (i.e., the function name plus the revision suffix).
  * **Google Cloud Functions:** The value of the
    [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
  * **Azure Functions:** Not applicable. Do not set this attribute.
    */
    FAAS_VERSION: 'faas.version',
    /**
    * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
    *
    * Note: * **AWS Lambda:** Use the (full) log stream name.
    */
    FAAS_INSTANCE: 'faas.instance',
    /**
    * The amount of memory available to the serverless function in MiB.
    *
    * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
    */
    FAAS_MAX_MEMORY: 'faas.max_memory',
    /**
    * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
    */
    HOST_ID: 'host.id',
    /**
    * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
    */
    HOST_NAME: 'host.name',
    /**
    * Type of host. For Cloud, this must be the machine type.
    */
    HOST_TYPE: 'host.type',
    /**
    * The CPU architecture the host system is running on.
    */
    HOST_ARCH: 'host.arch',
    /**
    * Name of the VM image or OS install the host was instantiated from.
    */
    HOST_IMAGE_NAME: 'host.image.name',
    /**
    * VM image ID. For Cloud, this value is from the provider.
    */
    HOST_IMAGE_ID: 'host.image.id',
    /**
    * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
    */
    HOST_IMAGE_VERSION: 'host.image.version',
    /**
    * The name of the cluster.
    */
    K8S_CLUSTER_NAME: 'k8s.cluster.name',
    /**
    * The name of the Node.
    */
    K8S_NODE_NAME: 'k8s.node.name',
    /**
    * The UID of the Node.
    */
    K8S_NODE_UID: 'k8s.node.uid',
    /**
    * The name of the namespace that the pod is running in.
    */
    K8S_NAMESPACE_NAME: 'k8s.namespace.name',
    /**
    * The UID of the Pod.
    */
    K8S_POD_UID: 'k8s.pod.uid',
    /**
    * The name of the Pod.
    */
    K8S_POD_NAME: 'k8s.pod.name',
    /**
    * The name of the Container in a Pod template.
    */
    K8S_CONTAINER_NAME: 'k8s.container.name',
    /**
    * The UID of the ReplicaSet.
    */
    K8S_REPLICASET_UID: 'k8s.replicaset.uid',
    /**
    * The name of the ReplicaSet.
    */
    K8S_REPLICASET_NAME: 'k8s.replicaset.name',
    /**
    * The UID of the Deployment.
    */
    K8S_DEPLOYMENT_UID: 'k8s.deployment.uid',
    /**
    * The name of the Deployment.
    */
    K8S_DEPLOYMENT_NAME: 'k8s.deployment.name',
    /**
    * The UID of the StatefulSet.
    */
    K8S_STATEFULSET_UID: 'k8s.statefulset.uid',
    /**
    * The name of the StatefulSet.
    */
    K8S_STATEFULSET_NAME: 'k8s.statefulset.name',
    /**
    * The UID of the DaemonSet.
    */
    K8S_DAEMONSET_UID: 'k8s.daemonset.uid',
    /**
    * The name of the DaemonSet.
    */
    K8S_DAEMONSET_NAME: 'k8s.daemonset.name',
    /**
    * The UID of the Job.
    */
    K8S_JOB_UID: 'k8s.job.uid',
    /**
    * The name of the Job.
    */
    K8S_JOB_NAME: 'k8s.job.name',
    /**
    * The UID of the CronJob.
    */
    K8S_CRONJOB_UID: 'k8s.cronjob.uid',
    /**
    * The name of the CronJob.
    */
    K8S_CRONJOB_NAME: 'k8s.cronjob.name',
    /**
    * The operating system type.
    */
    OS_TYPE: 'os.type',
    /**
    * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
    */
    OS_DESCRIPTION: 'os.description',
    /**
    * Human readable operating system name.
    */
    OS_NAME: 'os.name',
    /**
    * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
    */
    OS_VERSION: 'os.version',
    /**
    * Process identifier (PID).
    */
    PROCESS_PID: 'process.pid',
    /**
    * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_NAME: 'process.executable.name',
    /**
    * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_PATH: 'process.executable.path',
    /**
    * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
    */
    PROCESS_COMMAND: 'process.command',
    /**
    * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
    */
    PROCESS_COMMAND_LINE: 'process.command_line',
    /**
    * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
    */
    PROCESS_COMMAND_ARGS: 'process.command_args',
    /**
    * The username of the user that owns the process.
    */
    PROCESS_OWNER: 'process.owner',
    /**
    * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
    */
    PROCESS_RUNTIME_NAME: 'process.runtime.name',
    /**
    * The version of the runtime of this process, as returned by the runtime without modification.
    */
    PROCESS_RUNTIME_VERSION: 'process.runtime.version',
    /**
    * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
    */
    PROCESS_RUNTIME_DESCRIPTION: 'process.runtime.description',
    /**
    * Logical name of the service.
    *
    * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
    */
    SERVICE_NAME: 'service.name',
    /**
    * A namespace for `service.name`.
    *
    * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
    */
    SERVICE_NAMESPACE: 'service.namespace',
    /**
    * The string ID of the service instance.
    *
    * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
    */
    SERVICE_INSTANCE_ID: 'service.instance.id',
    /**
    * The version string of the service API or implementation.
    */
    SERVICE_VERSION: 'service.version',
    /**
    * The name of the telemetry SDK as defined above.
    */
    TELEMETRY_SDK_NAME: 'telemetry.sdk.name',
    /**
    * The language of the telemetry SDK.
    */
    TELEMETRY_SDK_LANGUAGE: 'telemetry.sdk.language',
    /**
    * The version string of the telemetry SDK.
    */
    TELEMETRY_SDK_VERSION: 'telemetry.sdk.version',
    /**
    * The version string of the auto instrumentation agent, if used.
    */
    TELEMETRY_AUTO_VERSION: 'telemetry.auto.version',
    /**
    * The name of the web engine.
    */
    WEBENGINE_NAME: 'webengine.name',
    /**
    * The version of the web engine.
    */
    WEBENGINE_VERSION: 'webengine.version',
    /**
    * Additional description of the web engine (e.g. detailed version and edition information).
    */
    WEBENGINE_DESCRIPTION: 'webengine.description',
};
var resource_SemanticResourceAttributes_CloudProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var resource_SemanticResourceAttributes_CloudPlatformValues = {
    /** Alibaba Cloud Elastic Compute Service. */
    ALIBABA_CLOUD_ECS: 'alibaba_cloud_ecs',
    /** Alibaba Cloud Function Compute. */
    ALIBABA_CLOUD_FC: 'alibaba_cloud_fc',
    /** AWS Elastic Compute Cloud. */
    AWS_EC2: 'aws_ec2',
    /** AWS Elastic Container Service. */
    AWS_ECS: 'aws_ecs',
    /** AWS Elastic Kubernetes Service. */
    AWS_EKS: 'aws_eks',
    /** AWS Lambda. */
    AWS_LAMBDA: 'aws_lambda',
    /** AWS Elastic Beanstalk. */
    AWS_ELASTIC_BEANSTALK: 'aws_elastic_beanstalk',
    /** Azure Virtual Machines. */
    AZURE_VM: 'azure_vm',
    /** Azure Container Instances. */
    AZURE_CONTAINER_INSTANCES: 'azure_container_instances',
    /** Azure Kubernetes Service. */
    AZURE_AKS: 'azure_aks',
    /** Azure Functions. */
    AZURE_FUNCTIONS: 'azure_functions',
    /** Azure App Service. */
    AZURE_APP_SERVICE: 'azure_app_service',
    /** Google Cloud Compute Engine (GCE). */
    GCP_COMPUTE_ENGINE: 'gcp_compute_engine',
    /** Google Cloud Run. */
    GCP_CLOUD_RUN: 'gcp_cloud_run',
    /** Google Cloud Kubernetes Engine (GKE). */
    GCP_KUBERNETES_ENGINE: 'gcp_kubernetes_engine',
    /** Google Cloud Functions (GCF). */
    GCP_CLOUD_FUNCTIONS: 'gcp_cloud_functions',
    /** Google Cloud App Engine (GAE). */
    GCP_APP_ENGINE: 'gcp_app_engine',
};
var resource_SemanticResourceAttributes_AwsEcsLaunchtypeValues = {
    /** ec2. */
    EC2: 'ec2',
    /** fargate. */
    FARGATE: 'fargate',
};
var resource_SemanticResourceAttributes_HostArchValues = {
    /** AMD64. */
    AMD64: 'amd64',
    /** ARM32. */
    ARM32: 'arm32',
    /** ARM64. */
    ARM64: 'arm64',
    /** Itanium. */
    IA64: 'ia64',
    /** 32-bit PowerPC. */
    PPC32: 'ppc32',
    /** 64-bit PowerPC. */
    PPC64: 'ppc64',
    /** 32-bit x86. */
    X86: 'x86',
};
var resource_SemanticResourceAttributes_OsTypeValues = {
    /** Microsoft Windows. */
    WINDOWS: 'windows',
    /** Linux. */
    LINUX: 'linux',
    /** Apple Darwin. */
    DARWIN: 'darwin',
    /** FreeBSD. */
    FREEBSD: 'freebsd',
    /** NetBSD. */
    NETBSD: 'netbsd',
    /** OpenBSD. */
    OPENBSD: 'openbsd',
    /** DragonFly BSD. */
    DRAGONFLYBSD: 'dragonflybsd',
    /** HP-UX (Hewlett Packard Unix). */
    HPUX: 'hpux',
    /** AIX (Advanced Interactive eXecutive). */
    AIX: 'aix',
    /** Oracle Solaris. */
    SOLARIS: 'solaris',
    /** IBM z/OS. */
    Z_OS: 'z_os',
};
var resource_SemanticResourceAttributes_TelemetrySdkLanguageValues = {
    /** cpp. */
    CPP: 'cpp',
    /** dotnet. */
    DOTNET: 'dotnet',
    /** erlang. */
    ERLANG: 'erlang',
    /** go. */
    GO: 'go',
    /** java. */
    JAVA: 'java',
    /** nodejs. */
    NODEJS: 'nodejs',
    /** php. */
    PHP: 'php',
    /** python. */
    PYTHON: 'python',
    /** ruby. */
    RUBY: 'ruby',
    /** webjs. */
    WEBJS: 'webjs',
};
//# sourceMappingURL=SemanticResourceAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/platform/browser/sdk-info.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var browser_sdk_info_a;


/** Constants describing the SDK in use */
var browser_sdk_info_SDK_INFO = (browser_sdk_info_a = {},
    browser_sdk_info_a[resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_NAME] = 'opentelemetry',
    browser_sdk_info_a[resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = 'browser',
    browser_sdk_info_a[resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = resource_SemanticResourceAttributes_TelemetrySdkLanguageValues.WEBJS,
    browser_sdk_info_a[resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = build_esm_version_VERSION,
    browser_sdk_info_a);
//# sourceMappingURL=sdk-info.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/platform/browser/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/common/time.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var common_time_NANOSECOND_DIGITS = 9;
var common_time_SECOND_TO_NANOSECONDS = Math.pow(10, common_time_NANOSECOND_DIGITS);
/**
 * Converts a number to HrTime, HrTime = [number, number].
 * The first number is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * numberToHrtime calculates the first number by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * numberToHrtime calculates the second number by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * SECOND_TO_NANOSECONDS = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 * @param epochMillis
 */
function common_time_numberToHrtime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Number((epochSeconds - seconds).toFixed(common_time_NANOSECOND_DIGITS)) *
        common_time_SECOND_TO_NANOSECONDS;
    return [seconds, nanos];
}
function common_time_getTimeOrigin() {
    var timeOrigin = performance.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = performance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function common_time_hrTime(performanceNow) {
    var timeOrigin = common_time_numberToHrtime(common_time_getTimeOrigin());
    var now = common_time_numberToHrtime(typeof performanceNow === 'number' ? performanceNow : performance.now());
    var seconds = timeOrigin[0] + now[0];
    var nanos = timeOrigin[1] + now[1];
    // Nanoseconds
    if (nanos > common_time_SECOND_TO_NANOSECONDS) {
        nanos -= common_time_SECOND_TO_NANOSECONDS;
        seconds += 1;
    }
    return [seconds, nanos];
}
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */
function common_time_timeInputToHrTime(time) {
    // process.hrtime
    if (common_time_isTimeInputHrTime(time)) {
        return time;
    }
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < common_time_getTimeOrigin()) {
            return common_time_hrTime(time);
        }
        else {
            // epoch milliseconds or performance.timeOrigin
            return common_time_numberToHrtime(time);
        }
    }
    else if (time instanceof Date) {
        return common_time_numberToHrtime(time.getTime());
    }
    else {
        throw TypeError('Invalid input type');
    }
}
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */
function common_time_hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += common_time_SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
}
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */
function common_time_hrTimeToTimeStamp(time) {
    var precision = common_time_NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substr(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */
function esm_common_time_hrTimeToNanoseconds(time) {
    return time[0] * common_time_SECOND_TO_NANOSECONDS + time[1];
}
/**
 * Convert hrTime to milliseconds.
 * @param time
 */
function common_time_hrTimeToMilliseconds(time) {
    return Math.round(time[0] * 1e3 + time[1] / 1e6);
}
/**
 * Convert hrTime to microseconds.
 * @param time
 */
function common_time_hrTimeToMicroseconds(time) {
    return Math.round(time[0] * 1e6 + time[1] / 1e3);
}
/**
 * check if time is HrTime
 * @param value
 */
function common_time_isTimeInputHrTime(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        typeof value[0] === 'number' &&
        typeof value[1] === 'number');
}
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */
function common_time_isTimeInput(value) {
    return (common_time_isTimeInputHrTime(value) ||
        typeof value === 'number' ||
        value instanceof Date);
}
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/ExportResult.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_ExportResult_ExportResultCode;
(function (ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(esm_ExportResult_ExportResultCode || (esm_ExportResult_ExportResultCode = {}));
//# sourceMappingURL=ExportResult.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/propagation/composite.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_propagation_composite_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

/** Combines multiple propagators into a single propagator. */
var propagation_composite_CompositePropagator = /** @class */ (function () {
    /**
     * Construct a composite propagator from a list of propagators.
     *
     * @param [config] Configuration object for composite propagator
     */
    function CompositePropagator(config) {
        if (config === void 0) { config = {}; }
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators
            // older propagators may not have fields function, null check to be sure
            .map(function (p) { return (typeof p.fields === 'function' ? p.fields() : []); })
            .reduce(function (x, y) { return x.concat(y); }, [])));
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same carrier key, the propagator later in the list
     * will "win".
     *
     * @param context Context to inject
     * @param carrier Carrier into which context will be injected
     */
    CompositePropagator.prototype.inject = function (context, carrier, setter) {
        var e_1, _a;
        try {
            for (var _b = esm_propagation_composite_values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propagator = _c.value;
                try {
                    propagator.inject(context, carrier, setter);
                }
                catch (err) {
                    esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same context key, the propagator later in the list
     * will "win".
     *
     * @param context Context to add values to
     * @param carrier Carrier from which to extract context
     */
    CompositePropagator.prototype.extract = function (context, carrier, getter) {
        return this._propagators.reduce(function (ctx, propagator) {
            try {
                return propagator.extract(ctx, carrier, getter);
            }
            catch (err) {
                esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
            return ctx;
        }, context);
    };
    CompositePropagator.prototype.fields = function () {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
    };
    return CompositePropagator;
}());

//# sourceMappingURL=composite.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/internal/validators.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_internal_validators_VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var esm_internal_validators_VALID_KEY = "[a-z]" + esm_internal_validators_VALID_KEY_CHAR_RANGE + "{0,255}";
var esm_internal_validators_VALID_VENDOR_KEY = "[a-z0-9]" + esm_internal_validators_VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + esm_internal_validators_VALID_KEY_CHAR_RANGE + "{0,13}";
var esm_internal_validators_VALID_KEY_REGEX = new RegExp("^(?:" + esm_internal_validators_VALID_KEY + "|" + esm_internal_validators_VALID_VENDOR_KEY + ")$");
var esm_internal_validators_VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var esm_internal_validators_INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */
function esm_internal_validators_validateKey(key) {
    return esm_internal_validators_VALID_KEY_REGEX.test(key);
}
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */
function esm_internal_validators_validateValue(value) {
    return (esm_internal_validators_VALID_VALUE_BASE_REGEX.test(value) &&
        !esm_internal_validators_INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));
}
//# sourceMappingURL=validators.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/trace/TraceState.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var esm_trace_TraceState_MAX_TRACE_STATE_ITEMS = 32;
var esm_trace_TraceState_MAX_TRACE_STATE_LEN = 512;
var esm_trace_TraceState_LIST_MEMBERS_SEPARATOR = ',';
var esm_trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */
var trace_TraceState_TraceState = /** @class */ (function () {
    function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState)
            this._parse(rawTraceState);
    }
    TraceState.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
            traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceState.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceState.prototype.get = function (key) {
        return this._internalState.get(key);
    };
    TraceState.prototype.serialize = function () {
        var _this = this;
        return this._keys()
            .reduce(function (agg, key) {
            agg.push(key + esm_trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, [])
            .join(esm_trace_TraceState_LIST_MEMBERS_SEPARATOR);
    };
    TraceState.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > esm_trace_TraceState_MAX_TRACE_STATE_LEN)
            return;
        this._internalState = rawTraceState
            .split(esm_trace_TraceState_LIST_MEMBERS_SEPARATOR)
            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
            .reduce(function (agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(esm_trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if (esm_internal_validators_validateKey(key) && esm_internal_validators_validateValue(value)) {
                    agg.set(key, value);
                }
                else {
                    // TODO: Consider to add warning log
                }
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > esm_trace_TraceState_MAX_TRACE_STATE_ITEMS) {
            this._internalState = new Map(Array.from(this._internalState.entries())
                .reverse() // Use reverse same as original tracestate parse chain
                .slice(0, esm_trace_TraceState_MAX_TRACE_STATE_ITEMS));
        }
    };
    TraceState.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceState.prototype._clone = function () {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceState;
}());

//# sourceMappingURL=TraceState.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER = 'traceparent';
var trace_W3CTraceContextPropagator_TRACE_STATE_HEADER = 'tracestate';
var esm_trace_W3CTraceContextPropagator_VERSION = '00';
var trace_W3CTraceContextPropagator_VERSION_PART = '(?!ff)[\\da-f]{2}';
var trace_W3CTraceContextPropagator_TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
var trace_W3CTraceContextPropagator_PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
var trace_W3CTraceContextPropagator_FLAGS_PART = '[\\da-f]{2}';
var trace_W3CTraceContextPropagator_TRACE_PARENT_REGEX = new RegExp("^\\s?(" + trace_W3CTraceContextPropagator_VERSION_PART + ")-(" + trace_W3CTraceContextPropagator_TRACE_ID_PART + ")-(" + trace_W3CTraceContextPropagator_PARENT_ID_PART + ")-(" + trace_W3CTraceContextPropagator_FLAGS_PART + ")(-.*)?\\s?$");
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */
function trace_W3CTraceContextPropagator_parseTraceParent(traceParent) {
    var match = trace_W3CTraceContextPropagator_TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
        return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5])
        return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16),
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */
var trace_W3CTraceContextPropagator_W3CTraceContextPropagator = /** @class */ (function () {
    function W3CTraceContextPropagator() {
    }
    W3CTraceContextPropagator.prototype.inject = function (context, carrier, setter) {
        var spanContext = trace.getSpanContext(context);
        if (!spanContext ||
            trace_suppress_tracing_isTracingSuppressed(context) ||
            !isSpanContextValid(spanContext))
            return;
        var traceParent = esm_trace_W3CTraceContextPropagator_VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
            setter.set(carrier, trace_W3CTraceContextPropagator_TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
    };
    W3CTraceContextPropagator.prototype.extract = function (context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER);
        if (!traceParentHeader)
            return context;
        var traceParent = Array.isArray(traceParentHeader)
            ? traceParentHeader[0]
            : traceParentHeader;
        if (typeof traceParent !== 'string')
            return context;
        var spanContext = trace_W3CTraceContextPropagator_parseTraceParent(traceParent);
        if (!spanContext)
            return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, trace_W3CTraceContextPropagator_TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            var state = Array.isArray(traceStateHeader)
                ? traceStateHeader.join(',')
                : traceStateHeader;
            spanContext.traceState = new trace_TraceState_TraceState(typeof state === 'string' ? state : undefined);
        }
        return trace.setSpanContext(context, spanContext);
    };
    W3CTraceContextPropagator.prototype.fields = function () {
        return [trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER, trace_W3CTraceContextPropagator_TRACE_STATE_HEADER];
    };
    return W3CTraceContextPropagator;
}());

//# sourceMappingURL=W3CTraceContextPropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var rpc_metadata_RPC_METADATA_KEY = createContextKey('OpenTelemetry SDK Context Key RPC_METADATA');
var rpc_metadata_RPCType;
(function (RPCType) {
    RPCType["HTTP"] = "http";
})(rpc_metadata_RPCType || (rpc_metadata_RPCType = {}));
function rpc_metadata_setRPCMetadata(context, meta) {
    return context.setValue(rpc_metadata_RPC_METADATA_KEY, meta);
}
function rpc_metadata_deleteRPCMetadata(context) {
    return context.deleteValue(rpc_metadata_RPC_METADATA_KEY);
}
function rpc_metadata_getRPCMetadata(context) {
    return context.getValue(rpc_metadata_RPC_METADATA_KEY);
}
//# sourceMappingURL=rpc-metadata.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples no traces.
 */
var sampler_AlwaysOffSampler_AlwaysOffSampler = /** @class */ (function () {
    function AlwaysOffSampler() {
    }
    AlwaysOffSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.NOT_RECORD,
        };
    };
    AlwaysOffSampler.prototype.toString = function () {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}());

//# sourceMappingURL=AlwaysOffSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples all traces.
 */
var sampler_AlwaysOnSampler_AlwaysOnSampler = /** @class */ (function () {
    function AlwaysOnSampler() {
    }
    AlwaysOnSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.RECORD_AND_SAMPLED,
        };
    };
    AlwaysOnSampler.prototype.toString = function () {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}());

//# sourceMappingURL=AlwaysOnSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */
var sampler_ParentBasedSampler_ParentBasedSampler = /** @class */ (function () {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            common_global_error_handler_globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new sampler_AlwaysOnSampler_AlwaysOnSampler();
        }
        this._remoteParentSampled =
            (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new sampler_AlwaysOnSampler_AlwaysOnSampler();
        this._remoteParentNotSampled =
            (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new sampler_AlwaysOffSampler_AlwaysOffSampler();
        this._localParentSampled =
            (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new sampler_AlwaysOnSampler_AlwaysOnSampler();
        this._localParentNotSampled =
            (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new sampler_AlwaysOffSampler_AlwaysOffSampler();
    }
    ParentBasedSampler.prototype.shouldSample = function (context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
            return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & TraceFlags.SAMPLED) {
                return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            }
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function () {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}());

//# sourceMappingURL=ParentBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples a given fraction of traces based of trace id deterministically.
 */
var sampler_TraceIdRatioBasedSampler_TraceIdRatioBasedSampler = /** @class */ (function () {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) { _ratio = 0; }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function (context, traceId) {
        return {
            decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound
                ? SamplingDecision.RECORD_AND_SAMPLED
                : SamplingDecision.NOT_RECORD,
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function () {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function (ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio))
            return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function (traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}());

//# sourceMappingURL=TraceIdRatioBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * based on lodash in order to support esm builds without esModuleInterop.
 * lodash is using MIT License.
 **/
var utils_lodash_merge_objectTag = '[object Object]';
var utils_lodash_merge_nullTag = '[object Null]';
var utils_lodash_merge_undefinedTag = '[object Undefined]';
var utils_lodash_merge_funcProto = Function.prototype;
var utils_lodash_merge_funcToString = utils_lodash_merge_funcProto.toString;
var utils_lodash_merge_objectCtorString = utils_lodash_merge_funcToString.call(Object);
var utils_lodash_merge_getPrototype = utils_lodash_merge_overArg(Object.getPrototypeOf, Object);
var utils_lodash_merge_objectProto = Object.prototype;
var esm_utils_lodash_merge_hasOwnProperty = utils_lodash_merge_objectProto.hasOwnProperty;
var utils_lodash_merge_symToStringTag = Symbol ? Symbol.toStringTag : undefined;
var utils_lodash_merge_nativeObjectToString = utils_lodash_merge_objectProto.toString;
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function utils_lodash_merge_overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function esm_utils_lodash_merge_isPlainObject(value) {
    if (!utils_lodash_merge_isObjectLike(value) || utils_lodash_merge_baseGetTag(value) !== utils_lodash_merge_objectTag) {
        return false;
    }
    var proto = utils_lodash_merge_getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = esm_utils_lodash_merge_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        utils_lodash_merge_funcToString.call(Ctor) === utils_lodash_merge_objectCtorString;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function utils_lodash_merge_isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function utils_lodash_merge_baseGetTag(value) {
    if (value == null) {
        return value === undefined ? utils_lodash_merge_undefinedTag : utils_lodash_merge_nullTag;
    }
    return (utils_lodash_merge_symToStringTag && utils_lodash_merge_symToStringTag in Object(value))
        ? utils_lodash_merge_getRawTag(value)
        : utils_lodash_merge_objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function utils_lodash_merge_getRawTag(value) {
    var isOwn = esm_utils_lodash_merge_hasOwnProperty.call(value, utils_lodash_merge_symToStringTag), tag = value[utils_lodash_merge_symToStringTag];
    var unmasked = false;
    try {
        value[utils_lodash_merge_symToStringTag] = undefined;
        unmasked = true;
    }
    catch (e) {
        // silence
    }
    var result = utils_lodash_merge_nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[utils_lodash_merge_symToStringTag] = tag;
        }
        else {
            delete value[utils_lodash_merge_symToStringTag];
        }
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function utils_lodash_merge_objectToString(value) {
    return utils_lodash_merge_nativeObjectToString.call(value);
}
//# sourceMappingURL=lodash.merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */

var utils_merge_MAX_LEVEL = 20;
/**
 * Merges objects together
 * @param args - objects / values to be merged
 */
function utils_merge_merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var result = args.shift();
    var objects = new WeakMap();
    while (args.length > 0) {
        result = utils_merge_mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
}
function utils_merge_takeValue(value) {
    if (utils_merge_isArray(value)) {
        return value.slice();
    }
    return value;
}
/**
 * Merges two objects
 * @param one - first object
 * @param two - second object
 * @param level - current deep level
 * @param objects - objects holder that has been already referenced - to prevent
 * cyclic dependency
 */
function utils_merge_mergeTwoObjects(one, two, level, objects) {
    if (level === void 0) { level = 0; }
    var result;
    if (level > utils_merge_MAX_LEVEL) {
        return undefined;
    }
    level++;
    if (utils_merge_isPrimitive(one) || utils_merge_isPrimitive(two) || utils_merge_isFunction(two)) {
        result = utils_merge_takeValue(two);
    }
    else if (utils_merge_isArray(one)) {
        result = one.slice();
        if (utils_merge_isArray(two)) {
            for (var i = 0, j = two.length; i < j; i++) {
                result.push(utils_merge_takeValue(two[i]));
            }
        }
        else if (utils_merge_isObject(two)) {
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                result[key] = utils_merge_takeValue(two[key]);
            }
        }
    }
    else if (utils_merge_isObject(one)) {
        if (utils_merge_isObject(two)) {
            if (!utils_merge_shouldMerge(one, two)) {
                return two;
            }
            result = Object.assign({}, one);
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                var twoValue = two[key];
                if (utils_merge_isPrimitive(twoValue)) {
                    if (typeof twoValue === 'undefined') {
                        delete result[key];
                    }
                    else {
                        // result[key] = takeValue(twoValue);
                        result[key] = twoValue;
                    }
                }
                else {
                    var obj1 = result[key];
                    var obj2 = twoValue;
                    if (utils_merge_wasObjectReferenced(one, key, objects) ||
                        utils_merge_wasObjectReferenced(two, key, objects)) {
                        delete result[key];
                    }
                    else {
                        if (utils_merge_isObject(obj1) && utils_merge_isObject(obj2)) {
                            var arr1 = objects.get(obj1) || [];
                            var arr2 = objects.get(obj2) || [];
                            arr1.push({ obj: one, key: key });
                            arr2.push({ obj: two, key: key });
                            objects.set(obj1, arr1);
                            objects.set(obj2, arr2);
                        }
                        result[key] = utils_merge_mergeTwoObjects(result[key], twoValue, level, objects);
                    }
                }
            }
        }
        else {
            result = two;
        }
    }
    return result;
}
/**
 * Function to check if object has been already reference
 * @param obj
 * @param key
 * @param objects
 */
function utils_merge_wasObjectReferenced(obj, key, objects) {
    var arr = objects.get(obj[key]) || [];
    for (var i = 0, j = arr.length; i < j; i++) {
        var info = arr[i];
        if (info.key === key && info.obj === obj) {
            return true;
        }
    }
    return false;
}
function utils_merge_isArray(value) {
    return Array.isArray(value);
}
function utils_merge_isFunction(value) {
    return typeof value === 'function';
}
function utils_merge_isObject(value) {
    return !utils_merge_isPrimitive(value) && !utils_merge_isArray(value) && !utils_merge_isFunction(value) && typeof value === 'object';
}
function utils_merge_isPrimitive(value) {
    return typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean' ||
        typeof value === 'undefined' ||
        value instanceof Date ||
        value instanceof RegExp ||
        value === null;
}
function utils_merge_shouldMerge(one, two) {
    if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
    }
    return true;
}
//# sourceMappingURL=merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/url.js
var utils_url_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function url_urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === 'string') {
        return url === urlToMatch;
    }
    else {
        return !!url.match(urlToMatch);
    }
}
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */
function url_isUrlIgnored(url, ignoredUrls) {
    var e_1, _a;
    if (!ignoredUrls) {
        return false;
    }
    try {
        for (var ignoredUrls_1 = utils_url_values(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
            var ignoreUrl = ignoredUrls_1_1.value;
            if (url_urlMatches(url, ignoreUrl)) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return)) _a.call(ignoredUrls_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}
//# sourceMappingURL=url.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/promise.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_utils_promise_Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function (val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function (err) {
        this._reject(err);
    };
    return Deferred;
}());

//# sourceMappingURL=promise.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/utils/callback.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_utils_callback_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var esm_utils_callback_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */
var utils_callback_BindOnceFuture = /** @class */ (function () {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new esm_utils_promise_Deferred();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function () {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function () {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, esm_utils_callback_spreadArray([this._that], esm_utils_callback_read(args), false)))
                    .then(function (val) { return _this._deferred.resolve(val); }, function (err) { return _this._deferred.reject(err); });
            }
            catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}());

//# sourceMappingURL=callback.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





























//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/build/esm/util.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var util_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};


var DEFAULT_TRACE_TIMEOUT = 10000;
/**
 * Parses headers from config leaving only those that have defined values
 * @param partialHeaders
 */
function parseHeaders(partialHeaders) {
    if (partialHeaders === void 0) { partialHeaders = {}; }
    var headers = {};
    Object.entries(partialHeaders).forEach(function (_a) {
        var _b = util_read(_a, 2), key = _b[0], value = _b[1];
        if (typeof value !== 'undefined') {
            headers[key] = String(value);
        }
        else {
            esm_diag.warn("Header \"" + key + "\" has wrong value and will be ignored");
        }
    });
    return headers;
}
/**
 * Adds path (version + signal) to a no per-signal endpoint
 * @param url
 * @param path
 * @returns url + path
 */
function appendResourcePathToUrl(url, path) {
    if (!url.endsWith('/')) {
        url = url + '/';
    }
    return url + path;
}
/**
 * Adds root path to signal specific endpoint when endpoint contains no path part and no root path
 * @param url
 * @param path
 * @returns url
 */
function appendRootPathToUrlIfNeeded(url, path) {
    if (!url.includes(path) && !url.endsWith('/')) {
        url = url + '/';
    }
    return url;
}
/**
 * Configure exporter trace timeout value from passed in value or environment variables
 * @param timeoutMillis
 * @returns timeout value in milliseconds
 */
function configureExporterTimeout(timeoutMillis) {
    if (typeof timeoutMillis === 'number') {
        if (timeoutMillis <= 0) {
            // OTLP exporter configured timeout - using default value of 10000ms
            return invalidTimeout(timeoutMillis, DEFAULT_TRACE_TIMEOUT);
        }
        return timeoutMillis;
    }
    else {
        return getExporterTimeoutFromEnv();
    }
}
function getExporterTimeoutFromEnv() {
    var _a;
    var definedTimeout = Number((_a = browser_environment_getEnv().OTEL_EXPORTER_OTLP_TRACES_TIMEOUT) !== null && _a !== void 0 ? _a : browser_environment_getEnv().OTEL_EXPORTER_OTLP_TIMEOUT);
    if (definedTimeout <= 0) {
        // OTLP exporter configured timeout - using default value of 10000ms
        return invalidTimeout(definedTimeout, DEFAULT_TRACE_TIMEOUT);
    }
    else {
        return definedTimeout;
    }
}
// OTLP exporter configured timeout - using default value of 10000ms
function invalidTimeout(timeout, defaultTimeout) {
    esm_diag.warn('Timeout must be greater than 0', timeout);
    return defaultTimeout;
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/build/esm/OTLPExporterBase.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Collector Exporter abstract base class
 */
var OTLPExporterBase = /** @class */ (function () {
    /**
     * @param config
     */
    function OTLPExporterBase(config) {
        if (config === void 0) { config = {}; }
        this._sendingPromises = [];
        this.url = this.getDefaultUrl(config);
        if (typeof config.hostname === 'string') {
            this.hostname = config.hostname;
        }
        this.shutdown = this.shutdown.bind(this);
        this._shutdownOnce = new utils_callback_BindOnceFuture(this._shutdown, this);
        this._concurrencyLimit =
            typeof config.concurrencyLimit === 'number'
                ? config.concurrencyLimit
                : Infinity;
        this.timeoutMillis = configureExporterTimeout(config.timeoutMillis);
        // platform dependent
        this.onInit(config);
    }
    /**
     * Export items.
     * @param items
     * @param resultCallback
     */
    OTLPExporterBase.prototype.export = function (items, resultCallback) {
        if (this._shutdownOnce.isCalled) {
            resultCallback({
                code: esm_ExportResult_ExportResultCode.FAILED,
                error: new Error('Exporter has been shutdown'),
            });
            return;
        }
        if (this._sendingPromises.length >= this._concurrencyLimit) {
            resultCallback({
                code: esm_ExportResult_ExportResultCode.FAILED,
                error: new Error('Concurrent export limit reached'),
            });
            return;
        }
        this._export(items)
            .then(function () {
            resultCallback({ code: esm_ExportResult_ExportResultCode.SUCCESS });
        })
            .catch(function (error) {
            resultCallback({ code: esm_ExportResult_ExportResultCode.FAILED, error: error });
        });
    };
    OTLPExporterBase.prototype._export = function (items) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                esm_diag.debug('items to be sent', items);
                _this.send(items, resolve, reject);
            }
            catch (e) {
                reject(e);
            }
        });
    };
    /**
     * Shutdown the exporter.
     */
    OTLPExporterBase.prototype.shutdown = function () {
        return this._shutdownOnce.call();
    };
    /**
     * Called by _shutdownOnce with BindOnceFuture
     */
    OTLPExporterBase.prototype._shutdown = function () {
        esm_diag.debug('shutdown started');
        this.onShutdown();
        return Promise.all(this._sendingPromises)
            .then(function () {
            /** ignore resolved values */
        });
    };
    return OTLPExporterBase;
}());

//# sourceMappingURL=OTLPExporterBase.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/build/esm/types.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var types_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Interface for handling error
 */
var OTLPExporterError = /** @class */ (function (_super) {
    types_extends(OTLPExporterError, _super);
    function OTLPExporterError(message, code, data) {
        var _this = _super.call(this, message) || this;
        _this.name = 'OTLPExporterError';
        _this.data = data;
        _this.code = code;
        return _this;
    }
    return OTLPExporterError;
}(Error));

//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/browser/util.js
var util_assign = (undefined && undefined.__assign) || function () {
    util_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return util_assign.apply(this, arguments);
};
var browser_util_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Send metrics/spans using browser navigator.sendBeacon
 * @param body
 * @param url
 * @param blobPropertyBag
 * @param onSuccess
 * @param onError
 */
function sendWithBeacon(body, url, blobPropertyBag, onSuccess, onError) {
    if (navigator.sendBeacon(url, new Blob([body], blobPropertyBag))) {
        esm_diag.debug('sendBeacon - can send', body);
        onSuccess();
    }
    else {
        var error = new OTLPExporterError("sendBeacon - cannot send " + body);
        onError(error);
    }
}
/**
 * function to send metrics/spans using browser XMLHttpRequest
 *     used when navigator.sendBeacon is not available
 * @param body
 * @param url
 * @param headers
 * @param onSuccess
 * @param onError
 */
function sendWithXhr(body, url, headers, exporterTimeout, onSuccess, onError) {
    var reqIsDestroyed;
    var exporterTimer = setTimeout(function () {
        reqIsDestroyed = true;
        xhr.abort();
    }, exporterTimeout);
    var xhr = new XMLHttpRequest();
    xhr.open('POST', url);
    var defaultHeaders = {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
    };
    Object.entries(util_assign(util_assign({}, defaultHeaders), headers)).forEach(function (_a) {
        var _b = browser_util_read(_a, 2), k = _b[0], v = _b[1];
        xhr.setRequestHeader(k, v);
    });
    xhr.send(body);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === XMLHttpRequest.DONE) {
            if (xhr.status >= 200 && xhr.status <= 299) {
                clearTimeout(exporterTimer);
                esm_diag.debug('xhr success', body);
                onSuccess();
            }
            else if (reqIsDestroyed) {
                var error = new OTLPExporterError('Request Timeout', xhr.status);
                onError(error);
            }
            else {
                var error = new OTLPExporterError("Failed to export with XHR (status: " + xhr.status + ")", xhr.status);
                clearTimeout(exporterTimer);
                onError(error);
            }
        }
    };
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/browser/OTLPExporterBrowserBase.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var OTLPExporterBrowserBase_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





/**
 * Collector Metric Exporter abstract base class
 */
var OTLPExporterBrowserBase = /** @class */ (function (_super) {
    OTLPExporterBrowserBase_extends(OTLPExporterBrowserBase, _super);
    /**
     * @param config
     */
    function OTLPExporterBrowserBase(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, config) || this;
        _this._useXHR = false;
        _this._useXHR =
            !!config.headers || typeof navigator.sendBeacon !== 'function';
        if (_this._useXHR) {
            _this._headers = Object.assign({}, parseHeaders(config.headers), baggage_utils_parseKeyPairsIntoRecord(browser_environment_getEnv().OTEL_EXPORTER_OTLP_HEADERS));
        }
        else {
            _this._headers = {};
        }
        return _this;
    }
    OTLPExporterBrowserBase.prototype.onInit = function () {
        window.addEventListener('unload', this.shutdown);
    };
    OTLPExporterBrowserBase.prototype.onShutdown = function () {
        window.removeEventListener('unload', this.shutdown);
    };
    OTLPExporterBrowserBase.prototype.send = function (items, onSuccess, onError) {
        var _this = this;
        if (this._shutdownOnce.isCalled) {
            esm_diag.debug('Shutdown already started. Cannot send objects');
            return;
        }
        var serviceRequest = this.convert(items);
        var body = JSON.stringify(serviceRequest);
        var promise = new Promise(function (resolve, reject) {
            if (_this._useXHR) {
                sendWithXhr(body, _this.url, _this._headers, _this.timeoutMillis, resolve, reject);
            }
            else {
                sendWithBeacon(body, _this.url, { type: 'application/json' }, resolve, reject);
            }
        })
            .then(onSuccess, onError);
        this._sendingPromises.push(promise);
        var popPromise = function () {
            var index = _this._sendingPromises.indexOf(promise);
            _this._sendingPromises.splice(index, 1);
        };
        promise.then(popPromise, popPromise);
    };
    return OTLPExporterBrowserBase;
}(OTLPExporterBase));

//# sourceMappingURL=OTLPExporterBrowserBase.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/browser/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-exporter-base/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/build/esm/trace/types.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * SpanKind is the type of span. Can be used to specify additional relationships between spans
 * in addition to a parent/child relationship.
 */
var ESpanKind;
(function (ESpanKind) {
    /** Unspecified. Do NOT use as default. Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED. */
    ESpanKind[ESpanKind["SPAN_KIND_UNSPECIFIED"] = 0] = "SPAN_KIND_UNSPECIFIED";
    /** Indicates that the span represents an internal operation within an application,
      * as opposed to an operation happening at the boundaries. Default value.
      */
    ESpanKind[ESpanKind["SPAN_KIND_INTERNAL"] = 1] = "SPAN_KIND_INTERNAL";
    /** Indicates that the span covers server-side handling of an RPC or other
      * remote network request.
      */
    ESpanKind[ESpanKind["SPAN_KIND_SERVER"] = 2] = "SPAN_KIND_SERVER";
    /** Indicates that the span describes a request to some remote service.
      */
    ESpanKind[ESpanKind["SPAN_KIND_CLIENT"] = 3] = "SPAN_KIND_CLIENT";
    /** Indicates that the span describes a producer sending a message to a broker.
      * Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
      * between producer and consumer spans. A PRODUCER span ends when the message was accepted
      * by the broker while the logical processing of the message might span a much longer time.
      */
    ESpanKind[ESpanKind["SPAN_KIND_PRODUCER"] = 4] = "SPAN_KIND_PRODUCER";
    /** Indicates that the span describes consumer receiving a message from a broker.
      * Like the PRODUCER kind, there is often no direct critical path latency relationship
      * between producer and consumer spans.
      */
    ESpanKind[ESpanKind["SPAN_KIND_CONSUMER"] = 5] = "SPAN_KIND_CONSUMER";
})(ESpanKind || (ESpanKind = {}));
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/build/esm/common/internal.js
var internal_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function internal_toAttributes(attributes) {
    return Object.keys(attributes).map(function (key) { return toKeyValue(key, attributes[key]); });
}
function toKeyValue(key, value) {
    return {
        key: key,
        value: toAnyValue(value),
    };
}
function toAnyValue(value) {
    var t = typeof value;
    if (t === 'string')
        return { stringValue: value };
    if (t === 'number') {
        if (!Number.isInteger(value))
            return { doubleValue: value };
        return { intValue: value };
    }
    if (t === 'boolean')
        return { boolValue: value };
    if (value instanceof Uint8Array)
        return { bytesValue: value };
    if (Array.isArray(value))
        return { arrayValue: { values: value.map(toAnyValue) } };
    if (t === 'object' && value != null)
        return { kvlistValue: { values: Object.entries(value).map(function (_a) {
                    var _b = internal_read(_a, 2), k = _b[0], v = _b[1];
                    return toKeyValue(k, v);
                }) } };
    return {};
}
function hexToBuf(hex) {
    var _a;
    var ints = (_a = hex.match(/[\da-f]{2}/gi)) === null || _a === void 0 ? void 0 : _a.map(function (h) { return parseInt(h, 16); });
    return ints && new Uint8Array(ints);
}
function i2hex(i) {
    return ('0' + i.toString(16)).slice(-2);
}
function bufToHex(buf) {
    if (buf == null || buf.length === 0)
        return undefined;
    return Array.from(buf).map(i2hex).join('');
}
//# sourceMappingURL=internal.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var esm_trace_suppress_tracing_SUPPRESS_TRACING_KEY = createContextKey('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function esm_trace_suppress_tracing_suppressTracing(context) {
    return context.setValue(esm_trace_suppress_tracing_SUPPRESS_TRACING_KEY, true);
}
function esm_trace_suppress_tracing_unsuppressTracing(context) {
    return context.deleteValue(esm_trace_suppress_tracing_SUPPRESS_TRACING_KEY);
}
function esm_trace_suppress_tracing_isTracingSuppressed(context) {
    return context.getValue(esm_trace_suppress_tracing_SUPPRESS_TRACING_KEY) === true;
}
//# sourceMappingURL=suppress-tracing.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/baggage/constants.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_baggage_constants_BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var esm_baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR = ';';
var build_esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR = ',';
// Name of the http header used to propagate the baggage
var esm_baggage_constants_BAGGAGE_HEADER = 'baggage';
// Maximum number of name-value pairs allowed by w3c spec
var esm_baggage_constants_BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
// Maximum number of bytes per a single name-value pair allowed by w3c spec
var esm_baggage_constants_BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
// Maximum total length of all name-value pairs allowed by w3c spec
var esm_baggage_constants_BAGGAGE_MAX_TOTAL_LENGTH = 8192;
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/baggage/utils.js
var build_esm_baggage_utils_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function esm_baggage_utils_serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function (hValue, current) {
        var value = "" + hValue + (hValue !== '' ? build_esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR : '') + current;
        return value.length > esm_baggage_constants_BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, '');
}
function esm_baggage_utils_getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function (_a) {
        var _b = build_esm_baggage_utils_read(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) {
            entry += esm_baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
    });
}
function esm_baggage_utils_parsePairKeyValue(entry) {
    var valueProps = entry.split(esm_baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
        return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart)
        return;
    var keyPair = keyPairPart.split(esm_baggage_constants_BAGGAGE_KEY_PAIR_SEPARATOR);
    if (keyPair.length !== 2)
        return;
    var key = decodeURIComponent(keyPair[0].trim());
    var value = decodeURIComponent(keyPair[1].trim());
    var metadata;
    if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(esm_baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key: key, value: value, metadata: metadata };
}
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */
function esm_baggage_utils_parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0)
        return {};
    return value
        .split(BAGGAGE_ITEMS_SEPARATOR)
        .map(function (entry) {
        return esm_baggage_utils_parsePairKeyValue(entry);
    })
        .filter(function (keyPair) { return keyPair !== undefined && keyPair.value.length > 0; })
        .reduce(function (headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Propagates {@link Baggage} through Context format propagation.
 *
 * Based on the Baggage specification:
 * https://w3c.github.io/baggage/
 */
var baggage_propagation_W3CBaggagePropagator_W3CBaggagePropagator = /** @class */ (function () {
    function W3CBaggagePropagator() {
    }
    W3CBaggagePropagator.prototype.inject = function (context, carrier, setter) {
        var baggage = propagation.getBaggage(context);
        if (!baggage || esm_trace_suppress_tracing_isTracingSuppressed(context))
            return;
        var keyPairs = esm_baggage_utils_getKeyPairs(baggage)
            .filter(function (pair) {
            return pair.length <= esm_baggage_constants_BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        })
            .slice(0, esm_baggage_constants_BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = esm_baggage_utils_serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
            setter.set(carrier, esm_baggage_constants_BAGGAGE_HEADER, headerValue);
        }
    };
    W3CBaggagePropagator.prototype.extract = function (context, carrier, getter) {
        var headerValue = getter.get(carrier, esm_baggage_constants_BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(build_esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
            return context;
        var baggage = {};
        if (baggageString.length === 0) {
            return context;
        }
        var pairs = baggageString.split(build_esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function (entry) {
            var keyPair = esm_baggage_utils_parsePairKeyValue(entry);
            if (keyPair) {
                var baggageEntry = { value: keyPair.value };
                if (keyPair.metadata) {
                    baggageEntry.metadata = keyPair.metadata;
                }
                baggage[keyPair.key] = baggageEntry;
            }
        });
        if (Object.entries(baggage).length === 0) {
            return context;
        }
        return propagation.setBaggage(context, propagation.createBaggage(baggage));
    };
    W3CBaggagePropagator.prototype.fields = function () {
        return [esm_baggage_constants_BAGGAGE_HEADER];
    };
    return W3CBaggagePropagator;
}());

//# sourceMappingURL=W3CBaggagePropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/common/anchored-clock.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A utility for returning wall times anchored to a given point in time. Wall time measurements will
 * not be taken from the system, but instead are computed by adding a monotonic clock time
 * to the anchor point.
 *
 * This is needed because the system time can change and result in unexpected situations like
 * spans ending before they are started. Creating an anchored clock for each local root span
 * ensures that span timings and durations are accurate while preventing span times from drifting
 * too far from the system clock.
 *
 * Only creating an anchored clock once per local trace ensures span times are correct relative
 * to each other. For example, a child span will never have a start time before its parent even
 * if the system clock is corrected during the local trace.
 *
 * Heavily inspired by the OTel Java anchored clock
 * https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk/trace/src/main/java/io/opentelemetry/sdk/trace/AnchoredClock.java
 */
var common_anchored_clock_AnchoredClock = /** @class */ (function () {
    /**
     * Create a new AnchoredClock anchored to the current time returned by systemClock.
     *
     * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
     * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
     */
    function AnchoredClock(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
    }
    /**
     * Returns the current time by adding the number of milliseconds since the
     * AnchoredClock was created to the creation epoch time
     */
    AnchoredClock.prototype.now = function () {
        var delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
    };
    return AnchoredClock;
}());

//# sourceMappingURL=anchored-clock.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/common/attributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var build_esm_common_attributes_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var build_esm_common_attributes_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

function esm_common_attributes_sanitizeAttributes(attributes) {
    var e_1, _a;
    var out = {};
    if (typeof attributes !== 'object' || attributes == null) {
        return out;
    }
    try {
        for (var _b = build_esm_common_attributes_values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = build_esm_common_attributes_read(_c.value, 2), key = _d[0], val = _d[1];
            if (!esm_common_attributes_isAttributeKey(key)) {
                diag.warn("Invalid attribute key: " + key);
                continue;
            }
            if (!esm_common_attributes_isAttributeValue(val)) {
                diag.warn("Invalid attribute value set for key: " + key);
                continue;
            }
            if (Array.isArray(val)) {
                out[key] = val.slice();
            }
            else {
                out[key] = val;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return out;
}
function esm_common_attributes_isAttributeKey(key) {
    return typeof key === 'string' && key.length > 0;
}
function esm_common_attributes_isAttributeValue(val) {
    if (val == null) {
        return true;
    }
    if (Array.isArray(val)) {
        return esm_common_attributes_isHomogeneousAttributeValueArray(val);
    }
    return esm_common_attributes_isValidPrimitiveAttributeValue(val);
}
function esm_common_attributes_isHomogeneousAttributeValueArray(arr) {
    var e_2, _a;
    var type;
    try {
        for (var arr_1 = build_esm_common_attributes_values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var element = arr_1_1.value;
            // null/undefined elements are allowed
            if (element == null)
                continue;
            if (!type) {
                if (esm_common_attributes_isValidPrimitiveAttributeValue(element)) {
                    type = typeof element;
                    continue;
                }
                // encountered an invalid primitive
                return false;
            }
            if (typeof element === type) {
                continue;
            }
            return false;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return true;
}
function esm_common_attributes_isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
        case 'number':
        case 'boolean':
        case 'string':
            return true;
    }
    return false;
}
//# sourceMappingURL=attributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */
function esm_common_logging_error_handler_loggingErrorHandler() {
    return function (ex) {
        esm_diag.error(esm_common_logging_error_handler_stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */
function esm_common_logging_error_handler_stringifyException(ex) {
    if (typeof ex === 'string') {
        return ex;
    }
    else {
        return JSON.stringify(esm_common_logging_error_handler_flattenException(ex));
    }
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */
function esm_common_logging_error_handler_flattenException(ex) {
    var result = {};
    var current = ex;
    while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function (propertyName) {
            if (result[propertyName])
                return;
            var value = current[propertyName];
            if (value) {
                result[propertyName] = String(value);
            }
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}
//# sourceMappingURL=logging-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** The global error handler delegate */
var esm_common_global_error_handler_delegateHandler = esm_common_logging_error_handler_loggingErrorHandler();
/**
 * Set the global error handler
 * @param {ErrorHandler} handler
 */
function esm_common_global_error_handler_setGlobalErrorHandler(handler) {
    esm_common_global_error_handler_delegateHandler = handler;
}
/**
 * Return the global error handler
 * @param {Exception} ex
 */
function esm_common_global_error_handler_globalErrorHandler(ex) {
    try {
        esm_common_global_error_handler_delegateHandler(ex);
    }
    catch (_a) { } // eslint-disable-line no-empty
}
//# sourceMappingURL=global-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/utils/sampling.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_utils_sampling_TracesSamplerValues;
(function (TracesSamplerValues) {
    TracesSamplerValues["AlwaysOff"] = "always_off";
    TracesSamplerValues["AlwaysOn"] = "always_on";
    TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues["TraceIdRatio"] = "traceidratio";
})(esm_utils_sampling_TracesSamplerValues || (esm_utils_sampling_TracesSamplerValues = {}));
//# sourceMappingURL=sampling.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/platform/browser/globalThis.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/api-metrics too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var build_esm_platform_browser_globalThis_globalThis = typeof globalThis === 'object' ? globalThis :
    typeof self === 'object' ? self :
        typeof window === 'object' ? window :
            typeof __webpack_require__.g === 'object' ? __webpack_require__.g :
                {};
//# sourceMappingURL=globalThis.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/utils/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var esm_utils_environment_DEFAULT_LIST_SEPARATOR = ',';
/**
 * Environment interface to define all names
 */
var esm_utils_environment_ENVIRONMENT_NUMBERS_KEYS = (/* unused pure expression or super */ null && ([
    'OTEL_BSP_EXPORT_TIMEOUT',
    'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BSP_MAX_QUEUE_SIZE',
    'OTEL_BSP_SCHEDULE_DELAY',
    'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_LINK_COUNT_LIMIT',
    'OTEL_EXPORTER_OTLP_TIMEOUT',
    'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
    'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
    'OTEL_EXPORTER_JAEGER_AGENT_PORT',
]));
function esm_utils_environment_isEnvVarANumber(key) {
    return (esm_utils_environment_ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1);
}
var esm_utils_environment_ENVIRONMENT_LISTS_KEYS = (/* unused pure expression or super */ null && ([
    'OTEL_NO_PATCH_MODULES',
    'OTEL_PROPAGATORS',
]));
function esm_utils_environment_isEnvVarAList(key) {
    return esm_utils_environment_ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var esm_utils_environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var esm_utils_environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
/**
 * Default environment variables
 */
var build_esm_utils_environment_DEFAULT_ENVIRONMENT = {
    CONTAINER_NAME: '',
    ECS_CONTAINER_METADATA_URI_V4: '',
    ECS_CONTAINER_METADATA_URI: '',
    HOSTNAME: '',
    KUBERNETES_SERVICE_HOST: '',
    NAMESPACE: '',
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: '',
    OTEL_EXPORTER_JAEGER_PASSWORD: '',
    OTEL_EXPORTER_JAEGER_USER: '',
    OTEL_EXPORTER_OTLP_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_HEADERS: '',
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
    OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
    OTEL_LOG_LEVEL: DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
    OTEL_RESOURCE_ATTRIBUTES: '',
    OTEL_SERVICE_NAME: '',
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: esm_utils_environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: esm_utils_environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: esm_utils_environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: esm_utils_environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_TRACES_EXPORTER: 'none',
    OTEL_TRACES_SAMPLER: esm_utils_sampling_TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: '',
    OTEL_EXPORTER_OTLP_INSECURE: '',
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
    OTEL_EXPORTER_OTLP_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: ''
};
/**
 * Parses a variable as number with number validation
 * @param name
 * @param environment
 * @param values
 * @param min
 * @param max
 */
function esm_utils_environment_parseNumber(name, environment, values, min, max) {
    if (min === void 0) { min = -Infinity; }
    if (max === void 0) { max = Infinity; }
    if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
            if (value < min) {
                environment[name] = min;
            }
            else if (value > max) {
                environment[name] = max;
            }
            else {
                environment[name] = value;
            }
        }
    }
}
/**
 * Parses list-like strings from input into output.
 * @param name
 * @param environment
 * @param values
 * @param separator
 */
function esm_utils_environment_parseStringList(name, output, input, separator) {
    if (separator === void 0) { separator = esm_utils_environment_DEFAULT_LIST_SEPARATOR; }
    var givenValue = input[name];
    if (typeof givenValue === 'string') {
        output[name] = givenValue.split(separator).map(function (v) { return v.trim(); });
    }
}
// The support string -> DiagLogLevel mappings
var esm_utils_environment_logLevelMap = {
    ALL: DiagLogLevel.ALL,
    VERBOSE: DiagLogLevel.VERBOSE,
    DEBUG: DiagLogLevel.DEBUG,
    INFO: DiagLogLevel.INFO,
    WARN: DiagLogLevel.WARN,
    ERROR: DiagLogLevel.ERROR,
    NONE: DiagLogLevel.NONE,
};
/**
 * Environmentally sets log level if valid log level string is provided
 * @param key
 * @param environment
 * @param values
 */
function esm_utils_environment_setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if (typeof value === 'string') {
        var theLevel = esm_utils_environment_logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
            environment[key] = theLevel;
        }
    }
}
/**
 * Parses environment values
 * @param values
 */
function build_esm_utils_environment_parseEnvironment(values) {
    var environment = {};
    for (var env in build_esm_utils_environment_DEFAULT_ENVIRONMENT) {
        var key = env;
        switch (key) {
            case 'OTEL_LOG_LEVEL':
                esm_utils_environment_setLogLevelFromEnv(key, environment, values);
                break;
            default:
                if (esm_utils_environment_isEnvVarANumber(key)) {
                    esm_utils_environment_parseNumber(key, environment, values);
                }
                else if (esm_utils_environment_isEnvVarAList(key)) {
                    esm_utils_environment_parseStringList(key, environment, values);
                }
                else {
                    var value = values[key];
                    if (typeof value !== 'undefined' && value !== null) {
                        environment[key] = String(value);
                    }
                }
        }
    }
    return environment;
}
/**
 * Get environment in node or browser without
 * populating default values.
 */
function esm_utils_environment_getEnvWithoutDefaults() {
    return typeof process !== 'undefined' ?
        build_esm_utils_environment_parseEnvironment("MISSING_ENV_VAR") :
        build_esm_utils_environment_parseEnvironment(_globalThis);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/platform/browser/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Gets the environment variables
 */
function platform_browser_environment_getEnv() {
    var globalEnv = parseEnvironment(_globalThis);
    return Object.assign({}, DEFAULT_ENVIRONMENT, globalEnv);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/platform/browser/hex-to-base64.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hexToBase64(hexStr) {
    var hexStrLen = hexStr.length;
    var hexAsciiCharsStr = '';
    for (var i = 0; i < hexStrLen; i += 2) {
        var hexPair = hexStr.substring(i, i + 2);
        var hexVal = parseInt(hexPair, 16);
        hexAsciiCharsStr += String.fromCharCode(hexVal);
    }
    return btoa(hexAsciiCharsStr);
}
//# sourceMappingURL=hex-to-base64.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/platform/browser/RandomIdGenerator.js
var platform_browser_RandomIdGenerator_SPAN_ID_BYTES = 8;
var platform_browser_RandomIdGenerator_TRACE_ID_BYTES = 16;
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 */
var platform_browser_RandomIdGenerator_RandomIdGenerator = /** @class */ (function () {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */
        this.generateTraceId = platform_browser_RandomIdGenerator_getIdGenerator(platform_browser_RandomIdGenerator_TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */
        this.generateSpanId = platform_browser_RandomIdGenerator_getIdGenerator(platform_browser_RandomIdGenerator_SPAN_ID_BYTES);
    }
    return RandomIdGenerator;
}());

var platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY = Array(32);
function platform_browser_RandomIdGenerator_getIdGenerator(bytes) {
    return function generateId() {
        for (var i = 0; i < bytes * 2; i++) {
            platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
            // valid hex characters in the range 48-57 and 97-102
            if (platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] >= 58) {
                platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] += 39;
            }
        }
        return String.fromCharCode.apply(null, platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
    };
}
//# sourceMappingURL=RandomIdGenerator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/platform/browser/performance.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var platform_browser_performance_otperformance = performance;
//# sourceMappingURL=performance.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/version.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var core_build_esm_version_VERSION = '1.7.0';
//# sourceMappingURL=version.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var esm_trace_SemanticAttributes_SemanticAttributes = {
    /**
    * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
    *
    * Note: This may be different from `faas.id` if an alias is involved.
    */
    AWS_LAMBDA_INVOKED_ARN: 'aws.lambda.invoked_arn',
    /**
    * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
    */
    DB_SYSTEM: 'db.system',
    /**
    * The connection string used to connect to the database. It is recommended to remove embedded credentials.
    */
    DB_CONNECTION_STRING: 'db.connection_string',
    /**
    * Username for accessing the database.
    */
    DB_USER: 'db.user',
    /**
    * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
    */
    DB_JDBC_DRIVER_CLASSNAME: 'db.jdbc.driver_classname',
    /**
    * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
    *
    * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
    */
    DB_NAME: 'db.name',
    /**
    * The database statement being executed.
    *
    * Note: The value may be sanitized to exclude sensitive information.
    */
    DB_STATEMENT: 'db.statement',
    /**
    * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
    *
    * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
    */
    DB_OPERATION: 'db.operation',
    /**
    * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
    *
    * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
    */
    DB_MSSQL_INSTANCE_NAME: 'db.mssql.instance_name',
    /**
    * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_CASSANDRA_KEYSPACE: 'db.cassandra.keyspace',
    /**
    * The fetch size used for paging, i.e. how many rows will be returned at once.
    */
    DB_CASSANDRA_PAGE_SIZE: 'db.cassandra.page_size',
    /**
    * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
    */
    DB_CASSANDRA_CONSISTENCY_LEVEL: 'db.cassandra.consistency_level',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_CASSANDRA_TABLE: 'db.cassandra.table',
    /**
    * Whether or not the query is idempotent.
    */
    DB_CASSANDRA_IDEMPOTENCE: 'db.cassandra.idempotence',
    /**
    * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
    */
    DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: 'db.cassandra.speculative_execution_count',
    /**
    * The ID of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_ID: 'db.cassandra.coordinator.id',
    /**
    * The data center of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_DC: 'db.cassandra.coordinator.dc',
    /**
    * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_HBASE_NAMESPACE: 'db.hbase.namespace',
    /**
    * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
    */
    DB_REDIS_DATABASE_INDEX: 'db.redis.database_index',
    /**
    * The collection being accessed within the database stated in `db.name`.
    */
    DB_MONGODB_COLLECTION: 'db.mongodb.collection',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_SQL_TABLE: 'db.sql.table',
    /**
    * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
    */
    EXCEPTION_TYPE: 'exception.type',
    /**
    * The exception message.
    */
    EXCEPTION_MESSAGE: 'exception.message',
    /**
    * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
    */
    EXCEPTION_STACKTRACE: 'exception.stacktrace',
    /**
    * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
    *
    * Note: An exception is considered to have escaped (or left) the scope of a span,
  if that span is ended while the exception is still logically &#34;in flight&#34;.
  This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
  is passed to a Context manager&#39;s `__exit__` method in Python) but will
  usually be caught at the point of recording the exception in most languages.
  
  It is usually not possible to determine at the point where an exception is thrown
  whether it will escape the scope of a span.
  However, it is trivial to know that an exception
  will escape, if one checks for an active exception just before ending the span,
  as done in the [example above](#exception-end-example).
  
  It follows that an exception may still escape the scope of the span
  even if the `exception.escaped` attribute was not set or set to false,
  since the event might have been recorded at a time where it was not
  clear whether the exception will escape.
    */
    EXCEPTION_ESCAPED: 'exception.escaped',
    /**
    * Type of the trigger on which the function is executed.
    */
    FAAS_TRIGGER: 'faas.trigger',
    /**
    * The execution ID of the current function execution.
    */
    FAAS_EXECUTION: 'faas.execution',
    /**
    * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
    */
    FAAS_DOCUMENT_COLLECTION: 'faas.document.collection',
    /**
    * Describes the type of the operation that was performed on the data.
    */
    FAAS_DOCUMENT_OPERATION: 'faas.document.operation',
    /**
    * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_DOCUMENT_TIME: 'faas.document.time',
    /**
    * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
    */
    FAAS_DOCUMENT_NAME: 'faas.document.name',
    /**
    * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_TIME: 'faas.time',
    /**
    * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
    */
    FAAS_CRON: 'faas.cron',
    /**
    * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
    */
    FAAS_COLDSTART: 'faas.coldstart',
    /**
    * The name of the invoked function.
    *
    * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
    */
    FAAS_INVOKED_NAME: 'faas.invoked_name',
    /**
    * The cloud provider of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
    */
    FAAS_INVOKED_PROVIDER: 'faas.invoked_provider',
    /**
    * The cloud region of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
    */
    FAAS_INVOKED_REGION: 'faas.invoked_region',
    /**
    * Transport protocol used. See note below.
    */
    NET_TRANSPORT: 'net.transport',
    /**
    * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
    */
    NET_PEER_IP: 'net.peer.ip',
    /**
    * Remote port number.
    */
    NET_PEER_PORT: 'net.peer.port',
    /**
    * Remote hostname or similar, see note below.
    */
    NET_PEER_NAME: 'net.peer.name',
    /**
    * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
    */
    NET_HOST_IP: 'net.host.ip',
    /**
    * Like `net.peer.port` but for the host port.
    */
    NET_HOST_PORT: 'net.host.port',
    /**
    * Local hostname or similar, see note below.
    */
    NET_HOST_NAME: 'net.host.name',
    /**
    * The internet connection type currently being used by the host.
    */
    NET_HOST_CONNECTION_TYPE: 'net.host.connection.type',
    /**
    * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
    */
    NET_HOST_CONNECTION_SUBTYPE: 'net.host.connection.subtype',
    /**
    * The name of the mobile carrier.
    */
    NET_HOST_CARRIER_NAME: 'net.host.carrier.name',
    /**
    * The mobile carrier country code.
    */
    NET_HOST_CARRIER_MCC: 'net.host.carrier.mcc',
    /**
    * The mobile carrier network code.
    */
    NET_HOST_CARRIER_MNC: 'net.host.carrier.mnc',
    /**
    * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
    */
    NET_HOST_CARRIER_ICC: 'net.host.carrier.icc',
    /**
    * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
    */
    PEER_SERVICE: 'peer.service',
    /**
    * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
    */
    ENDUSER_ID: 'enduser.id',
    /**
    * Actual/assumed role the client is making the request under extracted from token or application security context.
    */
    ENDUSER_ROLE: 'enduser.role',
    /**
    * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
    */
    ENDUSER_SCOPE: 'enduser.scope',
    /**
    * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
    */
    THREAD_ID: 'thread.id',
    /**
    * Current thread name.
    */
    THREAD_NAME: 'thread.name',
    /**
    * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
    */
    CODE_FUNCTION: 'code.function',
    /**
    * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
    */
    CODE_NAMESPACE: 'code.namespace',
    /**
    * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
    */
    CODE_FILEPATH: 'code.filepath',
    /**
    * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
    */
    CODE_LINENO: 'code.lineno',
    /**
    * HTTP request method.
    */
    HTTP_METHOD: 'http.method',
    /**
    * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
    *
    * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
    */
    HTTP_URL: 'http.url',
    /**
    * The full request target as passed in a HTTP request line or equivalent.
    */
    HTTP_TARGET: 'http.target',
    /**
    * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
    *
    * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
    */
    HTTP_HOST: 'http.host',
    /**
    * The URI scheme identifying the used protocol.
    */
    HTTP_SCHEME: 'http.scheme',
    /**
    * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
    */
    HTTP_STATUS_CODE: 'http.status_code',
    /**
    * Kind of HTTP protocol used.
    *
    * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
    */
    HTTP_FLAVOR: 'http.flavor',
    /**
    * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
    */
    HTTP_USER_AGENT: 'http.user_agent',
    /**
    * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_REQUEST_CONTENT_LENGTH: 'http.request_content_length',
    /**
    * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: 'http.request_content_length_uncompressed',
    /**
    * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_RESPONSE_CONTENT_LENGTH: 'http.response_content_length',
    /**
    * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: 'http.response_content_length_uncompressed',
    /**
    * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
    *
    * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
    */
    HTTP_SERVER_NAME: 'http.server_name',
    /**
    * The matched route (path template).
    */
    HTTP_ROUTE: 'http.route',
    /**
    * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
    *
    * Note: This is not necessarily the same as `net.peer.ip`, which would
  identify the network-level peer, which may be a proxy.
  
  This attribute should be set when a source of information different
  from the one used for `net.peer.ip`, is available even if that other
  source just confirms the same value as `net.peer.ip`.
  Rationale: For `net.peer.ip`, one typically does not know if it
  comes from a proxy, reverse proxy, or the actual client. Setting
  `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
  one is at least somewhat confident that the address is not that of
  the closest proxy.
    */
    HTTP_CLIENT_IP: 'http.client_ip',
    /**
    * The keys in the `RequestItems` object field.
    */
    AWS_DYNAMODB_TABLE_NAMES: 'aws.dynamodb.table_names',
    /**
    * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
    */
    AWS_DYNAMODB_CONSUMED_CAPACITY: 'aws.dynamodb.consumed_capacity',
    /**
    * The JSON-serialized value of the `ItemCollectionMetrics` response field.
    */
    AWS_DYNAMODB_ITEM_COLLECTION_METRICS: 'aws.dynamodb.item_collection_metrics',
    /**
    * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: 'aws.dynamodb.provisioned_read_capacity',
    /**
    * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: 'aws.dynamodb.provisioned_write_capacity',
    /**
    * The value of the `ConsistentRead` request parameter.
    */
    AWS_DYNAMODB_CONSISTENT_READ: 'aws.dynamodb.consistent_read',
    /**
    * The value of the `ProjectionExpression` request parameter.
    */
    AWS_DYNAMODB_PROJECTION: 'aws.dynamodb.projection',
    /**
    * The value of the `Limit` request parameter.
    */
    AWS_DYNAMODB_LIMIT: 'aws.dynamodb.limit',
    /**
    * The value of the `AttributesToGet` request parameter.
    */
    AWS_DYNAMODB_ATTRIBUTES_TO_GET: 'aws.dynamodb.attributes_to_get',
    /**
    * The value of the `IndexName` request parameter.
    */
    AWS_DYNAMODB_INDEX_NAME: 'aws.dynamodb.index_name',
    /**
    * The value of the `Select` request parameter.
    */
    AWS_DYNAMODB_SELECT: 'aws.dynamodb.select',
    /**
    * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: 'aws.dynamodb.global_secondary_indexes',
    /**
    * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: 'aws.dynamodb.local_secondary_indexes',
    /**
    * The value of the `ExclusiveStartTableName` request parameter.
    */
    AWS_DYNAMODB_EXCLUSIVE_START_TABLE: 'aws.dynamodb.exclusive_start_table',
    /**
    * The the number of items in the `TableNames` response parameter.
    */
    AWS_DYNAMODB_TABLE_COUNT: 'aws.dynamodb.table_count',
    /**
    * The value of the `ScanIndexForward` request parameter.
    */
    AWS_DYNAMODB_SCAN_FORWARD: 'aws.dynamodb.scan_forward',
    /**
    * The value of the `Segment` request parameter.
    */
    AWS_DYNAMODB_SEGMENT: 'aws.dynamodb.segment',
    /**
    * The value of the `TotalSegments` request parameter.
    */
    AWS_DYNAMODB_TOTAL_SEGMENTS: 'aws.dynamodb.total_segments',
    /**
    * The value of the `Count` response parameter.
    */
    AWS_DYNAMODB_COUNT: 'aws.dynamodb.count',
    /**
    * The value of the `ScannedCount` response parameter.
    */
    AWS_DYNAMODB_SCANNED_COUNT: 'aws.dynamodb.scanned_count',
    /**
    * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
    */
    AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: 'aws.dynamodb.attribute_definitions',
    /**
    * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: 'aws.dynamodb.global_secondary_index_updates',
    /**
    * A string identifying the messaging system.
    */
    MESSAGING_SYSTEM: 'messaging.system',
    /**
    * The message destination name. This might be equal to the span name but is required nevertheless.
    */
    MESSAGING_DESTINATION: 'messaging.destination',
    /**
    * The kind of message destination.
    */
    MESSAGING_DESTINATION_KIND: 'messaging.destination_kind',
    /**
    * A boolean that is true if the message destination is temporary.
    */
    MESSAGING_TEMP_DESTINATION: 'messaging.temp_destination',
    /**
    * The name of the transport protocol.
    */
    MESSAGING_PROTOCOL: 'messaging.protocol',
    /**
    * The version of the transport protocol.
    */
    MESSAGING_PROTOCOL_VERSION: 'messaging.protocol_version',
    /**
    * Connection string.
    */
    MESSAGING_URL: 'messaging.url',
    /**
    * A value used by the messaging system as an identifier for the message, represented as a string.
    */
    MESSAGING_MESSAGE_ID: 'messaging.message_id',
    /**
    * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
    */
    MESSAGING_CONVERSATION_ID: 'messaging.conversation_id',
    /**
    * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
    */
    MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: 'messaging.message_payload_size_bytes',
    /**
    * The compressed size of the message payload in bytes.
    */
    MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: 'messaging.message_payload_compressed_size_bytes',
    /**
    * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
    */
    MESSAGING_OPERATION: 'messaging.operation',
    /**
    * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
    */
    MESSAGING_CONSUMER_ID: 'messaging.consumer_id',
    /**
    * RabbitMQ message routing key.
    */
    MESSAGING_RABBITMQ_ROUTING_KEY: 'messaging.rabbitmq.routing_key',
    /**
    * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
    *
    * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
    */
    MESSAGING_KAFKA_MESSAGE_KEY: 'messaging.kafka.message_key',
    /**
    * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
    */
    MESSAGING_KAFKA_CONSUMER_GROUP: 'messaging.kafka.consumer_group',
    /**
    * Client Id for the Consumer or Producer that is handling the message.
    */
    MESSAGING_KAFKA_CLIENT_ID: 'messaging.kafka.client_id',
    /**
    * Partition the message is sent to.
    */
    MESSAGING_KAFKA_PARTITION: 'messaging.kafka.partition',
    /**
    * A boolean that is true if the message is a tombstone.
    */
    MESSAGING_KAFKA_TOMBSTONE: 'messaging.kafka.tombstone',
    /**
    * A string identifying the remoting system.
    */
    RPC_SYSTEM: 'rpc.system',
    /**
    * The full (logical) name of the service being called, including its package name, if applicable.
    *
    * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
    */
    RPC_SERVICE: 'rpc.service',
    /**
    * The name of the (logical) method being called, must be equal to the $method part in the span name.
    *
    * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
    */
    RPC_METHOD: 'rpc.method',
    /**
    * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
    */
    RPC_GRPC_STATUS_CODE: 'rpc.grpc.status_code',
    /**
    * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
    */
    RPC_JSONRPC_VERSION: 'rpc.jsonrpc.version',
    /**
    * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
    */
    RPC_JSONRPC_REQUEST_ID: 'rpc.jsonrpc.request_id',
    /**
    * `error.code` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_CODE: 'rpc.jsonrpc.error_code',
    /**
    * `error.message` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_MESSAGE: 'rpc.jsonrpc.error_message',
    /**
    * Whether this is a received or sent message.
    */
    MESSAGE_TYPE: 'message.type',
    /**
    * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
    *
    * Note: This way we guarantee that the values will be consistent between different implementations.
    */
    MESSAGE_ID: 'message.id',
    /**
    * Compressed size of the message in bytes.
    */
    MESSAGE_COMPRESSED_SIZE: 'message.compressed_size',
    /**
    * Uncompressed size of the message in bytes.
    */
    MESSAGE_UNCOMPRESSED_SIZE: 'message.uncompressed_size',
};
var esm_trace_SemanticAttributes_DbSystemValues = {
    /** Some other SQL database. Fallback only. See notes. */
    OTHER_SQL: 'other_sql',
    /** Microsoft SQL Server. */
    MSSQL: 'mssql',
    /** MySQL. */
    MYSQL: 'mysql',
    /** Oracle Database. */
    ORACLE: 'oracle',
    /** IBM Db2. */
    DB2: 'db2',
    /** PostgreSQL. */
    POSTGRESQL: 'postgresql',
    /** Amazon Redshift. */
    REDSHIFT: 'redshift',
    /** Apache Hive. */
    HIVE: 'hive',
    /** Cloudscape. */
    CLOUDSCAPE: 'cloudscape',
    /** HyperSQL DataBase. */
    HSQLDB: 'hsqldb',
    /** Progress Database. */
    PROGRESS: 'progress',
    /** SAP MaxDB. */
    MAXDB: 'maxdb',
    /** SAP HANA. */
    HANADB: 'hanadb',
    /** Ingres. */
    INGRES: 'ingres',
    /** FirstSQL. */
    FIRSTSQL: 'firstsql',
    /** EnterpriseDB. */
    EDB: 'edb',
    /** InterSystems Caché. */
    CACHE: 'cache',
    /** Adabas (Adaptable Database System). */
    ADABAS: 'adabas',
    /** Firebird. */
    FIREBIRD: 'firebird',
    /** Apache Derby. */
    DERBY: 'derby',
    /** FileMaker. */
    FILEMAKER: 'filemaker',
    /** Informix. */
    INFORMIX: 'informix',
    /** InstantDB. */
    INSTANTDB: 'instantdb',
    /** InterBase. */
    INTERBASE: 'interbase',
    /** MariaDB. */
    MARIADB: 'mariadb',
    /** Netezza. */
    NETEZZA: 'netezza',
    /** Pervasive PSQL. */
    PERVASIVE: 'pervasive',
    /** PointBase. */
    POINTBASE: 'pointbase',
    /** SQLite. */
    SQLITE: 'sqlite',
    /** Sybase. */
    SYBASE: 'sybase',
    /** Teradata. */
    TERADATA: 'teradata',
    /** Vertica. */
    VERTICA: 'vertica',
    /** H2. */
    H2: 'h2',
    /** ColdFusion IMQ. */
    COLDFUSION: 'coldfusion',
    /** Apache Cassandra. */
    CASSANDRA: 'cassandra',
    /** Apache HBase. */
    HBASE: 'hbase',
    /** MongoDB. */
    MONGODB: 'mongodb',
    /** Redis. */
    REDIS: 'redis',
    /** Couchbase. */
    COUCHBASE: 'couchbase',
    /** CouchDB. */
    COUCHDB: 'couchdb',
    /** Microsoft Azure Cosmos DB. */
    COSMOSDB: 'cosmosdb',
    /** Amazon DynamoDB. */
    DYNAMODB: 'dynamodb',
    /** Neo4j. */
    NEO4J: 'neo4j',
    /** Apache Geode. */
    GEODE: 'geode',
    /** Elasticsearch. */
    ELASTICSEARCH: 'elasticsearch',
    /** Memcached. */
    MEMCACHED: 'memcached',
    /** CockroachDB. */
    COCKROACHDB: 'cockroachdb',
};
var esm_trace_SemanticAttributes_DbCassandraConsistencyLevelValues = {
    /** all. */
    ALL: 'all',
    /** each_quorum. */
    EACH_QUORUM: 'each_quorum',
    /** quorum. */
    QUORUM: 'quorum',
    /** local_quorum. */
    LOCAL_QUORUM: 'local_quorum',
    /** one. */
    ONE: 'one',
    /** two. */
    TWO: 'two',
    /** three. */
    THREE: 'three',
    /** local_one. */
    LOCAL_ONE: 'local_one',
    /** any. */
    ANY: 'any',
    /** serial. */
    SERIAL: 'serial',
    /** local_serial. */
    LOCAL_SERIAL: 'local_serial',
};
var esm_trace_SemanticAttributes_FaasTriggerValues = {
    /** A response to some data source operation such as a database or filesystem read/write. */
    DATASOURCE: 'datasource',
    /** To provide an answer to an inbound HTTP request. */
    HTTP: 'http',
    /** A function is set to be executed when messages are sent to a messaging system. */
    PUBSUB: 'pubsub',
    /** A function is scheduled to be executed regularly. */
    TIMER: 'timer',
    /** If none of the others apply. */
    OTHER: 'other',
};
var esm_trace_SemanticAttributes_FaasDocumentOperationValues = {
    /** When a new object is created. */
    INSERT: 'insert',
    /** When an object is modified. */
    EDIT: 'edit',
    /** When an object is deleted. */
    DELETE: 'delete',
};
var esm_trace_SemanticAttributes_FaasInvokedProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var esm_trace_SemanticAttributes_NetTransportValues = {
    /** ip_tcp. */
    IP_TCP: 'ip_tcp',
    /** ip_udp. */
    IP_UDP: 'ip_udp',
    /** Another IP-based protocol. */
    IP: 'ip',
    /** Unix Domain socket. See below. */
    UNIX: 'unix',
    /** Named or anonymous pipe. See note below. */
    PIPE: 'pipe',
    /** In-process communication. */
    INPROC: 'inproc',
    /** Something else (non IP-based). */
    OTHER: 'other',
};
var esm_trace_SemanticAttributes_NetHostConnectionTypeValues = {
    /** wifi. */
    WIFI: 'wifi',
    /** wired. */
    WIRED: 'wired',
    /** cell. */
    CELL: 'cell',
    /** unavailable. */
    UNAVAILABLE: 'unavailable',
    /** unknown. */
    UNKNOWN: 'unknown',
};
var esm_trace_SemanticAttributes_NetHostConnectionSubtypeValues = {
    /** GPRS. */
    GPRS: 'gprs',
    /** EDGE. */
    EDGE: 'edge',
    /** UMTS. */
    UMTS: 'umts',
    /** CDMA. */
    CDMA: 'cdma',
    /** EVDO Rel. 0. */
    EVDO_0: 'evdo_0',
    /** EVDO Rev. A. */
    EVDO_A: 'evdo_a',
    /** CDMA2000 1XRTT. */
    CDMA2000_1XRTT: 'cdma2000_1xrtt',
    /** HSDPA. */
    HSDPA: 'hsdpa',
    /** HSUPA. */
    HSUPA: 'hsupa',
    /** HSPA. */
    HSPA: 'hspa',
    /** IDEN. */
    IDEN: 'iden',
    /** EVDO Rev. B. */
    EVDO_B: 'evdo_b',
    /** LTE. */
    LTE: 'lte',
    /** EHRPD. */
    EHRPD: 'ehrpd',
    /** HSPAP. */
    HSPAP: 'hspap',
    /** GSM. */
    GSM: 'gsm',
    /** TD-SCDMA. */
    TD_SCDMA: 'td_scdma',
    /** IWLAN. */
    IWLAN: 'iwlan',
    /** 5G NR (New Radio). */
    NR: 'nr',
    /** 5G NRNSA (New Radio Non-Standalone). */
    NRNSA: 'nrnsa',
    /** LTE CA. */
    LTE_CA: 'lte_ca',
};
var esm_trace_SemanticAttributes_HttpFlavorValues = {
    /** HTTP 1.0. */
    HTTP_1_0: '1.0',
    /** HTTP 1.1. */
    HTTP_1_1: '1.1',
    /** HTTP 2. */
    HTTP_2_0: '2.0',
    /** SPDY protocol. */
    SPDY: 'SPDY',
    /** QUIC protocol. */
    QUIC: 'QUIC',
};
var esm_trace_SemanticAttributes_MessagingDestinationKindValues = {
    /** A message sent to a queue. */
    QUEUE: 'queue',
    /** A message sent to a topic. */
    TOPIC: 'topic',
};
var esm_trace_SemanticAttributes_MessagingOperationValues = {
    /** receive. */
    RECEIVE: 'receive',
    /** process. */
    PROCESS: 'process',
};
var esm_trace_SemanticAttributes_RpcGrpcStatusCodeValues = {
    /** OK. */
    OK: 0,
    /** CANCELLED. */
    CANCELLED: 1,
    /** UNKNOWN. */
    UNKNOWN: 2,
    /** INVALID_ARGUMENT. */
    INVALID_ARGUMENT: 3,
    /** DEADLINE_EXCEEDED. */
    DEADLINE_EXCEEDED: 4,
    /** NOT_FOUND. */
    NOT_FOUND: 5,
    /** ALREADY_EXISTS. */
    ALREADY_EXISTS: 6,
    /** PERMISSION_DENIED. */
    PERMISSION_DENIED: 7,
    /** RESOURCE_EXHAUSTED. */
    RESOURCE_EXHAUSTED: 8,
    /** FAILED_PRECONDITION. */
    FAILED_PRECONDITION: 9,
    /** ABORTED. */
    ABORTED: 10,
    /** OUT_OF_RANGE. */
    OUT_OF_RANGE: 11,
    /** UNIMPLEMENTED. */
    UNIMPLEMENTED: 12,
    /** INTERNAL. */
    INTERNAL: 13,
    /** UNAVAILABLE. */
    UNAVAILABLE: 14,
    /** DATA_LOSS. */
    DATA_LOSS: 15,
    /** UNAUTHENTICATED. */
    UNAUTHENTICATED: 16,
};
var esm_trace_SemanticAttributes_MessageTypeValues = {
    /** sent. */
    SENT: 'SENT',
    /** received. */
    RECEIVED: 'RECEIVED',
};
//# sourceMappingURL=SemanticAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var esm_resource_SemanticResourceAttributes_SemanticResourceAttributes = {
    /**
    * Name of the cloud provider.
    */
    CLOUD_PROVIDER: 'cloud.provider',
    /**
    * The cloud account ID the resource is assigned to.
    */
    CLOUD_ACCOUNT_ID: 'cloud.account.id',
    /**
    * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
    */
    CLOUD_REGION: 'cloud.region',
    /**
    * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
    *
    * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
    */
    CLOUD_AVAILABILITY_ZONE: 'cloud.availability_zone',
    /**
    * The cloud platform in use.
    *
    * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
    */
    CLOUD_PLATFORM: 'cloud.platform',
    /**
    * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
    */
    AWS_ECS_CONTAINER_ARN: 'aws.ecs.container.arn',
    /**
    * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
    */
    AWS_ECS_CLUSTER_ARN: 'aws.ecs.cluster.arn',
    /**
    * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
    */
    AWS_ECS_LAUNCHTYPE: 'aws.ecs.launchtype',
    /**
    * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
    */
    AWS_ECS_TASK_ARN: 'aws.ecs.task.arn',
    /**
    * The task definition family this task definition is a member of.
    */
    AWS_ECS_TASK_FAMILY: 'aws.ecs.task.family',
    /**
    * The revision for this task definition.
    */
    AWS_ECS_TASK_REVISION: 'aws.ecs.task.revision',
    /**
    * The ARN of an EKS cluster.
    */
    AWS_EKS_CLUSTER_ARN: 'aws.eks.cluster.arn',
    /**
    * The name(s) of the AWS log group(s) an application is writing to.
    *
    * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
    */
    AWS_LOG_GROUP_NAMES: 'aws.log.group.names',
    /**
    * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
    *
    * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
    */
    AWS_LOG_GROUP_ARNS: 'aws.log.group.arns',
    /**
    * The name(s) of the AWS log stream(s) an application is writing to.
    */
    AWS_LOG_STREAM_NAMES: 'aws.log.stream.names',
    /**
    * The ARN(s) of the AWS log stream(s).
    *
    * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
    */
    AWS_LOG_STREAM_ARNS: 'aws.log.stream.arns',
    /**
    * Container name.
    */
    CONTAINER_NAME: 'container.name',
    /**
    * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
    */
    CONTAINER_ID: 'container.id',
    /**
    * The container runtime managing this container.
    */
    CONTAINER_RUNTIME: 'container.runtime',
    /**
    * Name of the image the container was built on.
    */
    CONTAINER_IMAGE_NAME: 'container.image.name',
    /**
    * Container image tag.
    */
    CONTAINER_IMAGE_TAG: 'container.image.tag',
    /**
    * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
    */
    DEPLOYMENT_ENVIRONMENT: 'deployment.environment',
    /**
    * A unique identifier representing the device.
    *
    * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
    */
    DEVICE_ID: 'device.id',
    /**
    * The model identifier for the device.
    *
    * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
    */
    DEVICE_MODEL_IDENTIFIER: 'device.model.identifier',
    /**
    * The marketing name for the device model.
    *
    * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
    */
    DEVICE_MODEL_NAME: 'device.model.name',
    /**
    * The name of the single function that this runtime instance executes.
    *
    * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
    */
    FAAS_NAME: 'faas.name',
    /**
    * The unique ID of the single function that this runtime instance executes.
    *
    * Note: Depending on the cloud provider, use:
  
  * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
  Take care not to use the &#34;invoked ARN&#34; directly but replace any
  [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
  different aliases.
  * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
  * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
  
  On some providers, it may not be possible to determine the full ID at startup,
  which is why this field cannot be made required. For example, on AWS the account ID
  part of the ARN is not available without calling another AWS API
  which may be deemed too slow for a short-running lambda function.
  As an alternative, consider setting `faas.id` as a span attribute instead.
    */
    FAAS_ID: 'faas.id',
    /**
    * The immutable version of the function being executed.
    *
    * Note: Depending on the cloud provider and platform, use:
  
  * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
    (an integer represented as a decimal string).
  * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
    (i.e., the function name plus the revision suffix).
  * **Google Cloud Functions:** The value of the
    [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
  * **Azure Functions:** Not applicable. Do not set this attribute.
    */
    FAAS_VERSION: 'faas.version',
    /**
    * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
    *
    * Note: * **AWS Lambda:** Use the (full) log stream name.
    */
    FAAS_INSTANCE: 'faas.instance',
    /**
    * The amount of memory available to the serverless function in MiB.
    *
    * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
    */
    FAAS_MAX_MEMORY: 'faas.max_memory',
    /**
    * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
    */
    HOST_ID: 'host.id',
    /**
    * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
    */
    HOST_NAME: 'host.name',
    /**
    * Type of host. For Cloud, this must be the machine type.
    */
    HOST_TYPE: 'host.type',
    /**
    * The CPU architecture the host system is running on.
    */
    HOST_ARCH: 'host.arch',
    /**
    * Name of the VM image or OS install the host was instantiated from.
    */
    HOST_IMAGE_NAME: 'host.image.name',
    /**
    * VM image ID. For Cloud, this value is from the provider.
    */
    HOST_IMAGE_ID: 'host.image.id',
    /**
    * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
    */
    HOST_IMAGE_VERSION: 'host.image.version',
    /**
    * The name of the cluster.
    */
    K8S_CLUSTER_NAME: 'k8s.cluster.name',
    /**
    * The name of the Node.
    */
    K8S_NODE_NAME: 'k8s.node.name',
    /**
    * The UID of the Node.
    */
    K8S_NODE_UID: 'k8s.node.uid',
    /**
    * The name of the namespace that the pod is running in.
    */
    K8S_NAMESPACE_NAME: 'k8s.namespace.name',
    /**
    * The UID of the Pod.
    */
    K8S_POD_UID: 'k8s.pod.uid',
    /**
    * The name of the Pod.
    */
    K8S_POD_NAME: 'k8s.pod.name',
    /**
    * The name of the Container in a Pod template.
    */
    K8S_CONTAINER_NAME: 'k8s.container.name',
    /**
    * The UID of the ReplicaSet.
    */
    K8S_REPLICASET_UID: 'k8s.replicaset.uid',
    /**
    * The name of the ReplicaSet.
    */
    K8S_REPLICASET_NAME: 'k8s.replicaset.name',
    /**
    * The UID of the Deployment.
    */
    K8S_DEPLOYMENT_UID: 'k8s.deployment.uid',
    /**
    * The name of the Deployment.
    */
    K8S_DEPLOYMENT_NAME: 'k8s.deployment.name',
    /**
    * The UID of the StatefulSet.
    */
    K8S_STATEFULSET_UID: 'k8s.statefulset.uid',
    /**
    * The name of the StatefulSet.
    */
    K8S_STATEFULSET_NAME: 'k8s.statefulset.name',
    /**
    * The UID of the DaemonSet.
    */
    K8S_DAEMONSET_UID: 'k8s.daemonset.uid',
    /**
    * The name of the DaemonSet.
    */
    K8S_DAEMONSET_NAME: 'k8s.daemonset.name',
    /**
    * The UID of the Job.
    */
    K8S_JOB_UID: 'k8s.job.uid',
    /**
    * The name of the Job.
    */
    K8S_JOB_NAME: 'k8s.job.name',
    /**
    * The UID of the CronJob.
    */
    K8S_CRONJOB_UID: 'k8s.cronjob.uid',
    /**
    * The name of the CronJob.
    */
    K8S_CRONJOB_NAME: 'k8s.cronjob.name',
    /**
    * The operating system type.
    */
    OS_TYPE: 'os.type',
    /**
    * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
    */
    OS_DESCRIPTION: 'os.description',
    /**
    * Human readable operating system name.
    */
    OS_NAME: 'os.name',
    /**
    * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
    */
    OS_VERSION: 'os.version',
    /**
    * Process identifier (PID).
    */
    PROCESS_PID: 'process.pid',
    /**
    * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_NAME: 'process.executable.name',
    /**
    * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_PATH: 'process.executable.path',
    /**
    * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
    */
    PROCESS_COMMAND: 'process.command',
    /**
    * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
    */
    PROCESS_COMMAND_LINE: 'process.command_line',
    /**
    * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
    */
    PROCESS_COMMAND_ARGS: 'process.command_args',
    /**
    * The username of the user that owns the process.
    */
    PROCESS_OWNER: 'process.owner',
    /**
    * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
    */
    PROCESS_RUNTIME_NAME: 'process.runtime.name',
    /**
    * The version of the runtime of this process, as returned by the runtime without modification.
    */
    PROCESS_RUNTIME_VERSION: 'process.runtime.version',
    /**
    * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
    */
    PROCESS_RUNTIME_DESCRIPTION: 'process.runtime.description',
    /**
    * Logical name of the service.
    *
    * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
    */
    SERVICE_NAME: 'service.name',
    /**
    * A namespace for `service.name`.
    *
    * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
    */
    SERVICE_NAMESPACE: 'service.namespace',
    /**
    * The string ID of the service instance.
    *
    * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
    */
    SERVICE_INSTANCE_ID: 'service.instance.id',
    /**
    * The version string of the service API or implementation.
    */
    SERVICE_VERSION: 'service.version',
    /**
    * The name of the telemetry SDK as defined above.
    */
    TELEMETRY_SDK_NAME: 'telemetry.sdk.name',
    /**
    * The language of the telemetry SDK.
    */
    TELEMETRY_SDK_LANGUAGE: 'telemetry.sdk.language',
    /**
    * The version string of the telemetry SDK.
    */
    TELEMETRY_SDK_VERSION: 'telemetry.sdk.version',
    /**
    * The version string of the auto instrumentation agent, if used.
    */
    TELEMETRY_AUTO_VERSION: 'telemetry.auto.version',
    /**
    * The name of the web engine.
    */
    WEBENGINE_NAME: 'webengine.name',
    /**
    * The version of the web engine.
    */
    WEBENGINE_VERSION: 'webengine.version',
    /**
    * Additional description of the web engine (e.g. detailed version and edition information).
    */
    WEBENGINE_DESCRIPTION: 'webengine.description',
};
var esm_resource_SemanticResourceAttributes_CloudProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var esm_resource_SemanticResourceAttributes_CloudPlatformValues = {
    /** Alibaba Cloud Elastic Compute Service. */
    ALIBABA_CLOUD_ECS: 'alibaba_cloud_ecs',
    /** Alibaba Cloud Function Compute. */
    ALIBABA_CLOUD_FC: 'alibaba_cloud_fc',
    /** AWS Elastic Compute Cloud. */
    AWS_EC2: 'aws_ec2',
    /** AWS Elastic Container Service. */
    AWS_ECS: 'aws_ecs',
    /** AWS Elastic Kubernetes Service. */
    AWS_EKS: 'aws_eks',
    /** AWS Lambda. */
    AWS_LAMBDA: 'aws_lambda',
    /** AWS Elastic Beanstalk. */
    AWS_ELASTIC_BEANSTALK: 'aws_elastic_beanstalk',
    /** Azure Virtual Machines. */
    AZURE_VM: 'azure_vm',
    /** Azure Container Instances. */
    AZURE_CONTAINER_INSTANCES: 'azure_container_instances',
    /** Azure Kubernetes Service. */
    AZURE_AKS: 'azure_aks',
    /** Azure Functions. */
    AZURE_FUNCTIONS: 'azure_functions',
    /** Azure App Service. */
    AZURE_APP_SERVICE: 'azure_app_service',
    /** Google Cloud Compute Engine (GCE). */
    GCP_COMPUTE_ENGINE: 'gcp_compute_engine',
    /** Google Cloud Run. */
    GCP_CLOUD_RUN: 'gcp_cloud_run',
    /** Google Cloud Kubernetes Engine (GKE). */
    GCP_KUBERNETES_ENGINE: 'gcp_kubernetes_engine',
    /** Google Cloud Functions (GCF). */
    GCP_CLOUD_FUNCTIONS: 'gcp_cloud_functions',
    /** Google Cloud App Engine (GAE). */
    GCP_APP_ENGINE: 'gcp_app_engine',
};
var esm_resource_SemanticResourceAttributes_AwsEcsLaunchtypeValues = {
    /** ec2. */
    EC2: 'ec2',
    /** fargate. */
    FARGATE: 'fargate',
};
var esm_resource_SemanticResourceAttributes_HostArchValues = {
    /** AMD64. */
    AMD64: 'amd64',
    /** ARM32. */
    ARM32: 'arm32',
    /** ARM64. */
    ARM64: 'arm64',
    /** Itanium. */
    IA64: 'ia64',
    /** 32-bit PowerPC. */
    PPC32: 'ppc32',
    /** 64-bit PowerPC. */
    PPC64: 'ppc64',
    /** 32-bit x86. */
    X86: 'x86',
};
var esm_resource_SemanticResourceAttributes_OsTypeValues = {
    /** Microsoft Windows. */
    WINDOWS: 'windows',
    /** Linux. */
    LINUX: 'linux',
    /** Apple Darwin. */
    DARWIN: 'darwin',
    /** FreeBSD. */
    FREEBSD: 'freebsd',
    /** NetBSD. */
    NETBSD: 'netbsd',
    /** OpenBSD. */
    OPENBSD: 'openbsd',
    /** DragonFly BSD. */
    DRAGONFLYBSD: 'dragonflybsd',
    /** HP-UX (Hewlett Packard Unix). */
    HPUX: 'hpux',
    /** AIX (Advanced Interactive eXecutive). */
    AIX: 'aix',
    /** Oracle Solaris. */
    SOLARIS: 'solaris',
    /** IBM z/OS. */
    Z_OS: 'z_os',
};
var esm_resource_SemanticResourceAttributes_TelemetrySdkLanguageValues = {
    /** cpp. */
    CPP: 'cpp',
    /** dotnet. */
    DOTNET: 'dotnet',
    /** erlang. */
    ERLANG: 'erlang',
    /** go. */
    GO: 'go',
    /** java. */
    JAVA: 'java',
    /** nodejs. */
    NODEJS: 'nodejs',
    /** php. */
    PHP: 'php',
    /** python. */
    PYTHON: 'python',
    /** ruby. */
    RUBY: 'ruby',
    /** webjs. */
    WEBJS: 'webjs',
};
//# sourceMappingURL=SemanticResourceAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/platform/browser/sdk-info.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var platform_browser_sdk_info_a;


/** Constants describing the SDK in use */
var platform_browser_sdk_info_SDK_INFO = (platform_browser_sdk_info_a = {},
    platform_browser_sdk_info_a[esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_NAME] = 'opentelemetry',
    platform_browser_sdk_info_a[esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = 'browser',
    platform_browser_sdk_info_a[esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = esm_resource_SemanticResourceAttributes_TelemetrySdkLanguageValues.WEBJS,
    platform_browser_sdk_info_a[esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = core_build_esm_version_VERSION,
    platform_browser_sdk_info_a);
//# sourceMappingURL=sdk-info.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/platform/browser/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/common/time.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var esm_common_time_NANOSECOND_DIGITS = 9;
var esm_common_time_SECOND_TO_NANOSECONDS = Math.pow(10, esm_common_time_NANOSECOND_DIGITS);
/**
 * Converts a number to HrTime, HrTime = [number, number].
 * The first number is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * numberToHrtime calculates the first number by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * numberToHrtime calculates the second number by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * SECOND_TO_NANOSECONDS = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 * @param epochMillis
 */
function esm_common_time_numberToHrtime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Number((epochSeconds - seconds).toFixed(esm_common_time_NANOSECOND_DIGITS)) *
        esm_common_time_SECOND_TO_NANOSECONDS;
    return [seconds, nanos];
}
function esm_common_time_getTimeOrigin() {
    var timeOrigin = performance.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = performance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function esm_common_time_hrTime(performanceNow) {
    var timeOrigin = esm_common_time_numberToHrtime(esm_common_time_getTimeOrigin());
    var now = esm_common_time_numberToHrtime(typeof performanceNow === 'number' ? performanceNow : performance.now());
    var seconds = timeOrigin[0] + now[0];
    var nanos = timeOrigin[1] + now[1];
    // Nanoseconds
    if (nanos > esm_common_time_SECOND_TO_NANOSECONDS) {
        nanos -= esm_common_time_SECOND_TO_NANOSECONDS;
        seconds += 1;
    }
    return [seconds, nanos];
}
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */
function esm_common_time_timeInputToHrTime(time) {
    // process.hrtime
    if (esm_common_time_isTimeInputHrTime(time)) {
        return time;
    }
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < esm_common_time_getTimeOrigin()) {
            return esm_common_time_hrTime(time);
        }
        else {
            // epoch milliseconds or performance.timeOrigin
            return esm_common_time_numberToHrtime(time);
        }
    }
    else if (time instanceof Date) {
        return esm_common_time_numberToHrtime(time.getTime());
    }
    else {
        throw TypeError('Invalid input type');
    }
}
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */
function esm_common_time_hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += esm_common_time_SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
}
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */
function esm_common_time_hrTimeToTimeStamp(time) {
    var precision = esm_common_time_NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substr(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */
function build_esm_common_time_hrTimeToNanoseconds(time) {
    return time[0] * esm_common_time_SECOND_TO_NANOSECONDS + time[1];
}
/**
 * Convert hrTime to milliseconds.
 * @param time
 */
function esm_common_time_hrTimeToMilliseconds(time) {
    return Math.round(time[0] * 1e3 + time[1] / 1e6);
}
/**
 * Convert hrTime to microseconds.
 * @param time
 */
function esm_common_time_hrTimeToMicroseconds(time) {
    return Math.round(time[0] * 1e6 + time[1] / 1e3);
}
/**
 * check if time is HrTime
 * @param value
 */
function esm_common_time_isTimeInputHrTime(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        typeof value[0] === 'number' &&
        typeof value[1] === 'number');
}
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */
function esm_common_time_isTimeInput(value) {
    return (esm_common_time_isTimeInputHrTime(value) ||
        typeof value === 'number' ||
        value instanceof Date);
}
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/ExportResult.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var build_esm_ExportResult_ExportResultCode;
(function (ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(build_esm_ExportResult_ExportResultCode || (build_esm_ExportResult_ExportResultCode = {}));
//# sourceMappingURL=ExportResult.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/propagation/composite.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var build_esm_propagation_composite_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

/** Combines multiple propagators into a single propagator. */
var esm_propagation_composite_CompositePropagator = /** @class */ (function () {
    /**
     * Construct a composite propagator from a list of propagators.
     *
     * @param [config] Configuration object for composite propagator
     */
    function CompositePropagator(config) {
        if (config === void 0) { config = {}; }
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators
            // older propagators may not have fields function, null check to be sure
            .map(function (p) { return (typeof p.fields === 'function' ? p.fields() : []); })
            .reduce(function (x, y) { return x.concat(y); }, [])));
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same carrier key, the propagator later in the list
     * will "win".
     *
     * @param context Context to inject
     * @param carrier Carrier into which context will be injected
     */
    CompositePropagator.prototype.inject = function (context, carrier, setter) {
        var e_1, _a;
        try {
            for (var _b = build_esm_propagation_composite_values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propagator = _c.value;
                try {
                    propagator.inject(context, carrier, setter);
                }
                catch (err) {
                    esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same context key, the propagator later in the list
     * will "win".
     *
     * @param context Context to add values to
     * @param carrier Carrier from which to extract context
     */
    CompositePropagator.prototype.extract = function (context, carrier, getter) {
        return this._propagators.reduce(function (ctx, propagator) {
            try {
                return propagator.extract(ctx, carrier, getter);
            }
            catch (err) {
                esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
            return ctx;
        }, context);
    };
    CompositePropagator.prototype.fields = function () {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
    };
    return CompositePropagator;
}());

//# sourceMappingURL=composite.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/internal/validators.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var build_esm_internal_validators_VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var build_esm_internal_validators_VALID_KEY = "[a-z]" + build_esm_internal_validators_VALID_KEY_CHAR_RANGE + "{0,255}";
var build_esm_internal_validators_VALID_VENDOR_KEY = "[a-z0-9]" + build_esm_internal_validators_VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + build_esm_internal_validators_VALID_KEY_CHAR_RANGE + "{0,13}";
var build_esm_internal_validators_VALID_KEY_REGEX = new RegExp("^(?:" + build_esm_internal_validators_VALID_KEY + "|" + build_esm_internal_validators_VALID_VENDOR_KEY + ")$");
var build_esm_internal_validators_VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var build_esm_internal_validators_INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */
function build_esm_internal_validators_validateKey(key) {
    return build_esm_internal_validators_VALID_KEY_REGEX.test(key);
}
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */
function build_esm_internal_validators_validateValue(value) {
    return (build_esm_internal_validators_VALID_VALUE_BASE_REGEX.test(value) &&
        !build_esm_internal_validators_INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));
}
//# sourceMappingURL=validators.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/trace/TraceState.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var build_esm_trace_TraceState_MAX_TRACE_STATE_ITEMS = 32;
var build_esm_trace_TraceState_MAX_TRACE_STATE_LEN = 512;
var build_esm_trace_TraceState_LIST_MEMBERS_SEPARATOR = ',';
var build_esm_trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */
var esm_trace_TraceState_TraceState = /** @class */ (function () {
    function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState)
            this._parse(rawTraceState);
    }
    TraceState.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
            traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceState.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceState.prototype.get = function (key) {
        return this._internalState.get(key);
    };
    TraceState.prototype.serialize = function () {
        var _this = this;
        return this._keys()
            .reduce(function (agg, key) {
            agg.push(key + build_esm_trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, [])
            .join(build_esm_trace_TraceState_LIST_MEMBERS_SEPARATOR);
    };
    TraceState.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > build_esm_trace_TraceState_MAX_TRACE_STATE_LEN)
            return;
        this._internalState = rawTraceState
            .split(build_esm_trace_TraceState_LIST_MEMBERS_SEPARATOR)
            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
            .reduce(function (agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(build_esm_trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if (build_esm_internal_validators_validateKey(key) && build_esm_internal_validators_validateValue(value)) {
                    agg.set(key, value);
                }
                else {
                    // TODO: Consider to add warning log
                }
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > build_esm_trace_TraceState_MAX_TRACE_STATE_ITEMS) {
            this._internalState = new Map(Array.from(this._internalState.entries())
                .reverse() // Use reverse same as original tracestate parse chain
                .slice(0, build_esm_trace_TraceState_MAX_TRACE_STATE_ITEMS));
        }
    };
    TraceState.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceState.prototype._clone = function () {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceState;
}());

//# sourceMappingURL=TraceState.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var esm_trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER = 'traceparent';
var esm_trace_W3CTraceContextPropagator_TRACE_STATE_HEADER = 'tracestate';
var build_esm_trace_W3CTraceContextPropagator_VERSION = '00';
var esm_trace_W3CTraceContextPropagator_VERSION_PART = '(?!ff)[\\da-f]{2}';
var esm_trace_W3CTraceContextPropagator_TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
var esm_trace_W3CTraceContextPropagator_PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
var esm_trace_W3CTraceContextPropagator_FLAGS_PART = '[\\da-f]{2}';
var esm_trace_W3CTraceContextPropagator_TRACE_PARENT_REGEX = new RegExp("^\\s?(" + esm_trace_W3CTraceContextPropagator_VERSION_PART + ")-(" + esm_trace_W3CTraceContextPropagator_TRACE_ID_PART + ")-(" + esm_trace_W3CTraceContextPropagator_PARENT_ID_PART + ")-(" + esm_trace_W3CTraceContextPropagator_FLAGS_PART + ")(-.*)?\\s?$");
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */
function esm_trace_W3CTraceContextPropagator_parseTraceParent(traceParent) {
    var match = esm_trace_W3CTraceContextPropagator_TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
        return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5])
        return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16),
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */
var esm_trace_W3CTraceContextPropagator_W3CTraceContextPropagator = /** @class */ (function () {
    function W3CTraceContextPropagator() {
    }
    W3CTraceContextPropagator.prototype.inject = function (context, carrier, setter) {
        var spanContext = trace.getSpanContext(context);
        if (!spanContext ||
            esm_trace_suppress_tracing_isTracingSuppressed(context) ||
            !isSpanContextValid(spanContext))
            return;
        var traceParent = build_esm_trace_W3CTraceContextPropagator_VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, esm_trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
            setter.set(carrier, esm_trace_W3CTraceContextPropagator_TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
    };
    W3CTraceContextPropagator.prototype.extract = function (context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, esm_trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER);
        if (!traceParentHeader)
            return context;
        var traceParent = Array.isArray(traceParentHeader)
            ? traceParentHeader[0]
            : traceParentHeader;
        if (typeof traceParent !== 'string')
            return context;
        var spanContext = esm_trace_W3CTraceContextPropagator_parseTraceParent(traceParent);
        if (!spanContext)
            return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, esm_trace_W3CTraceContextPropagator_TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            var state = Array.isArray(traceStateHeader)
                ? traceStateHeader.join(',')
                : traceStateHeader;
            spanContext.traceState = new esm_trace_TraceState_TraceState(typeof state === 'string' ? state : undefined);
        }
        return trace.setSpanContext(context, spanContext);
    };
    W3CTraceContextPropagator.prototype.fields = function () {
        return [esm_trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER, esm_trace_W3CTraceContextPropagator_TRACE_STATE_HEADER];
    };
    return W3CTraceContextPropagator;
}());

//# sourceMappingURL=W3CTraceContextPropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var trace_rpc_metadata_RPC_METADATA_KEY = createContextKey('OpenTelemetry SDK Context Key RPC_METADATA');
var trace_rpc_metadata_RPCType;
(function (RPCType) {
    RPCType["HTTP"] = "http";
})(trace_rpc_metadata_RPCType || (trace_rpc_metadata_RPCType = {}));
function trace_rpc_metadata_setRPCMetadata(context, meta) {
    return context.setValue(trace_rpc_metadata_RPC_METADATA_KEY, meta);
}
function trace_rpc_metadata_deleteRPCMetadata(context) {
    return context.deleteValue(trace_rpc_metadata_RPC_METADATA_KEY);
}
function trace_rpc_metadata_getRPCMetadata(context) {
    return context.getValue(trace_rpc_metadata_RPC_METADATA_KEY);
}
//# sourceMappingURL=rpc-metadata.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples no traces.
 */
var trace_sampler_AlwaysOffSampler_AlwaysOffSampler = /** @class */ (function () {
    function AlwaysOffSampler() {
    }
    AlwaysOffSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.NOT_RECORD,
        };
    };
    AlwaysOffSampler.prototype.toString = function () {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}());

//# sourceMappingURL=AlwaysOffSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples all traces.
 */
var trace_sampler_AlwaysOnSampler_AlwaysOnSampler = /** @class */ (function () {
    function AlwaysOnSampler() {
    }
    AlwaysOnSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.RECORD_AND_SAMPLED,
        };
    };
    AlwaysOnSampler.prototype.toString = function () {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}());

//# sourceMappingURL=AlwaysOnSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */
var trace_sampler_ParentBasedSampler_ParentBasedSampler = /** @class */ (function () {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            esm_common_global_error_handler_globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new trace_sampler_AlwaysOnSampler_AlwaysOnSampler();
        }
        this._remoteParentSampled =
            (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new trace_sampler_AlwaysOnSampler_AlwaysOnSampler();
        this._remoteParentNotSampled =
            (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new trace_sampler_AlwaysOffSampler_AlwaysOffSampler();
        this._localParentSampled =
            (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new trace_sampler_AlwaysOnSampler_AlwaysOnSampler();
        this._localParentNotSampled =
            (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new trace_sampler_AlwaysOffSampler_AlwaysOffSampler();
    }
    ParentBasedSampler.prototype.shouldSample = function (context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
            return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & TraceFlags.SAMPLED) {
                return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            }
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function () {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}());

//# sourceMappingURL=ParentBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples a given fraction of traces based of trace id deterministically.
 */
var trace_sampler_TraceIdRatioBasedSampler_TraceIdRatioBasedSampler = /** @class */ (function () {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) { _ratio = 0; }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function (context, traceId) {
        return {
            decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound
                ? SamplingDecision.RECORD_AND_SAMPLED
                : SamplingDecision.NOT_RECORD,
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function () {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function (ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio))
            return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function (traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}());

//# sourceMappingURL=TraceIdRatioBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * based on lodash in order to support esm builds without esModuleInterop.
 * lodash is using MIT License.
 **/
var esm_utils_lodash_merge_objectTag = '[object Object]';
var esm_utils_lodash_merge_nullTag = '[object Null]';
var esm_utils_lodash_merge_undefinedTag = '[object Undefined]';
var esm_utils_lodash_merge_funcProto = Function.prototype;
var esm_utils_lodash_merge_funcToString = esm_utils_lodash_merge_funcProto.toString;
var esm_utils_lodash_merge_objectCtorString = esm_utils_lodash_merge_funcToString.call(Object);
var esm_utils_lodash_merge_getPrototype = esm_utils_lodash_merge_overArg(Object.getPrototypeOf, Object);
var esm_utils_lodash_merge_objectProto = Object.prototype;
var build_esm_utils_lodash_merge_hasOwnProperty = esm_utils_lodash_merge_objectProto.hasOwnProperty;
var esm_utils_lodash_merge_symToStringTag = Symbol ? Symbol.toStringTag : undefined;
var esm_utils_lodash_merge_nativeObjectToString = esm_utils_lodash_merge_objectProto.toString;
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function esm_utils_lodash_merge_overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function build_esm_utils_lodash_merge_isPlainObject(value) {
    if (!esm_utils_lodash_merge_isObjectLike(value) || esm_utils_lodash_merge_baseGetTag(value) !== esm_utils_lodash_merge_objectTag) {
        return false;
    }
    var proto = esm_utils_lodash_merge_getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = build_esm_utils_lodash_merge_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        esm_utils_lodash_merge_funcToString.call(Ctor) === esm_utils_lodash_merge_objectCtorString;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function esm_utils_lodash_merge_isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function esm_utils_lodash_merge_baseGetTag(value) {
    if (value == null) {
        return value === undefined ? esm_utils_lodash_merge_undefinedTag : esm_utils_lodash_merge_nullTag;
    }
    return (esm_utils_lodash_merge_symToStringTag && esm_utils_lodash_merge_symToStringTag in Object(value))
        ? esm_utils_lodash_merge_getRawTag(value)
        : esm_utils_lodash_merge_objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function esm_utils_lodash_merge_getRawTag(value) {
    var isOwn = build_esm_utils_lodash_merge_hasOwnProperty.call(value, esm_utils_lodash_merge_symToStringTag), tag = value[esm_utils_lodash_merge_symToStringTag];
    var unmasked = false;
    try {
        value[esm_utils_lodash_merge_symToStringTag] = undefined;
        unmasked = true;
    }
    catch (e) {
        // silence
    }
    var result = esm_utils_lodash_merge_nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[esm_utils_lodash_merge_symToStringTag] = tag;
        }
        else {
            delete value[esm_utils_lodash_merge_symToStringTag];
        }
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function esm_utils_lodash_merge_objectToString(value) {
    return esm_utils_lodash_merge_nativeObjectToString.call(value);
}
//# sourceMappingURL=lodash.merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/utils/merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */

var esm_utils_merge_MAX_LEVEL = 20;
/**
 * Merges objects together
 * @param args - objects / values to be merged
 */
function esm_utils_merge_merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var result = args.shift();
    var objects = new WeakMap();
    while (args.length > 0) {
        result = esm_utils_merge_mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
}
function esm_utils_merge_takeValue(value) {
    if (esm_utils_merge_isArray(value)) {
        return value.slice();
    }
    return value;
}
/**
 * Merges two objects
 * @param one - first object
 * @param two - second object
 * @param level - current deep level
 * @param objects - objects holder that has been already referenced - to prevent
 * cyclic dependency
 */
function esm_utils_merge_mergeTwoObjects(one, two, level, objects) {
    if (level === void 0) { level = 0; }
    var result;
    if (level > esm_utils_merge_MAX_LEVEL) {
        return undefined;
    }
    level++;
    if (esm_utils_merge_isPrimitive(one) || esm_utils_merge_isPrimitive(two) || esm_utils_merge_isFunction(two)) {
        result = esm_utils_merge_takeValue(two);
    }
    else if (esm_utils_merge_isArray(one)) {
        result = one.slice();
        if (esm_utils_merge_isArray(two)) {
            for (var i = 0, j = two.length; i < j; i++) {
                result.push(esm_utils_merge_takeValue(two[i]));
            }
        }
        else if (esm_utils_merge_isObject(two)) {
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                result[key] = esm_utils_merge_takeValue(two[key]);
            }
        }
    }
    else if (esm_utils_merge_isObject(one)) {
        if (esm_utils_merge_isObject(two)) {
            if (!esm_utils_merge_shouldMerge(one, two)) {
                return two;
            }
            result = Object.assign({}, one);
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                var twoValue = two[key];
                if (esm_utils_merge_isPrimitive(twoValue)) {
                    if (typeof twoValue === 'undefined') {
                        delete result[key];
                    }
                    else {
                        // result[key] = takeValue(twoValue);
                        result[key] = twoValue;
                    }
                }
                else {
                    var obj1 = result[key];
                    var obj2 = twoValue;
                    if (esm_utils_merge_wasObjectReferenced(one, key, objects) ||
                        esm_utils_merge_wasObjectReferenced(two, key, objects)) {
                        delete result[key];
                    }
                    else {
                        if (esm_utils_merge_isObject(obj1) && esm_utils_merge_isObject(obj2)) {
                            var arr1 = objects.get(obj1) || [];
                            var arr2 = objects.get(obj2) || [];
                            arr1.push({ obj: one, key: key });
                            arr2.push({ obj: two, key: key });
                            objects.set(obj1, arr1);
                            objects.set(obj2, arr2);
                        }
                        result[key] = esm_utils_merge_mergeTwoObjects(result[key], twoValue, level, objects);
                    }
                }
            }
        }
        else {
            result = two;
        }
    }
    return result;
}
/**
 * Function to check if object has been already reference
 * @param obj
 * @param key
 * @param objects
 */
function esm_utils_merge_wasObjectReferenced(obj, key, objects) {
    var arr = objects.get(obj[key]) || [];
    for (var i = 0, j = arr.length; i < j; i++) {
        var info = arr[i];
        if (info.key === key && info.obj === obj) {
            return true;
        }
    }
    return false;
}
function esm_utils_merge_isArray(value) {
    return Array.isArray(value);
}
function esm_utils_merge_isFunction(value) {
    return typeof value === 'function';
}
function esm_utils_merge_isObject(value) {
    return !esm_utils_merge_isPrimitive(value) && !esm_utils_merge_isArray(value) && !esm_utils_merge_isFunction(value) && typeof value === 'object';
}
function esm_utils_merge_isPrimitive(value) {
    return typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean' ||
        typeof value === 'undefined' ||
        value instanceof Date ||
        value instanceof RegExp ||
        value === null;
}
function esm_utils_merge_shouldMerge(one, two) {
    if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
    }
    return true;
}
//# sourceMappingURL=merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/utils/url.js
var esm_utils_url_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function utils_url_urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === 'string') {
        return url === urlToMatch;
    }
    else {
        return !!url.match(urlToMatch);
    }
}
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */
function utils_url_isUrlIgnored(url, ignoredUrls) {
    var e_1, _a;
    if (!ignoredUrls) {
        return false;
    }
    try {
        for (var ignoredUrls_1 = esm_utils_url_values(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
            var ignoreUrl = ignoredUrls_1_1.value;
            if (utils_url_urlMatches(url, ignoreUrl)) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return)) _a.call(ignoredUrls_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}
//# sourceMappingURL=url.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/utils/promise.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var build_esm_utils_promise_Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function (val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function (err) {
        this._reject(err);
    };
    return Deferred;
}());

//# sourceMappingURL=promise.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/utils/callback.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var build_esm_utils_callback_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var build_esm_utils_callback_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */
var esm_utils_callback_BindOnceFuture = /** @class */ (function () {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new build_esm_utils_promise_Deferred();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function () {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function () {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, build_esm_utils_callback_spreadArray([this._that], build_esm_utils_callback_read(args), false)))
                    .then(function (val) { return _this._deferred.resolve(val); }, function (err) { return _this._deferred.reject(err); });
            }
            catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}());

//# sourceMappingURL=callback.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





























//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/build/esm/trace/internal.js



function sdkSpanToOtlpSpan(span, useHex) {
    var ctx = span.spanContext();
    var status = span.status;
    var parentSpanId = useHex ? span.parentSpanId : span.parentSpanId != null ? hexToBase64(span.parentSpanId) : undefined;
    return {
        traceId: useHex ? ctx.traceId : hexToBase64(ctx.traceId),
        spanId: useHex ? ctx.spanId : hexToBase64(ctx.spanId),
        parentSpanId: parentSpanId,
        name: span.name,
        // Span kind is offset by 1 because the API does not define a value for unset
        kind: span.kind == null ? 0 : span.kind + 1,
        startTimeUnixNano: build_esm_common_time_hrTimeToNanoseconds(span.startTime),
        endTimeUnixNano: build_esm_common_time_hrTimeToNanoseconds(span.endTime),
        attributes: internal_toAttributes(span.attributes),
        droppedAttributesCount: 0,
        events: span.events.map(toOtlpSpanEvent),
        droppedEventsCount: 0,
        status: {
            // API and proto enums share the same values
            code: status.code,
            message: status.message,
        },
        links: span.links.map(function (link) { return toOtlpLink(link, useHex); }),
        droppedLinksCount: 0,
    };
}
function toOtlpLink(link, useHex) {
    return {
        attributes: link.attributes ? internal_toAttributes(link.attributes) : [],
        spanId: useHex ? link.context.spanId : hexToBase64(link.context.spanId),
        traceId: useHex ? link.context.traceId : hexToBase64(link.context.traceId),
        droppedAttributesCount: 0,
    };
}
function toOtlpSpanEvent(timedEvent) {
    return {
        attributes: timedEvent.attributes ? internal_toAttributes(timedEvent.attributes) : [],
        name: timedEvent.name,
        timeUnixNano: build_esm_common_time_hrTimeToNanoseconds(timedEvent.time),
        droppedAttributesCount: 0,
    };
}
//# sourceMappingURL=internal.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/build/esm/trace/index.js
var trace_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var trace_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};


function createExportTraceServiceRequest(spans, useHex) {
    return {
        resourceSpans: spanRecordsToResourceSpans(spans, useHex)
    };
}
function createResourceMap(readableSpans) {
    var e_1, _a;
    var resourceMap = new Map();
    try {
        for (var readableSpans_1 = trace_values(readableSpans), readableSpans_1_1 = readableSpans_1.next(); !readableSpans_1_1.done; readableSpans_1_1 = readableSpans_1.next()) {
            var record = readableSpans_1_1.value;
            var ilmMap = resourceMap.get(record.resource);
            if (!ilmMap) {
                ilmMap = new Map();
                resourceMap.set(record.resource, ilmMap);
            }
            // TODO this is duplicated in basic tracer. Consolidate on a common helper in core
            var instrumentationLibraryKey = record.instrumentationLibrary.name + "@" + (record.instrumentationLibrary.version || '') + ":" + (record.instrumentationLibrary.schemaUrl || '');
            var records = ilmMap.get(instrumentationLibraryKey);
            if (!records) {
                records = [];
                ilmMap.set(instrumentationLibraryKey, records);
            }
            records.push(record);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (readableSpans_1_1 && !readableSpans_1_1.done && (_a = readableSpans_1.return)) _a.call(readableSpans_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return resourceMap;
}
function spanRecordsToResourceSpans(readableSpans, useHex) {
    var resourceMap = createResourceMap(readableSpans);
    var out = [];
    var entryIterator = resourceMap.entries();
    var entry = entryIterator.next();
    while (!entry.done) {
        var _a = trace_read(entry.value, 2), resource = _a[0], ilmMap = _a[1];
        var scopeResourceSpans = [];
        var ilmIterator = ilmMap.values();
        var ilmEntry = ilmIterator.next();
        while (!ilmEntry.done) {
            var scopeSpans = ilmEntry.value;
            if (scopeSpans.length > 0) {
                var _b = scopeSpans[0].instrumentationLibrary, name_1 = _b.name, version = _b.version, schemaUrl = _b.schemaUrl;
                var spans = scopeSpans.map(function (readableSpan) { return sdkSpanToOtlpSpan(readableSpan, useHex); });
                scopeResourceSpans.push({
                    scope: { name: name_1, version: version },
                    spans: spans,
                    schemaUrl: schemaUrl
                });
            }
            ilmEntry = ilmIterator.next();
        }
        // TODO SDK types don't provide resource schema URL at this time
        var transformedSpans = {
            resource: {
                attributes: internal_toAttributes(resource.attributes),
                droppedAttributesCount: 0,
            },
            scopeSpans: scopeResourceSpans,
            schemaUrl: undefined
        };
        out.push(transformedSpans);
        entry = entryIterator.next();
    }
    return out;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api-metrics/build/esm/NoopMeter.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NoopMeter_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
 * constant NoopMetrics for all of its methods.
 */
var NoopMeter = /** @class */ (function () {
    function NoopMeter() {
    }
    /**
     * @see {@link Meter.createHistogram}
     */
    NoopMeter.prototype.createHistogram = function (_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
    };
    /**
     * @see {@link Meter.createCounter}
     */
    NoopMeter.prototype.createCounter = function (_name, _options) {
        return NOOP_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createUpDownCounter}
     */
    NoopMeter.prototype.createUpDownCounter = function (_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableGauge}
     */
    NoopMeter.prototype.createObservableGauge = function (_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    /**
     * @see {@link Meter.createObservableCounter}
     */
    NoopMeter.prototype.createObservableCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableUpDownCounter}
     */
    NoopMeter.prototype.createObservableUpDownCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.addBatchObservableCallback}
     */
    NoopMeter.prototype.addBatchObservableCallback = function (_callback, _observables) { };
    /**
     * @see {@link Meter.removeBatchObservableCallback}
     */
    NoopMeter.prototype.removeBatchObservableCallback = function (_callback) { };
    return NoopMeter;
}());

var NoopMetric = /** @class */ (function () {
    function NoopMetric() {
    }
    return NoopMetric;
}());

var NoopCounterMetric = /** @class */ (function (_super) {
    NoopMeter_extends(NoopCounterMetric, _super);
    function NoopCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric.prototype.add = function (_value, _attributes) { };
    return NoopCounterMetric;
}(NoopMetric));

var NoopUpDownCounterMetric = /** @class */ (function (_super) {
    NoopMeter_extends(NoopUpDownCounterMetric, _super);
    function NoopUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopUpDownCounterMetric.prototype.add = function (_value, _attributes) { };
    return NoopUpDownCounterMetric;
}(NoopMetric));

var NoopHistogramMetric = /** @class */ (function (_super) {
    NoopMeter_extends(NoopHistogramMetric, _super);
    function NoopHistogramMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopHistogramMetric.prototype.record = function (_value, _attributes) { };
    return NoopHistogramMetric;
}(NoopMetric));

var NoopObservableMetric = /** @class */ (function () {
    function NoopObservableMetric() {
    }
    NoopObservableMetric.prototype.addCallback = function (_callback) { };
    NoopObservableMetric.prototype.removeCallback = function (_callback) { };
    return NoopObservableMetric;
}());

var NoopObservableCounterMetric = /** @class */ (function (_super) {
    NoopMeter_extends(NoopObservableCounterMetric, _super);
    function NoopObservableCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableCounterMetric;
}(NoopObservableMetric));

var NoopObservableGaugeMetric = /** @class */ (function (_super) {
    NoopMeter_extends(NoopObservableGaugeMetric, _super);
    function NoopObservableGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableGaugeMetric;
}(NoopObservableMetric));

var NoopObservableUpDownCounterMetric = /** @class */ (function (_super) {
    NoopMeter_extends(NoopObservableUpDownCounterMetric, _super);
    function NoopObservableUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableUpDownCounterMetric;
}(NoopObservableMetric));

var NOOP_METER = new NoopMeter();
// Synchronous instruments
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
// Asynchronous instruments
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
/**
 * Create a no-op Meter
 */
function createNoopMeter() {
    return NOOP_METER;
}
//# sourceMappingURL=NoopMeter.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api-metrics/build/esm/types/Metric.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The Type of value. It describes how the data is reported. */
var Metric_ValueType;
(function (ValueType) {
    ValueType[ValueType["INT"] = 0] = "INT";
    ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
})(Metric_ValueType || (Metric_ValueType = {}));
//# sourceMappingURL=Metric.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api-metrics/build/esm/NoopMeterProvider.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An implementation of the {@link MeterProvider} which returns an impotent Meter
 * for all calls to `getMeter`
 */
var NoopMeterProvider = /** @class */ (function () {
    function NoopMeterProvider() {
    }
    NoopMeterProvider.prototype.getMeter = function (_name, _version, _options) {
        return NOOP_METER;
    };
    return NoopMeterProvider;
}());

var NOOP_METER_PROVIDER = new NoopMeterProvider();
//# sourceMappingURL=NoopMeterProvider.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api-metrics/build/esm/platform/browser/globalThis.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/core too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var api_metrics_build_esm_platform_browser_globalThis_globalThis = typeof globalThis === 'object' ? globalThis :
    typeof self === 'object' ? self :
        typeof window === 'object' ? window :
            typeof __webpack_require__.g === 'object' ? __webpack_require__.g :
                {};
//# sourceMappingURL=globalThis.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api-metrics/build/esm/platform/browser/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api-metrics/build/esm/api/global-utils.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var GLOBAL_METRICS_API_KEY = Symbol.for('io.opentelemetry.js.api.metrics');
var global_utils_global = api_metrics_build_esm_platform_browser_globalThis_globalThis;
/**
 * Make a function which accepts a version integer and returns the instance of an API if the version
 * is compatible, or a fallback version (usually NOOP) if it is not.
 *
 * @param requiredVersion Backwards compatibility version which is required to return the instance
 * @param instance Instance which should be returned if the required version is compatible
 * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
 */
function makeGetter(requiredVersion, instance, fallback) {
    return function (version) {
        return version === requiredVersion ? instance : fallback;
    };
}
/**
 * A number which should be incremented each time a backwards incompatible
 * change is made to the API. This number is used when an API package
 * attempts to access the global API to ensure it is getting a compatible
 * version. If the global API is not compatible with the API package
 * attempting to get it, a NOOP API implementation will be returned.
 */
var API_BACKWARDS_COMPATIBILITY_VERSION = 4;
//# sourceMappingURL=global-utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api-metrics/build/esm/api/metrics.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
 */
var MetricsAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function MetricsAPI() {
    }
    /** Get the singleton instance of the Metrics API */
    MetricsAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new MetricsAPI();
        }
        return this._instance;
    };
    /**
     * Set the current global meter. Returns the initialized global meter provider.
     */
    MetricsAPI.prototype.setGlobalMeterProvider = function (provider) {
        if (global_utils_global[GLOBAL_METRICS_API_KEY]) {
            // global meter provider has already been set
            return this.getMeterProvider();
        }
        global_utils_global[GLOBAL_METRICS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_METER_PROVIDER);
        return provider;
    };
    /**
     * Returns the global meter provider.
     */
    MetricsAPI.prototype.getMeterProvider = function () {
        var _a, _b;
        return ((_b = (_a = global_utils_global[GLOBAL_METRICS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_global, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_METER_PROVIDER);
    };
    /**
     * Returns a meter from the global meter provider.
     */
    MetricsAPI.prototype.getMeter = function (name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
    };
    /** Remove the global meter provider */
    MetricsAPI.prototype.disable = function () {
        delete global_utils_global[GLOBAL_METRICS_API_KEY];
    };
    return MetricsAPI;
}());

//# sourceMappingURL=metrics.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/api-metrics/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/** Entrypoint for metrics API */
var metrics = MetricsAPI.getInstance();
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/export/AggregationTemporality.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * AggregationTemporality indicates the way additive quantities are expressed.
 */
var AggregationTemporality_AggregationTemporality;
(function (AggregationTemporality) {
    AggregationTemporality[AggregationTemporality["DELTA"] = 0] = "DELTA";
    AggregationTemporality[AggregationTemporality["CUMULATIVE"] = 1] = "CUMULATIVE";
})(AggregationTemporality_AggregationTemporality || (AggregationTemporality_AggregationTemporality = {}));
//# sourceMappingURL=AggregationTemporality.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/export/MetricData.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The aggregated point data type.
 */
var MetricData_DataPointType;
(function (DataPointType) {
    /**
     * A histogram data point contains a histogram statistics of collected
     * values with a list of explicit bucket boundaries and statistics such
     * as min, max, count, and sum of all collected values.
     */
    DataPointType[DataPointType["HISTOGRAM"] = 0] = "HISTOGRAM";
    /**
     * An exponential histogram data point contains a histogram statistics of
     * collected values where bucket boundaries are automatically calculated
     * using an exponential function, and statistics such as min, max, count,
     * and sum of all collected values.
     */
    DataPointType[DataPointType["EXPONENTIAL_HISTOGRAM"] = 1] = "EXPONENTIAL_HISTOGRAM";
    /**
     * A gauge metric data point has only a single numeric value.
     */
    DataPointType[DataPointType["GAUGE"] = 2] = "GAUGE";
    /**
     * A sum metric data point has a single numeric value and a
     * monotonicity-indicator.
     */
    DataPointType[DataPointType["SUM"] = 3] = "SUM";
})(MetricData_DataPointType || (MetricData_DataPointType = {}));
//# sourceMappingURL=MetricData.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/utils.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var utils_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var utils_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var utils_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var esm_utils_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var utils_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var utils_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function isNotNullish(item) {
    return item !== undefined && item !== null;
}
/**
 * Converting the unordered attributes into unique identifier string.
 * @param attributes user provided unordered MetricAttributes.
 */
function hashAttributes(attributes) {
    var keys = Object.keys(attributes);
    if (keys.length === 0)
        return '';
    // Return a string that is stable on key orders.
    keys = keys.sort();
    return JSON.stringify(keys.map(function (key) { return [key, attributes[key]]; }));
}
/**
 * Converting the instrumentation scope object to a unique identifier string.
 * @param instrumentationScope
 */
function instrumentationScopeId(instrumentationScope) {
    var _a, _b;
    return instrumentationScope.name + ":" + ((_a = instrumentationScope.version) !== null && _a !== void 0 ? _a : '') + ":" + ((_b = instrumentationScope.schemaUrl) !== null && _b !== void 0 ? _b : '');
}
/**
 * Error that is thrown on timeouts.
 */
var TimeoutError = /** @class */ (function (_super) {
    utils_extends(TimeoutError, _super);
    function TimeoutError(message) {
        var _this = _super.call(this, message) || this;
        // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:
        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
    }
    return TimeoutError;
}(Error));

/**
 * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise
 * rejects, and resolves if the specified promise resolves.
 *
 * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.
 *
 * @param promise promise to use with timeout.
 * @param timeout the timeout in milliseconds until the returned promise is rejected.
 */
function callWithTimeout(promise, timeout) {
    var timeoutHandle;
    var timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
            reject(new TimeoutError('Operation timed out.'));
        }, timeout);
    });
    return Promise.race([promise, timeoutPromise]).then(function (result) {
        clearTimeout(timeoutHandle);
        return result;
    }, function (reason) {
        clearTimeout(timeoutHandle);
        throw reason;
    });
}
/**
 * Node.js v12.9 lower and browser compatible `Promise.allSettled`.
 */
function PromiseAllSettled(promises) {
    return utils_awaiter(this, void 0, void 0, function () {
        var _this = this;
        return utils_generator(this, function (_a) {
            return [2 /*return*/, Promise.all(promises.map(function (p) { return utils_awaiter(_this, void 0, void 0, function () {
                    var ret, e_1;
                    return utils_generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, p];
                            case 1:
                                ret = _a.sent();
                                return [2 /*return*/, {
                                        status: 'fulfilled',
                                        value: ret,
                                    }];
                            case 2:
                                e_1 = _a.sent();
                                return [2 /*return*/, {
                                        status: 'rejected',
                                        reason: e_1,
                                    }];
                            case 3: return [2 /*return*/];
                        }
                    });
                }); }))];
        });
    });
}
function isPromiseAllSettledRejectionResult(it) {
    return it.status === 'rejected';
}
/**
 * Node.js v11.0 lower and browser compatible `Array.prototype.flatMap`.
 */
function FlatMap(arr, fn) {
    var result = [];
    arr.forEach(function (it) {
        result.push.apply(result, utils_spreadArray([], esm_utils_read(fn(it)), false));
    });
    return result;
}
function setEquals(lhs, rhs) {
    var e_2, _a;
    if (lhs.size !== rhs.size) {
        return false;
    }
    try {
        for (var lhs_1 = utils_values(lhs), lhs_1_1 = lhs_1.next(); !lhs_1_1.done; lhs_1_1 = lhs_1.next()) {
            var item = lhs_1_1.value;
            if (!rhs.has(item)) {
                return false;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (lhs_1_1 && !lhs_1_1.done && (_a = lhs_1.return)) _a.call(lhs_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return true;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/types.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The kind of aggregator. */
var AggregatorKind;
(function (AggregatorKind) {
    AggregatorKind[AggregatorKind["DROP"] = 0] = "DROP";
    AggregatorKind[AggregatorKind["SUM"] = 1] = "SUM";
    AggregatorKind[AggregatorKind["LAST_VALUE"] = 2] = "LAST_VALUE";
    AggregatorKind[AggregatorKind["HISTOGRAM"] = 3] = "HISTOGRAM";
})(AggregatorKind || (AggregatorKind = {}));
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/Drop.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Basic aggregator for None which keeps no recorded value. */
var DropAggregator = /** @class */ (function () {
    function DropAggregator() {
        this.kind = AggregatorKind.DROP;
    }
    DropAggregator.prototype.createAccumulation = function () {
        return undefined;
    };
    DropAggregator.prototype.merge = function (_previous, _delta) {
        return undefined;
    };
    DropAggregator.prototype.diff = function (_previous, _current) {
        return undefined;
    };
    DropAggregator.prototype.toMetricData = function (_descriptor, _aggregationTemporality, _accumulationByAttributes, _endTime) {
        return undefined;
    };
    return DropAggregator;
}());

//# sourceMappingURL=Drop.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/InstrumentDescriptor.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Supported types of metric instruments.
 */
var InstrumentType;
(function (InstrumentType) {
    InstrumentType["COUNTER"] = "COUNTER";
    InstrumentType["HISTOGRAM"] = "HISTOGRAM";
    InstrumentType["UP_DOWN_COUNTER"] = "UP_DOWN_COUNTER";
    InstrumentType["OBSERVABLE_COUNTER"] = "OBSERVABLE_COUNTER";
    InstrumentType["OBSERVABLE_GAUGE"] = "OBSERVABLE_GAUGE";
    InstrumentType["OBSERVABLE_UP_DOWN_COUNTER"] = "OBSERVABLE_UP_DOWN_COUNTER";
})(InstrumentType || (InstrumentType = {}));
function createInstrumentDescriptor(name, type, options) {
    var _a, _b, _c;
    return {
        name: name,
        type: type,
        description: (_a = options === null || options === void 0 ? void 0 : options.description) !== null && _a !== void 0 ? _a : '',
        unit: (_b = options === null || options === void 0 ? void 0 : options.unit) !== null && _b !== void 0 ? _b : '',
        valueType: (_c = options === null || options === void 0 ? void 0 : options.valueType) !== null && _c !== void 0 ? _c : Metric_ValueType.DOUBLE,
    };
}
function createInstrumentDescriptorWithView(view, instrument) {
    var _a, _b;
    return {
        name: (_a = view.name) !== null && _a !== void 0 ? _a : instrument.name,
        description: (_b = view.description) !== null && _b !== void 0 ? _b : instrument.description,
        type: instrument.type,
        unit: instrument.unit,
        valueType: instrument.valueType,
    };
}
function isDescriptorCompatibleWith(descriptor, otherDescriptor) {
    return descriptor.name === otherDescriptor.name
        && descriptor.unit === otherDescriptor.unit
        && descriptor.type === otherDescriptor.type
        && descriptor.valueType === otherDescriptor.valueType;
}
//# sourceMappingURL=InstrumentDescriptor.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/Histogram.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Histogram_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};



function createNewEmptyCheckpoint(boundaries) {
    var counts = boundaries.map(function () { return 0; });
    counts.push(0);
    return {
        buckets: {
            boundaries: boundaries,
            counts: counts,
        },
        sum: 0,
        count: 0,
        hasMinMax: false,
        min: Infinity,
        max: -Infinity
    };
}
var HistogramAccumulation = /** @class */ (function () {
    function HistogramAccumulation(startTime, _boundaries, _recordMinMax, _current) {
        if (_recordMinMax === void 0) { _recordMinMax = true; }
        if (_current === void 0) { _current = createNewEmptyCheckpoint(_boundaries); }
        this.startTime = startTime;
        this._boundaries = _boundaries;
        this._recordMinMax = _recordMinMax;
        this._current = _current;
    }
    HistogramAccumulation.prototype.record = function (value) {
        this._current.count += 1;
        this._current.sum += value;
        if (this._recordMinMax) {
            this._current.min = Math.min(value, this._current.min);
            this._current.max = Math.max(value, this._current.max);
            this._current.hasMinMax = true;
        }
        for (var i = 0; i < this._boundaries.length; i++) {
            if (value < this._boundaries[i]) {
                this._current.buckets.counts[i] += 1;
                return;
            }
        }
        // value is above all observed boundaries
        this._current.buckets.counts[this._boundaries.length] += 1;
    };
    HistogramAccumulation.prototype.setStartTime = function (startTime) {
        this.startTime = startTime;
    };
    HistogramAccumulation.prototype.toPointValue = function () {
        return this._current;
    };
    return HistogramAccumulation;
}());

/**
 * Basic aggregator which observes events and counts them in pre-defined buckets
 * and provides the total sum and count of all observations.
 */
var HistogramAggregator = /** @class */ (function () {
    /**
     * @param _boundaries upper bounds of recorded values.
     * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
     */
    function HistogramAggregator(_boundaries, _recordMinMax) {
        this._boundaries = _boundaries;
        this._recordMinMax = _recordMinMax;
        this.kind = AggregatorKind.HISTOGRAM;
    }
    HistogramAggregator.prototype.createAccumulation = function (startTime) {
        return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);
    };
    /**
     * Return the result of the merge of two histogram accumulations. As long as one Aggregator
     * instance produces all Accumulations with constant boundaries we don't need to worry about
     * merging accumulations with different boundaries.
     */
    HistogramAggregator.prototype.merge = function (previous, delta) {
        var previousValue = previous.toPointValue();
        var deltaValue = delta.toPointValue();
        var previousCounts = previousValue.buckets.counts;
        var deltaCounts = deltaValue.buckets.counts;
        var mergedCounts = new Array(previousCounts.length);
        for (var idx = 0; idx < previousCounts.length; idx++) {
            mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];
        }
        var min = Infinity;
        var max = -Infinity;
        if (this._recordMinMax) {
            if (previousValue.hasMinMax && deltaValue.hasMinMax) {
                min = Math.min(previousValue.min, deltaValue.min);
                max = Math.max(previousValue.max, deltaValue.max);
            }
            else if (previousValue.hasMinMax) {
                min = previousValue.min;
                max = previousValue.max;
            }
            else if (deltaValue.hasMinMax) {
                min = deltaValue.min;
                max = deltaValue.max;
            }
        }
        return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
            buckets: {
                boundaries: previousValue.buckets.boundaries,
                counts: mergedCounts,
            },
            count: previousValue.count + deltaValue.count,
            sum: previousValue.sum + deltaValue.sum,
            hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),
            min: min,
            max: max
        });
    };
    /**
     * Returns a new DELTA aggregation by comparing two cumulative measurements.
     */
    HistogramAggregator.prototype.diff = function (previous, current) {
        var previousValue = previous.toPointValue();
        var currentValue = current.toPointValue();
        var previousCounts = previousValue.buckets.counts;
        var currentCounts = currentValue.buckets.counts;
        var diffedCounts = new Array(previousCounts.length);
        for (var idx = 0; idx < previousCounts.length; idx++) {
            diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];
        }
        return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
            buckets: {
                boundaries: previousValue.buckets.boundaries,
                counts: diffedCounts,
            },
            count: currentValue.count - previousValue.count,
            sum: currentValue.sum - previousValue.sum,
            hasMinMax: false,
            min: Infinity,
            max: -Infinity
        });
    };
    HistogramAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
            descriptor: descriptor,
            aggregationTemporality: aggregationTemporality,
            dataPointType: MetricData_DataPointType.HISTOGRAM,
            dataPoints: accumulationByAttributes.map(function (_a) {
                var _b = Histogram_read(_a, 2), attributes = _b[0], accumulation = _b[1];
                var pointValue = accumulation.toPointValue();
                // determine if instrument allows negative values.
                var allowsNegativeValues = (descriptor.type === InstrumentType.UP_DOWN_COUNTER) ||
                    (descriptor.type === InstrumentType.OBSERVABLE_GAUGE) ||
                    (descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER);
                return {
                    attributes: attributes,
                    startTime: accumulation.startTime,
                    endTime: endTime,
                    value: {
                        min: pointValue.hasMinMax ? pointValue.min : undefined,
                        max: pointValue.hasMinMax ? pointValue.max : undefined,
                        sum: !allowsNegativeValues ? pointValue.sum : undefined,
                        buckets: pointValue.buckets,
                        count: pointValue.count
                    },
                };
            })
        };
    };
    return HistogramAggregator;
}());

//# sourceMappingURL=Histogram.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var build_esm_trace_suppress_tracing_SUPPRESS_TRACING_KEY = createContextKey('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function build_esm_trace_suppress_tracing_suppressTracing(context) {
    return context.setValue(build_esm_trace_suppress_tracing_SUPPRESS_TRACING_KEY, true);
}
function build_esm_trace_suppress_tracing_unsuppressTracing(context) {
    return context.deleteValue(build_esm_trace_suppress_tracing_SUPPRESS_TRACING_KEY);
}
function build_esm_trace_suppress_tracing_isTracingSuppressed(context) {
    return context.getValue(build_esm_trace_suppress_tracing_SUPPRESS_TRACING_KEY) === true;
}
//# sourceMappingURL=suppress-tracing.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/baggage/constants.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var build_esm_baggage_constants_BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var build_esm_baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR = ';';
var core_build_esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR = ',';
// Name of the http header used to propagate the baggage
var build_esm_baggage_constants_BAGGAGE_HEADER = 'baggage';
// Maximum number of name-value pairs allowed by w3c spec
var build_esm_baggage_constants_BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
// Maximum number of bytes per a single name-value pair allowed by w3c spec
var build_esm_baggage_constants_BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
// Maximum total length of all name-value pairs allowed by w3c spec
var build_esm_baggage_constants_BAGGAGE_MAX_TOTAL_LENGTH = 8192;
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/baggage/utils.js
var core_build_esm_baggage_utils_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function build_esm_baggage_utils_serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function (hValue, current) {
        var value = "" + hValue + (hValue !== '' ? core_build_esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR : '') + current;
        return value.length > build_esm_baggage_constants_BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, '');
}
function build_esm_baggage_utils_getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function (_a) {
        var _b = core_build_esm_baggage_utils_read(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) {
            entry += build_esm_baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
    });
}
function build_esm_baggage_utils_parsePairKeyValue(entry) {
    var valueProps = entry.split(build_esm_baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
        return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart)
        return;
    var keyPair = keyPairPart.split(build_esm_baggage_constants_BAGGAGE_KEY_PAIR_SEPARATOR);
    if (keyPair.length !== 2)
        return;
    var key = decodeURIComponent(keyPair[0].trim());
    var value = decodeURIComponent(keyPair[1].trim());
    var metadata;
    if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(build_esm_baggage_constants_BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key: key, value: value, metadata: metadata };
}
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */
function build_esm_baggage_utils_parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0)
        return {};
    return value
        .split(BAGGAGE_ITEMS_SEPARATOR)
        .map(function (entry) {
        return build_esm_baggage_utils_parsePairKeyValue(entry);
    })
        .filter(function (keyPair) { return keyPair !== undefined && keyPair.value.length > 0; })
        .reduce(function (headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Propagates {@link Baggage} through Context format propagation.
 *
 * Based on the Baggage specification:
 * https://w3c.github.io/baggage/
 */
var esm_baggage_propagation_W3CBaggagePropagator_W3CBaggagePropagator = /** @class */ (function () {
    function W3CBaggagePropagator() {
    }
    W3CBaggagePropagator.prototype.inject = function (context, carrier, setter) {
        var baggage = propagation.getBaggage(context);
        if (!baggage || build_esm_trace_suppress_tracing_isTracingSuppressed(context))
            return;
        var keyPairs = build_esm_baggage_utils_getKeyPairs(baggage)
            .filter(function (pair) {
            return pair.length <= build_esm_baggage_constants_BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        })
            .slice(0, build_esm_baggage_constants_BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = build_esm_baggage_utils_serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
            setter.set(carrier, build_esm_baggage_constants_BAGGAGE_HEADER, headerValue);
        }
    };
    W3CBaggagePropagator.prototype.extract = function (context, carrier, getter) {
        var headerValue = getter.get(carrier, build_esm_baggage_constants_BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(core_build_esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
            return context;
        var baggage = {};
        if (baggageString.length === 0) {
            return context;
        }
        var pairs = baggageString.split(core_build_esm_baggage_constants_BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function (entry) {
            var keyPair = build_esm_baggage_utils_parsePairKeyValue(entry);
            if (keyPair) {
                var baggageEntry = { value: keyPair.value };
                if (keyPair.metadata) {
                    baggageEntry.metadata = keyPair.metadata;
                }
                baggage[keyPair.key] = baggageEntry;
            }
        });
        if (Object.entries(baggage).length === 0) {
            return context;
        }
        return propagation.setBaggage(context, propagation.createBaggage(baggage));
    };
    W3CBaggagePropagator.prototype.fields = function () {
        return [build_esm_baggage_constants_BAGGAGE_HEADER];
    };
    return W3CBaggagePropagator;
}());

//# sourceMappingURL=W3CBaggagePropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/common/anchored-clock.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A utility for returning wall times anchored to a given point in time. Wall time measurements will
 * not be taken from the system, but instead are computed by adding a monotonic clock time
 * to the anchor point.
 *
 * This is needed because the system time can change and result in unexpected situations like
 * spans ending before they are started. Creating an anchored clock for each local root span
 * ensures that span timings and durations are accurate while preventing span times from drifting
 * too far from the system clock.
 *
 * Only creating an anchored clock once per local trace ensures span times are correct relative
 * to each other. For example, a child span will never have a start time before its parent even
 * if the system clock is corrected during the local trace.
 *
 * Heavily inspired by the OTel Java anchored clock
 * https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk/trace/src/main/java/io/opentelemetry/sdk/trace/AnchoredClock.java
 */
var esm_common_anchored_clock_AnchoredClock = /** @class */ (function () {
    /**
     * Create a new AnchoredClock anchored to the current time returned by systemClock.
     *
     * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
     * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
     */
    function AnchoredClock(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
    }
    /**
     * Returns the current time by adding the number of milliseconds since the
     * AnchoredClock was created to the creation epoch time
     */
    AnchoredClock.prototype.now = function () {
        var delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
    };
    return AnchoredClock;
}());

//# sourceMappingURL=anchored-clock.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/common/attributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var core_build_esm_common_attributes_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var core_build_esm_common_attributes_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

function build_esm_common_attributes_sanitizeAttributes(attributes) {
    var e_1, _a;
    var out = {};
    if (typeof attributes !== 'object' || attributes == null) {
        return out;
    }
    try {
        for (var _b = core_build_esm_common_attributes_values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = core_build_esm_common_attributes_read(_c.value, 2), key = _d[0], val = _d[1];
            if (!build_esm_common_attributes_isAttributeKey(key)) {
                diag.warn("Invalid attribute key: " + key);
                continue;
            }
            if (!build_esm_common_attributes_isAttributeValue(val)) {
                diag.warn("Invalid attribute value set for key: " + key);
                continue;
            }
            if (Array.isArray(val)) {
                out[key] = val.slice();
            }
            else {
                out[key] = val;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return out;
}
function build_esm_common_attributes_isAttributeKey(key) {
    return typeof key === 'string' && key.length > 0;
}
function build_esm_common_attributes_isAttributeValue(val) {
    if (val == null) {
        return true;
    }
    if (Array.isArray(val)) {
        return build_esm_common_attributes_isHomogeneousAttributeValueArray(val);
    }
    return build_esm_common_attributes_isValidPrimitiveAttributeValue(val);
}
function build_esm_common_attributes_isHomogeneousAttributeValueArray(arr) {
    var e_2, _a;
    var type;
    try {
        for (var arr_1 = core_build_esm_common_attributes_values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var element = arr_1_1.value;
            // null/undefined elements are allowed
            if (element == null)
                continue;
            if (!type) {
                if (build_esm_common_attributes_isValidPrimitiveAttributeValue(element)) {
                    type = typeof element;
                    continue;
                }
                // encountered an invalid primitive
                return false;
            }
            if (typeof element === type) {
                continue;
            }
            return false;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return true;
}
function build_esm_common_attributes_isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
        case 'number':
        case 'boolean':
        case 'string':
            return true;
    }
    return false;
}
//# sourceMappingURL=attributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */
function build_esm_common_logging_error_handler_loggingErrorHandler() {
    return function (ex) {
        esm_diag.error(build_esm_common_logging_error_handler_stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */
function build_esm_common_logging_error_handler_stringifyException(ex) {
    if (typeof ex === 'string') {
        return ex;
    }
    else {
        return JSON.stringify(build_esm_common_logging_error_handler_flattenException(ex));
    }
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */
function build_esm_common_logging_error_handler_flattenException(ex) {
    var result = {};
    var current = ex;
    while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function (propertyName) {
            if (result[propertyName])
                return;
            var value = current[propertyName];
            if (value) {
                result[propertyName] = String(value);
            }
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}
//# sourceMappingURL=logging-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** The global error handler delegate */
var build_esm_common_global_error_handler_delegateHandler = build_esm_common_logging_error_handler_loggingErrorHandler();
/**
 * Set the global error handler
 * @param {ErrorHandler} handler
 */
function build_esm_common_global_error_handler_setGlobalErrorHandler(handler) {
    build_esm_common_global_error_handler_delegateHandler = handler;
}
/**
 * Return the global error handler
 * @param {Exception} ex
 */
function build_esm_common_global_error_handler_globalErrorHandler(ex) {
    try {
        build_esm_common_global_error_handler_delegateHandler(ex);
    }
    catch (_a) { } // eslint-disable-line no-empty
}
//# sourceMappingURL=global-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/utils/sampling.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var build_esm_utils_sampling_TracesSamplerValues;
(function (TracesSamplerValues) {
    TracesSamplerValues["AlwaysOff"] = "always_off";
    TracesSamplerValues["AlwaysOn"] = "always_on";
    TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues["TraceIdRatio"] = "traceidratio";
})(build_esm_utils_sampling_TracesSamplerValues || (build_esm_utils_sampling_TracesSamplerValues = {}));
//# sourceMappingURL=sampling.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/platform/browser/globalThis.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/api-metrics too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var core_build_esm_platform_browser_globalThis_globalThis = typeof globalThis === 'object' ? globalThis :
    typeof self === 'object' ? self :
        typeof window === 'object' ? window :
            typeof __webpack_require__.g === 'object' ? __webpack_require__.g :
                {};
//# sourceMappingURL=globalThis.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/utils/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var build_esm_utils_environment_DEFAULT_LIST_SEPARATOR = ',';
/**
 * Environment interface to define all names
 */
var build_esm_utils_environment_ENVIRONMENT_NUMBERS_KEYS = [
    'OTEL_BSP_EXPORT_TIMEOUT',
    'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BSP_MAX_QUEUE_SIZE',
    'OTEL_BSP_SCHEDULE_DELAY',
    'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_LINK_COUNT_LIMIT',
    'OTEL_EXPORTER_OTLP_TIMEOUT',
    'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
    'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
    'OTEL_EXPORTER_JAEGER_AGENT_PORT',
];
function build_esm_utils_environment_isEnvVarANumber(key) {
    return (build_esm_utils_environment_ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1);
}
var build_esm_utils_environment_ENVIRONMENT_LISTS_KEYS = [
    'OTEL_NO_PATCH_MODULES',
    'OTEL_PROPAGATORS',
];
function build_esm_utils_environment_isEnvVarAList(key) {
    return build_esm_utils_environment_ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var build_esm_utils_environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var build_esm_utils_environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
/**
 * Default environment variables
 */
var core_build_esm_utils_environment_DEFAULT_ENVIRONMENT = {
    CONTAINER_NAME: '',
    ECS_CONTAINER_METADATA_URI_V4: '',
    ECS_CONTAINER_METADATA_URI: '',
    HOSTNAME: '',
    KUBERNETES_SERVICE_HOST: '',
    NAMESPACE: '',
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: '',
    OTEL_EXPORTER_JAEGER_PASSWORD: '',
    OTEL_EXPORTER_JAEGER_USER: '',
    OTEL_EXPORTER_OTLP_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_HEADERS: '',
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
    OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
    OTEL_LOG_LEVEL: DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
    OTEL_RESOURCE_ATTRIBUTES: '',
    OTEL_SERVICE_NAME: '',
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: build_esm_utils_environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: build_esm_utils_environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: build_esm_utils_environment_DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: build_esm_utils_environment_DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_TRACES_EXPORTER: 'none',
    OTEL_TRACES_SAMPLER: build_esm_utils_sampling_TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: '',
    OTEL_EXPORTER_OTLP_INSECURE: '',
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
    OTEL_EXPORTER_OTLP_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: ''
};
/**
 * Parses a variable as number with number validation
 * @param name
 * @param environment
 * @param values
 * @param min
 * @param max
 */
function build_esm_utils_environment_parseNumber(name, environment, values, min, max) {
    if (min === void 0) { min = -Infinity; }
    if (max === void 0) { max = Infinity; }
    if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
            if (value < min) {
                environment[name] = min;
            }
            else if (value > max) {
                environment[name] = max;
            }
            else {
                environment[name] = value;
            }
        }
    }
}
/**
 * Parses list-like strings from input into output.
 * @param name
 * @param environment
 * @param values
 * @param separator
 */
function build_esm_utils_environment_parseStringList(name, output, input, separator) {
    if (separator === void 0) { separator = build_esm_utils_environment_DEFAULT_LIST_SEPARATOR; }
    var givenValue = input[name];
    if (typeof givenValue === 'string') {
        output[name] = givenValue.split(separator).map(function (v) { return v.trim(); });
    }
}
// The support string -> DiagLogLevel mappings
var build_esm_utils_environment_logLevelMap = {
    ALL: DiagLogLevel.ALL,
    VERBOSE: DiagLogLevel.VERBOSE,
    DEBUG: DiagLogLevel.DEBUG,
    INFO: DiagLogLevel.INFO,
    WARN: DiagLogLevel.WARN,
    ERROR: DiagLogLevel.ERROR,
    NONE: DiagLogLevel.NONE,
};
/**
 * Environmentally sets log level if valid log level string is provided
 * @param key
 * @param environment
 * @param values
 */
function build_esm_utils_environment_setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if (typeof value === 'string') {
        var theLevel = build_esm_utils_environment_logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
            environment[key] = theLevel;
        }
    }
}
/**
 * Parses environment values
 * @param values
 */
function core_build_esm_utils_environment_parseEnvironment(values) {
    var environment = {};
    for (var env in core_build_esm_utils_environment_DEFAULT_ENVIRONMENT) {
        var key = env;
        switch (key) {
            case 'OTEL_LOG_LEVEL':
                build_esm_utils_environment_setLogLevelFromEnv(key, environment, values);
                break;
            default:
                if (build_esm_utils_environment_isEnvVarANumber(key)) {
                    build_esm_utils_environment_parseNumber(key, environment, values);
                }
                else if (build_esm_utils_environment_isEnvVarAList(key)) {
                    build_esm_utils_environment_parseStringList(key, environment, values);
                }
                else {
                    var value = values[key];
                    if (typeof value !== 'undefined' && value !== null) {
                        environment[key] = String(value);
                    }
                }
        }
    }
    return environment;
}
/**
 * Get environment in node or browser without
 * populating default values.
 */
function build_esm_utils_environment_getEnvWithoutDefaults() {
    return typeof process !== 'undefined' ?
        core_build_esm_utils_environment_parseEnvironment("MISSING_ENV_VAR") :
        core_build_esm_utils_environment_parseEnvironment(_globalThis);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/platform/browser/environment.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Gets the environment variables
 */
function esm_platform_browser_environment_getEnv() {
    var globalEnv = core_build_esm_utils_environment_parseEnvironment(core_build_esm_platform_browser_globalThis_globalThis);
    return Object.assign({}, core_build_esm_utils_environment_DEFAULT_ENVIRONMENT, globalEnv);
}
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/platform/browser/RandomIdGenerator.js
var esm_platform_browser_RandomIdGenerator_SPAN_ID_BYTES = 8;
var esm_platform_browser_RandomIdGenerator_TRACE_ID_BYTES = 16;
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 */
var esm_platform_browser_RandomIdGenerator_RandomIdGenerator = /** @class */ (function () {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */
        this.generateTraceId = esm_platform_browser_RandomIdGenerator_getIdGenerator(esm_platform_browser_RandomIdGenerator_TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */
        this.generateSpanId = esm_platform_browser_RandomIdGenerator_getIdGenerator(esm_platform_browser_RandomIdGenerator_SPAN_ID_BYTES);
    }
    return RandomIdGenerator;
}());

var esm_platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY = Array(32);
function esm_platform_browser_RandomIdGenerator_getIdGenerator(bytes) {
    return function generateId() {
        for (var i = 0; i < bytes * 2; i++) {
            esm_platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
            // valid hex characters in the range 48-57 and 97-102
            if (esm_platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] >= 58) {
                esm_platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY[i] += 39;
            }
        }
        return String.fromCharCode.apply(null, esm_platform_browser_RandomIdGenerator_SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
    };
}
//# sourceMappingURL=RandomIdGenerator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/platform/browser/performance.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_platform_browser_performance_otperformance = performance;
//# sourceMappingURL=performance.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/version.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var _opentelemetry_core_build_esm_version_VERSION = '1.7.0';
//# sourceMappingURL=version.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var build_esm_trace_SemanticAttributes_SemanticAttributes = {
    /**
    * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
    *
    * Note: This may be different from `faas.id` if an alias is involved.
    */
    AWS_LAMBDA_INVOKED_ARN: 'aws.lambda.invoked_arn',
    /**
    * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
    */
    DB_SYSTEM: 'db.system',
    /**
    * The connection string used to connect to the database. It is recommended to remove embedded credentials.
    */
    DB_CONNECTION_STRING: 'db.connection_string',
    /**
    * Username for accessing the database.
    */
    DB_USER: 'db.user',
    /**
    * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
    */
    DB_JDBC_DRIVER_CLASSNAME: 'db.jdbc.driver_classname',
    /**
    * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
    *
    * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
    */
    DB_NAME: 'db.name',
    /**
    * The database statement being executed.
    *
    * Note: The value may be sanitized to exclude sensitive information.
    */
    DB_STATEMENT: 'db.statement',
    /**
    * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
    *
    * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
    */
    DB_OPERATION: 'db.operation',
    /**
    * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
    *
    * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
    */
    DB_MSSQL_INSTANCE_NAME: 'db.mssql.instance_name',
    /**
    * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_CASSANDRA_KEYSPACE: 'db.cassandra.keyspace',
    /**
    * The fetch size used for paging, i.e. how many rows will be returned at once.
    */
    DB_CASSANDRA_PAGE_SIZE: 'db.cassandra.page_size',
    /**
    * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
    */
    DB_CASSANDRA_CONSISTENCY_LEVEL: 'db.cassandra.consistency_level',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_CASSANDRA_TABLE: 'db.cassandra.table',
    /**
    * Whether or not the query is idempotent.
    */
    DB_CASSANDRA_IDEMPOTENCE: 'db.cassandra.idempotence',
    /**
    * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
    */
    DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: 'db.cassandra.speculative_execution_count',
    /**
    * The ID of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_ID: 'db.cassandra.coordinator.id',
    /**
    * The data center of the coordinating node for a query.
    */
    DB_CASSANDRA_COORDINATOR_DC: 'db.cassandra.coordinator.dc',
    /**
    * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
    */
    DB_HBASE_NAMESPACE: 'db.hbase.namespace',
    /**
    * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
    */
    DB_REDIS_DATABASE_INDEX: 'db.redis.database_index',
    /**
    * The collection being accessed within the database stated in `db.name`.
    */
    DB_MONGODB_COLLECTION: 'db.mongodb.collection',
    /**
    * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
    *
    * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
    */
    DB_SQL_TABLE: 'db.sql.table',
    /**
    * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
    */
    EXCEPTION_TYPE: 'exception.type',
    /**
    * The exception message.
    */
    EXCEPTION_MESSAGE: 'exception.message',
    /**
    * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
    */
    EXCEPTION_STACKTRACE: 'exception.stacktrace',
    /**
    * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
    *
    * Note: An exception is considered to have escaped (or left) the scope of a span,
  if that span is ended while the exception is still logically &#34;in flight&#34;.
  This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
  is passed to a Context manager&#39;s `__exit__` method in Python) but will
  usually be caught at the point of recording the exception in most languages.
  
  It is usually not possible to determine at the point where an exception is thrown
  whether it will escape the scope of a span.
  However, it is trivial to know that an exception
  will escape, if one checks for an active exception just before ending the span,
  as done in the [example above](#exception-end-example).
  
  It follows that an exception may still escape the scope of the span
  even if the `exception.escaped` attribute was not set or set to false,
  since the event might have been recorded at a time where it was not
  clear whether the exception will escape.
    */
    EXCEPTION_ESCAPED: 'exception.escaped',
    /**
    * Type of the trigger on which the function is executed.
    */
    FAAS_TRIGGER: 'faas.trigger',
    /**
    * The execution ID of the current function execution.
    */
    FAAS_EXECUTION: 'faas.execution',
    /**
    * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
    */
    FAAS_DOCUMENT_COLLECTION: 'faas.document.collection',
    /**
    * Describes the type of the operation that was performed on the data.
    */
    FAAS_DOCUMENT_OPERATION: 'faas.document.operation',
    /**
    * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_DOCUMENT_TIME: 'faas.document.time',
    /**
    * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
    */
    FAAS_DOCUMENT_NAME: 'faas.document.name',
    /**
    * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
    */
    FAAS_TIME: 'faas.time',
    /**
    * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
    */
    FAAS_CRON: 'faas.cron',
    /**
    * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
    */
    FAAS_COLDSTART: 'faas.coldstart',
    /**
    * The name of the invoked function.
    *
    * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
    */
    FAAS_INVOKED_NAME: 'faas.invoked_name',
    /**
    * The cloud provider of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
    */
    FAAS_INVOKED_PROVIDER: 'faas.invoked_provider',
    /**
    * The cloud region of the invoked function.
    *
    * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
    */
    FAAS_INVOKED_REGION: 'faas.invoked_region',
    /**
    * Transport protocol used. See note below.
    */
    NET_TRANSPORT: 'net.transport',
    /**
    * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
    */
    NET_PEER_IP: 'net.peer.ip',
    /**
    * Remote port number.
    */
    NET_PEER_PORT: 'net.peer.port',
    /**
    * Remote hostname or similar, see note below.
    */
    NET_PEER_NAME: 'net.peer.name',
    /**
    * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
    */
    NET_HOST_IP: 'net.host.ip',
    /**
    * Like `net.peer.port` but for the host port.
    */
    NET_HOST_PORT: 'net.host.port',
    /**
    * Local hostname or similar, see note below.
    */
    NET_HOST_NAME: 'net.host.name',
    /**
    * The internet connection type currently being used by the host.
    */
    NET_HOST_CONNECTION_TYPE: 'net.host.connection.type',
    /**
    * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
    */
    NET_HOST_CONNECTION_SUBTYPE: 'net.host.connection.subtype',
    /**
    * The name of the mobile carrier.
    */
    NET_HOST_CARRIER_NAME: 'net.host.carrier.name',
    /**
    * The mobile carrier country code.
    */
    NET_HOST_CARRIER_MCC: 'net.host.carrier.mcc',
    /**
    * The mobile carrier network code.
    */
    NET_HOST_CARRIER_MNC: 'net.host.carrier.mnc',
    /**
    * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
    */
    NET_HOST_CARRIER_ICC: 'net.host.carrier.icc',
    /**
    * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
    */
    PEER_SERVICE: 'peer.service',
    /**
    * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
    */
    ENDUSER_ID: 'enduser.id',
    /**
    * Actual/assumed role the client is making the request under extracted from token or application security context.
    */
    ENDUSER_ROLE: 'enduser.role',
    /**
    * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
    */
    ENDUSER_SCOPE: 'enduser.scope',
    /**
    * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
    */
    THREAD_ID: 'thread.id',
    /**
    * Current thread name.
    */
    THREAD_NAME: 'thread.name',
    /**
    * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
    */
    CODE_FUNCTION: 'code.function',
    /**
    * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
    */
    CODE_NAMESPACE: 'code.namespace',
    /**
    * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
    */
    CODE_FILEPATH: 'code.filepath',
    /**
    * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
    */
    CODE_LINENO: 'code.lineno',
    /**
    * HTTP request method.
    */
    HTTP_METHOD: 'http.method',
    /**
    * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
    *
    * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
    */
    HTTP_URL: 'http.url',
    /**
    * The full request target as passed in a HTTP request line or equivalent.
    */
    HTTP_TARGET: 'http.target',
    /**
    * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
    *
    * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
    */
    HTTP_HOST: 'http.host',
    /**
    * The URI scheme identifying the used protocol.
    */
    HTTP_SCHEME: 'http.scheme',
    /**
    * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
    */
    HTTP_STATUS_CODE: 'http.status_code',
    /**
    * Kind of HTTP protocol used.
    *
    * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
    */
    HTTP_FLAVOR: 'http.flavor',
    /**
    * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
    */
    HTTP_USER_AGENT: 'http.user_agent',
    /**
    * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_REQUEST_CONTENT_LENGTH: 'http.request_content_length',
    /**
    * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: 'http.request_content_length_uncompressed',
    /**
    * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
    */
    HTTP_RESPONSE_CONTENT_LENGTH: 'http.response_content_length',
    /**
    * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
    */
    HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: 'http.response_content_length_uncompressed',
    /**
    * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
    *
    * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
    */
    HTTP_SERVER_NAME: 'http.server_name',
    /**
    * The matched route (path template).
    */
    HTTP_ROUTE: 'http.route',
    /**
    * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
    *
    * Note: This is not necessarily the same as `net.peer.ip`, which would
  identify the network-level peer, which may be a proxy.
  
  This attribute should be set when a source of information different
  from the one used for `net.peer.ip`, is available even if that other
  source just confirms the same value as `net.peer.ip`.
  Rationale: For `net.peer.ip`, one typically does not know if it
  comes from a proxy, reverse proxy, or the actual client. Setting
  `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
  one is at least somewhat confident that the address is not that of
  the closest proxy.
    */
    HTTP_CLIENT_IP: 'http.client_ip',
    /**
    * The keys in the `RequestItems` object field.
    */
    AWS_DYNAMODB_TABLE_NAMES: 'aws.dynamodb.table_names',
    /**
    * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
    */
    AWS_DYNAMODB_CONSUMED_CAPACITY: 'aws.dynamodb.consumed_capacity',
    /**
    * The JSON-serialized value of the `ItemCollectionMetrics` response field.
    */
    AWS_DYNAMODB_ITEM_COLLECTION_METRICS: 'aws.dynamodb.item_collection_metrics',
    /**
    * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: 'aws.dynamodb.provisioned_read_capacity',
    /**
    * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
    */
    AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: 'aws.dynamodb.provisioned_write_capacity',
    /**
    * The value of the `ConsistentRead` request parameter.
    */
    AWS_DYNAMODB_CONSISTENT_READ: 'aws.dynamodb.consistent_read',
    /**
    * The value of the `ProjectionExpression` request parameter.
    */
    AWS_DYNAMODB_PROJECTION: 'aws.dynamodb.projection',
    /**
    * The value of the `Limit` request parameter.
    */
    AWS_DYNAMODB_LIMIT: 'aws.dynamodb.limit',
    /**
    * The value of the `AttributesToGet` request parameter.
    */
    AWS_DYNAMODB_ATTRIBUTES_TO_GET: 'aws.dynamodb.attributes_to_get',
    /**
    * The value of the `IndexName` request parameter.
    */
    AWS_DYNAMODB_INDEX_NAME: 'aws.dynamodb.index_name',
    /**
    * The value of the `Select` request parameter.
    */
    AWS_DYNAMODB_SELECT: 'aws.dynamodb.select',
    /**
    * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: 'aws.dynamodb.global_secondary_indexes',
    /**
    * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
    */
    AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: 'aws.dynamodb.local_secondary_indexes',
    /**
    * The value of the `ExclusiveStartTableName` request parameter.
    */
    AWS_DYNAMODB_EXCLUSIVE_START_TABLE: 'aws.dynamodb.exclusive_start_table',
    /**
    * The the number of items in the `TableNames` response parameter.
    */
    AWS_DYNAMODB_TABLE_COUNT: 'aws.dynamodb.table_count',
    /**
    * The value of the `ScanIndexForward` request parameter.
    */
    AWS_DYNAMODB_SCAN_FORWARD: 'aws.dynamodb.scan_forward',
    /**
    * The value of the `Segment` request parameter.
    */
    AWS_DYNAMODB_SEGMENT: 'aws.dynamodb.segment',
    /**
    * The value of the `TotalSegments` request parameter.
    */
    AWS_DYNAMODB_TOTAL_SEGMENTS: 'aws.dynamodb.total_segments',
    /**
    * The value of the `Count` response parameter.
    */
    AWS_DYNAMODB_COUNT: 'aws.dynamodb.count',
    /**
    * The value of the `ScannedCount` response parameter.
    */
    AWS_DYNAMODB_SCANNED_COUNT: 'aws.dynamodb.scanned_count',
    /**
    * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
    */
    AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: 'aws.dynamodb.attribute_definitions',
    /**
    * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
    */
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: 'aws.dynamodb.global_secondary_index_updates',
    /**
    * A string identifying the messaging system.
    */
    MESSAGING_SYSTEM: 'messaging.system',
    /**
    * The message destination name. This might be equal to the span name but is required nevertheless.
    */
    MESSAGING_DESTINATION: 'messaging.destination',
    /**
    * The kind of message destination.
    */
    MESSAGING_DESTINATION_KIND: 'messaging.destination_kind',
    /**
    * A boolean that is true if the message destination is temporary.
    */
    MESSAGING_TEMP_DESTINATION: 'messaging.temp_destination',
    /**
    * The name of the transport protocol.
    */
    MESSAGING_PROTOCOL: 'messaging.protocol',
    /**
    * The version of the transport protocol.
    */
    MESSAGING_PROTOCOL_VERSION: 'messaging.protocol_version',
    /**
    * Connection string.
    */
    MESSAGING_URL: 'messaging.url',
    /**
    * A value used by the messaging system as an identifier for the message, represented as a string.
    */
    MESSAGING_MESSAGE_ID: 'messaging.message_id',
    /**
    * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
    */
    MESSAGING_CONVERSATION_ID: 'messaging.conversation_id',
    /**
    * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
    */
    MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: 'messaging.message_payload_size_bytes',
    /**
    * The compressed size of the message payload in bytes.
    */
    MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: 'messaging.message_payload_compressed_size_bytes',
    /**
    * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
    */
    MESSAGING_OPERATION: 'messaging.operation',
    /**
    * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
    */
    MESSAGING_CONSUMER_ID: 'messaging.consumer_id',
    /**
    * RabbitMQ message routing key.
    */
    MESSAGING_RABBITMQ_ROUTING_KEY: 'messaging.rabbitmq.routing_key',
    /**
    * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
    *
    * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
    */
    MESSAGING_KAFKA_MESSAGE_KEY: 'messaging.kafka.message_key',
    /**
    * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
    */
    MESSAGING_KAFKA_CONSUMER_GROUP: 'messaging.kafka.consumer_group',
    /**
    * Client Id for the Consumer or Producer that is handling the message.
    */
    MESSAGING_KAFKA_CLIENT_ID: 'messaging.kafka.client_id',
    /**
    * Partition the message is sent to.
    */
    MESSAGING_KAFKA_PARTITION: 'messaging.kafka.partition',
    /**
    * A boolean that is true if the message is a tombstone.
    */
    MESSAGING_KAFKA_TOMBSTONE: 'messaging.kafka.tombstone',
    /**
    * A string identifying the remoting system.
    */
    RPC_SYSTEM: 'rpc.system',
    /**
    * The full (logical) name of the service being called, including its package name, if applicable.
    *
    * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
    */
    RPC_SERVICE: 'rpc.service',
    /**
    * The name of the (logical) method being called, must be equal to the $method part in the span name.
    *
    * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
    */
    RPC_METHOD: 'rpc.method',
    /**
    * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
    */
    RPC_GRPC_STATUS_CODE: 'rpc.grpc.status_code',
    /**
    * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
    */
    RPC_JSONRPC_VERSION: 'rpc.jsonrpc.version',
    /**
    * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
    */
    RPC_JSONRPC_REQUEST_ID: 'rpc.jsonrpc.request_id',
    /**
    * `error.code` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_CODE: 'rpc.jsonrpc.error_code',
    /**
    * `error.message` property of response if it is an error response.
    */
    RPC_JSONRPC_ERROR_MESSAGE: 'rpc.jsonrpc.error_message',
    /**
    * Whether this is a received or sent message.
    */
    MESSAGE_TYPE: 'message.type',
    /**
    * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
    *
    * Note: This way we guarantee that the values will be consistent between different implementations.
    */
    MESSAGE_ID: 'message.id',
    /**
    * Compressed size of the message in bytes.
    */
    MESSAGE_COMPRESSED_SIZE: 'message.compressed_size',
    /**
    * Uncompressed size of the message in bytes.
    */
    MESSAGE_UNCOMPRESSED_SIZE: 'message.uncompressed_size',
};
var build_esm_trace_SemanticAttributes_DbSystemValues = {
    /** Some other SQL database. Fallback only. See notes. */
    OTHER_SQL: 'other_sql',
    /** Microsoft SQL Server. */
    MSSQL: 'mssql',
    /** MySQL. */
    MYSQL: 'mysql',
    /** Oracle Database. */
    ORACLE: 'oracle',
    /** IBM Db2. */
    DB2: 'db2',
    /** PostgreSQL. */
    POSTGRESQL: 'postgresql',
    /** Amazon Redshift. */
    REDSHIFT: 'redshift',
    /** Apache Hive. */
    HIVE: 'hive',
    /** Cloudscape. */
    CLOUDSCAPE: 'cloudscape',
    /** HyperSQL DataBase. */
    HSQLDB: 'hsqldb',
    /** Progress Database. */
    PROGRESS: 'progress',
    /** SAP MaxDB. */
    MAXDB: 'maxdb',
    /** SAP HANA. */
    HANADB: 'hanadb',
    /** Ingres. */
    INGRES: 'ingres',
    /** FirstSQL. */
    FIRSTSQL: 'firstsql',
    /** EnterpriseDB. */
    EDB: 'edb',
    /** InterSystems Caché. */
    CACHE: 'cache',
    /** Adabas (Adaptable Database System). */
    ADABAS: 'adabas',
    /** Firebird. */
    FIREBIRD: 'firebird',
    /** Apache Derby. */
    DERBY: 'derby',
    /** FileMaker. */
    FILEMAKER: 'filemaker',
    /** Informix. */
    INFORMIX: 'informix',
    /** InstantDB. */
    INSTANTDB: 'instantdb',
    /** InterBase. */
    INTERBASE: 'interbase',
    /** MariaDB. */
    MARIADB: 'mariadb',
    /** Netezza. */
    NETEZZA: 'netezza',
    /** Pervasive PSQL. */
    PERVASIVE: 'pervasive',
    /** PointBase. */
    POINTBASE: 'pointbase',
    /** SQLite. */
    SQLITE: 'sqlite',
    /** Sybase. */
    SYBASE: 'sybase',
    /** Teradata. */
    TERADATA: 'teradata',
    /** Vertica. */
    VERTICA: 'vertica',
    /** H2. */
    H2: 'h2',
    /** ColdFusion IMQ. */
    COLDFUSION: 'coldfusion',
    /** Apache Cassandra. */
    CASSANDRA: 'cassandra',
    /** Apache HBase. */
    HBASE: 'hbase',
    /** MongoDB. */
    MONGODB: 'mongodb',
    /** Redis. */
    REDIS: 'redis',
    /** Couchbase. */
    COUCHBASE: 'couchbase',
    /** CouchDB. */
    COUCHDB: 'couchdb',
    /** Microsoft Azure Cosmos DB. */
    COSMOSDB: 'cosmosdb',
    /** Amazon DynamoDB. */
    DYNAMODB: 'dynamodb',
    /** Neo4j. */
    NEO4J: 'neo4j',
    /** Apache Geode. */
    GEODE: 'geode',
    /** Elasticsearch. */
    ELASTICSEARCH: 'elasticsearch',
    /** Memcached. */
    MEMCACHED: 'memcached',
    /** CockroachDB. */
    COCKROACHDB: 'cockroachdb',
};
var build_esm_trace_SemanticAttributes_DbCassandraConsistencyLevelValues = {
    /** all. */
    ALL: 'all',
    /** each_quorum. */
    EACH_QUORUM: 'each_quorum',
    /** quorum. */
    QUORUM: 'quorum',
    /** local_quorum. */
    LOCAL_QUORUM: 'local_quorum',
    /** one. */
    ONE: 'one',
    /** two. */
    TWO: 'two',
    /** three. */
    THREE: 'three',
    /** local_one. */
    LOCAL_ONE: 'local_one',
    /** any. */
    ANY: 'any',
    /** serial. */
    SERIAL: 'serial',
    /** local_serial. */
    LOCAL_SERIAL: 'local_serial',
};
var build_esm_trace_SemanticAttributes_FaasTriggerValues = {
    /** A response to some data source operation such as a database or filesystem read/write. */
    DATASOURCE: 'datasource',
    /** To provide an answer to an inbound HTTP request. */
    HTTP: 'http',
    /** A function is set to be executed when messages are sent to a messaging system. */
    PUBSUB: 'pubsub',
    /** A function is scheduled to be executed regularly. */
    TIMER: 'timer',
    /** If none of the others apply. */
    OTHER: 'other',
};
var build_esm_trace_SemanticAttributes_FaasDocumentOperationValues = {
    /** When a new object is created. */
    INSERT: 'insert',
    /** When an object is modified. */
    EDIT: 'edit',
    /** When an object is deleted. */
    DELETE: 'delete',
};
var build_esm_trace_SemanticAttributes_FaasInvokedProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var build_esm_trace_SemanticAttributes_NetTransportValues = {
    /** ip_tcp. */
    IP_TCP: 'ip_tcp',
    /** ip_udp. */
    IP_UDP: 'ip_udp',
    /** Another IP-based protocol. */
    IP: 'ip',
    /** Unix Domain socket. See below. */
    UNIX: 'unix',
    /** Named or anonymous pipe. See note below. */
    PIPE: 'pipe',
    /** In-process communication. */
    INPROC: 'inproc',
    /** Something else (non IP-based). */
    OTHER: 'other',
};
var build_esm_trace_SemanticAttributes_NetHostConnectionTypeValues = {
    /** wifi. */
    WIFI: 'wifi',
    /** wired. */
    WIRED: 'wired',
    /** cell. */
    CELL: 'cell',
    /** unavailable. */
    UNAVAILABLE: 'unavailable',
    /** unknown. */
    UNKNOWN: 'unknown',
};
var build_esm_trace_SemanticAttributes_NetHostConnectionSubtypeValues = {
    /** GPRS. */
    GPRS: 'gprs',
    /** EDGE. */
    EDGE: 'edge',
    /** UMTS. */
    UMTS: 'umts',
    /** CDMA. */
    CDMA: 'cdma',
    /** EVDO Rel. 0. */
    EVDO_0: 'evdo_0',
    /** EVDO Rev. A. */
    EVDO_A: 'evdo_a',
    /** CDMA2000 1XRTT. */
    CDMA2000_1XRTT: 'cdma2000_1xrtt',
    /** HSDPA. */
    HSDPA: 'hsdpa',
    /** HSUPA. */
    HSUPA: 'hsupa',
    /** HSPA. */
    HSPA: 'hspa',
    /** IDEN. */
    IDEN: 'iden',
    /** EVDO Rev. B. */
    EVDO_B: 'evdo_b',
    /** LTE. */
    LTE: 'lte',
    /** EHRPD. */
    EHRPD: 'ehrpd',
    /** HSPAP. */
    HSPAP: 'hspap',
    /** GSM. */
    GSM: 'gsm',
    /** TD-SCDMA. */
    TD_SCDMA: 'td_scdma',
    /** IWLAN. */
    IWLAN: 'iwlan',
    /** 5G NR (New Radio). */
    NR: 'nr',
    /** 5G NRNSA (New Radio Non-Standalone). */
    NRNSA: 'nrnsa',
    /** LTE CA. */
    LTE_CA: 'lte_ca',
};
var build_esm_trace_SemanticAttributes_HttpFlavorValues = {
    /** HTTP 1.0. */
    HTTP_1_0: '1.0',
    /** HTTP 1.1. */
    HTTP_1_1: '1.1',
    /** HTTP 2. */
    HTTP_2_0: '2.0',
    /** SPDY protocol. */
    SPDY: 'SPDY',
    /** QUIC protocol. */
    QUIC: 'QUIC',
};
var build_esm_trace_SemanticAttributes_MessagingDestinationKindValues = {
    /** A message sent to a queue. */
    QUEUE: 'queue',
    /** A message sent to a topic. */
    TOPIC: 'topic',
};
var build_esm_trace_SemanticAttributes_MessagingOperationValues = {
    /** receive. */
    RECEIVE: 'receive',
    /** process. */
    PROCESS: 'process',
};
var build_esm_trace_SemanticAttributes_RpcGrpcStatusCodeValues = {
    /** OK. */
    OK: 0,
    /** CANCELLED. */
    CANCELLED: 1,
    /** UNKNOWN. */
    UNKNOWN: 2,
    /** INVALID_ARGUMENT. */
    INVALID_ARGUMENT: 3,
    /** DEADLINE_EXCEEDED. */
    DEADLINE_EXCEEDED: 4,
    /** NOT_FOUND. */
    NOT_FOUND: 5,
    /** ALREADY_EXISTS. */
    ALREADY_EXISTS: 6,
    /** PERMISSION_DENIED. */
    PERMISSION_DENIED: 7,
    /** RESOURCE_EXHAUSTED. */
    RESOURCE_EXHAUSTED: 8,
    /** FAILED_PRECONDITION. */
    FAILED_PRECONDITION: 9,
    /** ABORTED. */
    ABORTED: 10,
    /** OUT_OF_RANGE. */
    OUT_OF_RANGE: 11,
    /** UNIMPLEMENTED. */
    UNIMPLEMENTED: 12,
    /** INTERNAL. */
    INTERNAL: 13,
    /** UNAVAILABLE. */
    UNAVAILABLE: 14,
    /** DATA_LOSS. */
    DATA_LOSS: 15,
    /** UNAUTHENTICATED. */
    UNAUTHENTICATED: 16,
};
var build_esm_trace_SemanticAttributes_MessageTypeValues = {
    /** sent. */
    SENT: 'SENT',
    /** received. */
    RECEIVED: 'RECEIVED',
};
//# sourceMappingURL=SemanticAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2
var build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes = {
    /**
    * Name of the cloud provider.
    */
    CLOUD_PROVIDER: 'cloud.provider',
    /**
    * The cloud account ID the resource is assigned to.
    */
    CLOUD_ACCOUNT_ID: 'cloud.account.id',
    /**
    * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
    */
    CLOUD_REGION: 'cloud.region',
    /**
    * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
    *
    * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
    */
    CLOUD_AVAILABILITY_ZONE: 'cloud.availability_zone',
    /**
    * The cloud platform in use.
    *
    * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
    */
    CLOUD_PLATFORM: 'cloud.platform',
    /**
    * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
    */
    AWS_ECS_CONTAINER_ARN: 'aws.ecs.container.arn',
    /**
    * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
    */
    AWS_ECS_CLUSTER_ARN: 'aws.ecs.cluster.arn',
    /**
    * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
    */
    AWS_ECS_LAUNCHTYPE: 'aws.ecs.launchtype',
    /**
    * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
    */
    AWS_ECS_TASK_ARN: 'aws.ecs.task.arn',
    /**
    * The task definition family this task definition is a member of.
    */
    AWS_ECS_TASK_FAMILY: 'aws.ecs.task.family',
    /**
    * The revision for this task definition.
    */
    AWS_ECS_TASK_REVISION: 'aws.ecs.task.revision',
    /**
    * The ARN of an EKS cluster.
    */
    AWS_EKS_CLUSTER_ARN: 'aws.eks.cluster.arn',
    /**
    * The name(s) of the AWS log group(s) an application is writing to.
    *
    * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
    */
    AWS_LOG_GROUP_NAMES: 'aws.log.group.names',
    /**
    * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
    *
    * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
    */
    AWS_LOG_GROUP_ARNS: 'aws.log.group.arns',
    /**
    * The name(s) of the AWS log stream(s) an application is writing to.
    */
    AWS_LOG_STREAM_NAMES: 'aws.log.stream.names',
    /**
    * The ARN(s) of the AWS log stream(s).
    *
    * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
    */
    AWS_LOG_STREAM_ARNS: 'aws.log.stream.arns',
    /**
    * Container name.
    */
    CONTAINER_NAME: 'container.name',
    /**
    * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
    */
    CONTAINER_ID: 'container.id',
    /**
    * The container runtime managing this container.
    */
    CONTAINER_RUNTIME: 'container.runtime',
    /**
    * Name of the image the container was built on.
    */
    CONTAINER_IMAGE_NAME: 'container.image.name',
    /**
    * Container image tag.
    */
    CONTAINER_IMAGE_TAG: 'container.image.tag',
    /**
    * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
    */
    DEPLOYMENT_ENVIRONMENT: 'deployment.environment',
    /**
    * A unique identifier representing the device.
    *
    * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
    */
    DEVICE_ID: 'device.id',
    /**
    * The model identifier for the device.
    *
    * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
    */
    DEVICE_MODEL_IDENTIFIER: 'device.model.identifier',
    /**
    * The marketing name for the device model.
    *
    * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
    */
    DEVICE_MODEL_NAME: 'device.model.name',
    /**
    * The name of the single function that this runtime instance executes.
    *
    * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
    */
    FAAS_NAME: 'faas.name',
    /**
    * The unique ID of the single function that this runtime instance executes.
    *
    * Note: Depending on the cloud provider, use:
  
  * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
  Take care not to use the &#34;invoked ARN&#34; directly but replace any
  [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
  different aliases.
  * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
  * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
  
  On some providers, it may not be possible to determine the full ID at startup,
  which is why this field cannot be made required. For example, on AWS the account ID
  part of the ARN is not available without calling another AWS API
  which may be deemed too slow for a short-running lambda function.
  As an alternative, consider setting `faas.id` as a span attribute instead.
    */
    FAAS_ID: 'faas.id',
    /**
    * The immutable version of the function being executed.
    *
    * Note: Depending on the cloud provider and platform, use:
  
  * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
    (an integer represented as a decimal string).
  * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
    (i.e., the function name plus the revision suffix).
  * **Google Cloud Functions:** The value of the
    [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
  * **Azure Functions:** Not applicable. Do not set this attribute.
    */
    FAAS_VERSION: 'faas.version',
    /**
    * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
    *
    * Note: * **AWS Lambda:** Use the (full) log stream name.
    */
    FAAS_INSTANCE: 'faas.instance',
    /**
    * The amount of memory available to the serverless function in MiB.
    *
    * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
    */
    FAAS_MAX_MEMORY: 'faas.max_memory',
    /**
    * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
    */
    HOST_ID: 'host.id',
    /**
    * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
    */
    HOST_NAME: 'host.name',
    /**
    * Type of host. For Cloud, this must be the machine type.
    */
    HOST_TYPE: 'host.type',
    /**
    * The CPU architecture the host system is running on.
    */
    HOST_ARCH: 'host.arch',
    /**
    * Name of the VM image or OS install the host was instantiated from.
    */
    HOST_IMAGE_NAME: 'host.image.name',
    /**
    * VM image ID. For Cloud, this value is from the provider.
    */
    HOST_IMAGE_ID: 'host.image.id',
    /**
    * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
    */
    HOST_IMAGE_VERSION: 'host.image.version',
    /**
    * The name of the cluster.
    */
    K8S_CLUSTER_NAME: 'k8s.cluster.name',
    /**
    * The name of the Node.
    */
    K8S_NODE_NAME: 'k8s.node.name',
    /**
    * The UID of the Node.
    */
    K8S_NODE_UID: 'k8s.node.uid',
    /**
    * The name of the namespace that the pod is running in.
    */
    K8S_NAMESPACE_NAME: 'k8s.namespace.name',
    /**
    * The UID of the Pod.
    */
    K8S_POD_UID: 'k8s.pod.uid',
    /**
    * The name of the Pod.
    */
    K8S_POD_NAME: 'k8s.pod.name',
    /**
    * The name of the Container in a Pod template.
    */
    K8S_CONTAINER_NAME: 'k8s.container.name',
    /**
    * The UID of the ReplicaSet.
    */
    K8S_REPLICASET_UID: 'k8s.replicaset.uid',
    /**
    * The name of the ReplicaSet.
    */
    K8S_REPLICASET_NAME: 'k8s.replicaset.name',
    /**
    * The UID of the Deployment.
    */
    K8S_DEPLOYMENT_UID: 'k8s.deployment.uid',
    /**
    * The name of the Deployment.
    */
    K8S_DEPLOYMENT_NAME: 'k8s.deployment.name',
    /**
    * The UID of the StatefulSet.
    */
    K8S_STATEFULSET_UID: 'k8s.statefulset.uid',
    /**
    * The name of the StatefulSet.
    */
    K8S_STATEFULSET_NAME: 'k8s.statefulset.name',
    /**
    * The UID of the DaemonSet.
    */
    K8S_DAEMONSET_UID: 'k8s.daemonset.uid',
    /**
    * The name of the DaemonSet.
    */
    K8S_DAEMONSET_NAME: 'k8s.daemonset.name',
    /**
    * The UID of the Job.
    */
    K8S_JOB_UID: 'k8s.job.uid',
    /**
    * The name of the Job.
    */
    K8S_JOB_NAME: 'k8s.job.name',
    /**
    * The UID of the CronJob.
    */
    K8S_CRONJOB_UID: 'k8s.cronjob.uid',
    /**
    * The name of the CronJob.
    */
    K8S_CRONJOB_NAME: 'k8s.cronjob.name',
    /**
    * The operating system type.
    */
    OS_TYPE: 'os.type',
    /**
    * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
    */
    OS_DESCRIPTION: 'os.description',
    /**
    * Human readable operating system name.
    */
    OS_NAME: 'os.name',
    /**
    * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
    */
    OS_VERSION: 'os.version',
    /**
    * Process identifier (PID).
    */
    PROCESS_PID: 'process.pid',
    /**
    * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_NAME: 'process.executable.name',
    /**
    * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
    */
    PROCESS_EXECUTABLE_PATH: 'process.executable.path',
    /**
    * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
    */
    PROCESS_COMMAND: 'process.command',
    /**
    * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
    */
    PROCESS_COMMAND_LINE: 'process.command_line',
    /**
    * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
    */
    PROCESS_COMMAND_ARGS: 'process.command_args',
    /**
    * The username of the user that owns the process.
    */
    PROCESS_OWNER: 'process.owner',
    /**
    * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
    */
    PROCESS_RUNTIME_NAME: 'process.runtime.name',
    /**
    * The version of the runtime of this process, as returned by the runtime without modification.
    */
    PROCESS_RUNTIME_VERSION: 'process.runtime.version',
    /**
    * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
    */
    PROCESS_RUNTIME_DESCRIPTION: 'process.runtime.description',
    /**
    * Logical name of the service.
    *
    * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
    */
    SERVICE_NAME: 'service.name',
    /**
    * A namespace for `service.name`.
    *
    * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
    */
    SERVICE_NAMESPACE: 'service.namespace',
    /**
    * The string ID of the service instance.
    *
    * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
    */
    SERVICE_INSTANCE_ID: 'service.instance.id',
    /**
    * The version string of the service API or implementation.
    */
    SERVICE_VERSION: 'service.version',
    /**
    * The name of the telemetry SDK as defined above.
    */
    TELEMETRY_SDK_NAME: 'telemetry.sdk.name',
    /**
    * The language of the telemetry SDK.
    */
    TELEMETRY_SDK_LANGUAGE: 'telemetry.sdk.language',
    /**
    * The version string of the telemetry SDK.
    */
    TELEMETRY_SDK_VERSION: 'telemetry.sdk.version',
    /**
    * The version string of the auto instrumentation agent, if used.
    */
    TELEMETRY_AUTO_VERSION: 'telemetry.auto.version',
    /**
    * The name of the web engine.
    */
    WEBENGINE_NAME: 'webengine.name',
    /**
    * The version of the web engine.
    */
    WEBENGINE_VERSION: 'webengine.version',
    /**
    * Additional description of the web engine (e.g. detailed version and edition information).
    */
    WEBENGINE_DESCRIPTION: 'webengine.description',
};
var build_esm_resource_SemanticResourceAttributes_CloudProviderValues = {
    /** Alibaba Cloud. */
    ALIBABA_CLOUD: 'alibaba_cloud',
    /** Amazon Web Services. */
    AWS: 'aws',
    /** Microsoft Azure. */
    AZURE: 'azure',
    /** Google Cloud Platform. */
    GCP: 'gcp',
};
var build_esm_resource_SemanticResourceAttributes_CloudPlatformValues = {
    /** Alibaba Cloud Elastic Compute Service. */
    ALIBABA_CLOUD_ECS: 'alibaba_cloud_ecs',
    /** Alibaba Cloud Function Compute. */
    ALIBABA_CLOUD_FC: 'alibaba_cloud_fc',
    /** AWS Elastic Compute Cloud. */
    AWS_EC2: 'aws_ec2',
    /** AWS Elastic Container Service. */
    AWS_ECS: 'aws_ecs',
    /** AWS Elastic Kubernetes Service. */
    AWS_EKS: 'aws_eks',
    /** AWS Lambda. */
    AWS_LAMBDA: 'aws_lambda',
    /** AWS Elastic Beanstalk. */
    AWS_ELASTIC_BEANSTALK: 'aws_elastic_beanstalk',
    /** Azure Virtual Machines. */
    AZURE_VM: 'azure_vm',
    /** Azure Container Instances. */
    AZURE_CONTAINER_INSTANCES: 'azure_container_instances',
    /** Azure Kubernetes Service. */
    AZURE_AKS: 'azure_aks',
    /** Azure Functions. */
    AZURE_FUNCTIONS: 'azure_functions',
    /** Azure App Service. */
    AZURE_APP_SERVICE: 'azure_app_service',
    /** Google Cloud Compute Engine (GCE). */
    GCP_COMPUTE_ENGINE: 'gcp_compute_engine',
    /** Google Cloud Run. */
    GCP_CLOUD_RUN: 'gcp_cloud_run',
    /** Google Cloud Kubernetes Engine (GKE). */
    GCP_KUBERNETES_ENGINE: 'gcp_kubernetes_engine',
    /** Google Cloud Functions (GCF). */
    GCP_CLOUD_FUNCTIONS: 'gcp_cloud_functions',
    /** Google Cloud App Engine (GAE). */
    GCP_APP_ENGINE: 'gcp_app_engine',
};
var build_esm_resource_SemanticResourceAttributes_AwsEcsLaunchtypeValues = {
    /** ec2. */
    EC2: 'ec2',
    /** fargate. */
    FARGATE: 'fargate',
};
var build_esm_resource_SemanticResourceAttributes_HostArchValues = {
    /** AMD64. */
    AMD64: 'amd64',
    /** ARM32. */
    ARM32: 'arm32',
    /** ARM64. */
    ARM64: 'arm64',
    /** Itanium. */
    IA64: 'ia64',
    /** 32-bit PowerPC. */
    PPC32: 'ppc32',
    /** 64-bit PowerPC. */
    PPC64: 'ppc64',
    /** 32-bit x86. */
    X86: 'x86',
};
var build_esm_resource_SemanticResourceAttributes_OsTypeValues = {
    /** Microsoft Windows. */
    WINDOWS: 'windows',
    /** Linux. */
    LINUX: 'linux',
    /** Apple Darwin. */
    DARWIN: 'darwin',
    /** FreeBSD. */
    FREEBSD: 'freebsd',
    /** NetBSD. */
    NETBSD: 'netbsd',
    /** OpenBSD. */
    OPENBSD: 'openbsd',
    /** DragonFly BSD. */
    DRAGONFLYBSD: 'dragonflybsd',
    /** HP-UX (Hewlett Packard Unix). */
    HPUX: 'hpux',
    /** AIX (Advanced Interactive eXecutive). */
    AIX: 'aix',
    /** Oracle Solaris. */
    SOLARIS: 'solaris',
    /** IBM z/OS. */
    Z_OS: 'z_os',
};
var build_esm_resource_SemanticResourceAttributes_TelemetrySdkLanguageValues = {
    /** cpp. */
    CPP: 'cpp',
    /** dotnet. */
    DOTNET: 'dotnet',
    /** erlang. */
    ERLANG: 'erlang',
    /** go. */
    GO: 'go',
    /** java. */
    JAVA: 'java',
    /** nodejs. */
    NODEJS: 'nodejs',
    /** php. */
    PHP: 'php',
    /** python. */
    PYTHON: 'python',
    /** ruby. */
    RUBY: 'ruby',
    /** webjs. */
    WEBJS: 'webjs',
};
//# sourceMappingURL=SemanticResourceAttributes.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/platform/browser/sdk-info.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var esm_platform_browser_sdk_info_a;


/** Constants describing the SDK in use */
var esm_platform_browser_sdk_info_SDK_INFO = (esm_platform_browser_sdk_info_a = {},
    esm_platform_browser_sdk_info_a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_NAME] = 'opentelemetry',
    esm_platform_browser_sdk_info_a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = 'browser',
    esm_platform_browser_sdk_info_a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = build_esm_resource_SemanticResourceAttributes_TelemetrySdkLanguageValues.WEBJS,
    esm_platform_browser_sdk_info_a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = _opentelemetry_core_build_esm_version_VERSION,
    esm_platform_browser_sdk_info_a);
//# sourceMappingURL=sdk-info.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/platform/browser/timer-util.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function timer_util_unrefTimer(_timer) { }
//# sourceMappingURL=timer-util.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/platform/browser/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/common/time.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var build_esm_common_time_NANOSECOND_DIGITS = 9;
var build_esm_common_time_SECOND_TO_NANOSECONDS = Math.pow(10, build_esm_common_time_NANOSECOND_DIGITS);
/**
 * Converts a number to HrTime, HrTime = [number, number].
 * The first number is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * numberToHrtime calculates the first number by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * numberToHrtime calculates the second number by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * SECOND_TO_NANOSECONDS = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 * @param epochMillis
 */
function build_esm_common_time_numberToHrtime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Number((epochSeconds - seconds).toFixed(build_esm_common_time_NANOSECOND_DIGITS)) *
        build_esm_common_time_SECOND_TO_NANOSECONDS;
    return [seconds, nanos];
}
function build_esm_common_time_getTimeOrigin() {
    var timeOrigin = esm_platform_browser_performance_otperformance.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = esm_platform_browser_performance_otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function build_esm_common_time_hrTime(performanceNow) {
    var timeOrigin = build_esm_common_time_numberToHrtime(build_esm_common_time_getTimeOrigin());
    var now = build_esm_common_time_numberToHrtime(typeof performanceNow === 'number' ? performanceNow : esm_platform_browser_performance_otperformance.now());
    var seconds = timeOrigin[0] + now[0];
    var nanos = timeOrigin[1] + now[1];
    // Nanoseconds
    if (nanos > build_esm_common_time_SECOND_TO_NANOSECONDS) {
        nanos -= build_esm_common_time_SECOND_TO_NANOSECONDS;
        seconds += 1;
    }
    return [seconds, nanos];
}
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */
function build_esm_common_time_timeInputToHrTime(time) {
    // process.hrtime
    if (build_esm_common_time_isTimeInputHrTime(time)) {
        return time;
    }
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < build_esm_common_time_getTimeOrigin()) {
            return build_esm_common_time_hrTime(time);
        }
        else {
            // epoch milliseconds or performance.timeOrigin
            return build_esm_common_time_numberToHrtime(time);
        }
    }
    else if (time instanceof Date) {
        return build_esm_common_time_numberToHrtime(time.getTime());
    }
    else {
        throw TypeError('Invalid input type');
    }
}
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */
function build_esm_common_time_hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += build_esm_common_time_SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
}
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */
function build_esm_common_time_hrTimeToTimeStamp(time) {
    var precision = build_esm_common_time_NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substr(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */
function core_build_esm_common_time_hrTimeToNanoseconds(time) {
    return time[0] * build_esm_common_time_SECOND_TO_NANOSECONDS + time[1];
}
/**
 * Convert hrTime to milliseconds.
 * @param time
 */
function build_esm_common_time_hrTimeToMilliseconds(time) {
    return Math.round(time[0] * 1e3 + time[1] / 1e6);
}
/**
 * Convert hrTime to microseconds.
 * @param time
 */
function build_esm_common_time_hrTimeToMicroseconds(time) {
    return Math.round(time[0] * 1e6 + time[1] / 1e3);
}
/**
 * check if time is HrTime
 * @param value
 */
function build_esm_common_time_isTimeInputHrTime(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        typeof value[0] === 'number' &&
        typeof value[1] === 'number');
}
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */
function build_esm_common_time_isTimeInput(value) {
    return (build_esm_common_time_isTimeInputHrTime(value) ||
        typeof value === 'number' ||
        value instanceof Date);
}
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/ExportResult.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var core_build_esm_ExportResult_ExportResultCode;
(function (ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(core_build_esm_ExportResult_ExportResultCode || (core_build_esm_ExportResult_ExportResultCode = {}));
//# sourceMappingURL=ExportResult.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/propagation/composite.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var core_build_esm_propagation_composite_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

/** Combines multiple propagators into a single propagator. */
var build_esm_propagation_composite_CompositePropagator = /** @class */ (function () {
    /**
     * Construct a composite propagator from a list of propagators.
     *
     * @param [config] Configuration object for composite propagator
     */
    function CompositePropagator(config) {
        if (config === void 0) { config = {}; }
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators
            // older propagators may not have fields function, null check to be sure
            .map(function (p) { return (typeof p.fields === 'function' ? p.fields() : []); })
            .reduce(function (x, y) { return x.concat(y); }, [])));
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same carrier key, the propagator later in the list
     * will "win".
     *
     * @param context Context to inject
     * @param carrier Carrier into which context will be injected
     */
    CompositePropagator.prototype.inject = function (context, carrier, setter) {
        var e_1, _a;
        try {
            for (var _b = core_build_esm_propagation_composite_values(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propagator = _c.value;
                try {
                    propagator.inject(context, carrier, setter);
                }
                catch (err) {
                    esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same context key, the propagator later in the list
     * will "win".
     *
     * @param context Context to add values to
     * @param carrier Carrier from which to extract context
     */
    CompositePropagator.prototype.extract = function (context, carrier, getter) {
        return this._propagators.reduce(function (ctx, propagator) {
            try {
                return propagator.extract(ctx, carrier, getter);
            }
            catch (err) {
                esm_diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
            return ctx;
        }, context);
    };
    CompositePropagator.prototype.fields = function () {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
    };
    return CompositePropagator;
}());

//# sourceMappingURL=composite.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/internal/validators.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var core_build_esm_internal_validators_VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var core_build_esm_internal_validators_VALID_KEY = "[a-z]" + core_build_esm_internal_validators_VALID_KEY_CHAR_RANGE + "{0,255}";
var core_build_esm_internal_validators_VALID_VENDOR_KEY = "[a-z0-9]" + core_build_esm_internal_validators_VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + core_build_esm_internal_validators_VALID_KEY_CHAR_RANGE + "{0,13}";
var core_build_esm_internal_validators_VALID_KEY_REGEX = new RegExp("^(?:" + core_build_esm_internal_validators_VALID_KEY + "|" + core_build_esm_internal_validators_VALID_VENDOR_KEY + ")$");
var core_build_esm_internal_validators_VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var core_build_esm_internal_validators_INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */
function core_build_esm_internal_validators_validateKey(key) {
    return core_build_esm_internal_validators_VALID_KEY_REGEX.test(key);
}
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */
function core_build_esm_internal_validators_validateValue(value) {
    return (core_build_esm_internal_validators_VALID_VALUE_BASE_REGEX.test(value) &&
        !core_build_esm_internal_validators_INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));
}
//# sourceMappingURL=validators.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/trace/TraceState.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var core_build_esm_trace_TraceState_MAX_TRACE_STATE_ITEMS = 32;
var core_build_esm_trace_TraceState_MAX_TRACE_STATE_LEN = 512;
var core_build_esm_trace_TraceState_LIST_MEMBERS_SEPARATOR = ',';
var core_build_esm_trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */
var build_esm_trace_TraceState_TraceState = /** @class */ (function () {
    function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState)
            this._parse(rawTraceState);
    }
    TraceState.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
            traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceState.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceState.prototype.get = function (key) {
        return this._internalState.get(key);
    };
    TraceState.prototype.serialize = function () {
        var _this = this;
        return this._keys()
            .reduce(function (agg, key) {
            agg.push(key + core_build_esm_trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, [])
            .join(core_build_esm_trace_TraceState_LIST_MEMBERS_SEPARATOR);
    };
    TraceState.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > core_build_esm_trace_TraceState_MAX_TRACE_STATE_LEN)
            return;
        this._internalState = rawTraceState
            .split(core_build_esm_trace_TraceState_LIST_MEMBERS_SEPARATOR)
            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
            .reduce(function (agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(core_build_esm_trace_TraceState_LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if (core_build_esm_internal_validators_validateKey(key) && core_build_esm_internal_validators_validateValue(value)) {
                    agg.set(key, value);
                }
                else {
                    // TODO: Consider to add warning log
                }
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > core_build_esm_trace_TraceState_MAX_TRACE_STATE_ITEMS) {
            this._internalState = new Map(Array.from(this._internalState.entries())
                .reverse() // Use reverse same as original tracestate parse chain
                .slice(0, core_build_esm_trace_TraceState_MAX_TRACE_STATE_ITEMS));
        }
    };
    TraceState.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceState.prototype._clone = function () {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceState;
}());

//# sourceMappingURL=TraceState.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var build_esm_trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER = 'traceparent';
var build_esm_trace_W3CTraceContextPropagator_TRACE_STATE_HEADER = 'tracestate';
var core_build_esm_trace_W3CTraceContextPropagator_VERSION = '00';
var build_esm_trace_W3CTraceContextPropagator_VERSION_PART = '(?!ff)[\\da-f]{2}';
var build_esm_trace_W3CTraceContextPropagator_TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
var build_esm_trace_W3CTraceContextPropagator_PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
var build_esm_trace_W3CTraceContextPropagator_FLAGS_PART = '[\\da-f]{2}';
var build_esm_trace_W3CTraceContextPropagator_TRACE_PARENT_REGEX = new RegExp("^\\s?(" + build_esm_trace_W3CTraceContextPropagator_VERSION_PART + ")-(" + build_esm_trace_W3CTraceContextPropagator_TRACE_ID_PART + ")-(" + build_esm_trace_W3CTraceContextPropagator_PARENT_ID_PART + ")-(" + build_esm_trace_W3CTraceContextPropagator_FLAGS_PART + ")(-.*)?\\s?$");
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */
function build_esm_trace_W3CTraceContextPropagator_parseTraceParent(traceParent) {
    var match = build_esm_trace_W3CTraceContextPropagator_TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
        return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5])
        return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16),
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */
var build_esm_trace_W3CTraceContextPropagator_W3CTraceContextPropagator = /** @class */ (function () {
    function W3CTraceContextPropagator() {
    }
    W3CTraceContextPropagator.prototype.inject = function (context, carrier, setter) {
        var spanContext = trace.getSpanContext(context);
        if (!spanContext ||
            build_esm_trace_suppress_tracing_isTracingSuppressed(context) ||
            !isSpanContextValid(spanContext))
            return;
        var traceParent = core_build_esm_trace_W3CTraceContextPropagator_VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, build_esm_trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
            setter.set(carrier, build_esm_trace_W3CTraceContextPropagator_TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
    };
    W3CTraceContextPropagator.prototype.extract = function (context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, build_esm_trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER);
        if (!traceParentHeader)
            return context;
        var traceParent = Array.isArray(traceParentHeader)
            ? traceParentHeader[0]
            : traceParentHeader;
        if (typeof traceParent !== 'string')
            return context;
        var spanContext = build_esm_trace_W3CTraceContextPropagator_parseTraceParent(traceParent);
        if (!spanContext)
            return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, build_esm_trace_W3CTraceContextPropagator_TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            var state = Array.isArray(traceStateHeader)
                ? traceStateHeader.join(',')
                : traceStateHeader;
            spanContext.traceState = new build_esm_trace_TraceState_TraceState(typeof state === 'string' ? state : undefined);
        }
        return trace.setSpanContext(context, spanContext);
    };
    W3CTraceContextPropagator.prototype.fields = function () {
        return [build_esm_trace_W3CTraceContextPropagator_TRACE_PARENT_HEADER, build_esm_trace_W3CTraceContextPropagator_TRACE_STATE_HEADER];
    };
    return W3CTraceContextPropagator;
}());

//# sourceMappingURL=W3CTraceContextPropagator.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var esm_trace_rpc_metadata_RPC_METADATA_KEY = createContextKey('OpenTelemetry SDK Context Key RPC_METADATA');
var esm_trace_rpc_metadata_RPCType;
(function (RPCType) {
    RPCType["HTTP"] = "http";
})(esm_trace_rpc_metadata_RPCType || (esm_trace_rpc_metadata_RPCType = {}));
function esm_trace_rpc_metadata_setRPCMetadata(context, meta) {
    return context.setValue(esm_trace_rpc_metadata_RPC_METADATA_KEY, meta);
}
function esm_trace_rpc_metadata_deleteRPCMetadata(context) {
    return context.deleteValue(esm_trace_rpc_metadata_RPC_METADATA_KEY);
}
function esm_trace_rpc_metadata_getRPCMetadata(context) {
    return context.getValue(esm_trace_rpc_metadata_RPC_METADATA_KEY);
}
//# sourceMappingURL=rpc-metadata.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples no traces.
 */
var esm_trace_sampler_AlwaysOffSampler_AlwaysOffSampler = /** @class */ (function () {
    function AlwaysOffSampler() {
    }
    AlwaysOffSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.NOT_RECORD,
        };
    };
    AlwaysOffSampler.prototype.toString = function () {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}());

//# sourceMappingURL=AlwaysOffSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples all traces.
 */
var esm_trace_sampler_AlwaysOnSampler_AlwaysOnSampler = /** @class */ (function () {
    function AlwaysOnSampler() {
    }
    AlwaysOnSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.RECORD_AND_SAMPLED,
        };
    };
    AlwaysOnSampler.prototype.toString = function () {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}());

//# sourceMappingURL=AlwaysOnSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */
var esm_trace_sampler_ParentBasedSampler_ParentBasedSampler = /** @class */ (function () {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            build_esm_common_global_error_handler_globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new esm_trace_sampler_AlwaysOnSampler_AlwaysOnSampler();
        }
        this._remoteParentSampled =
            (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new esm_trace_sampler_AlwaysOnSampler_AlwaysOnSampler();
        this._remoteParentNotSampled =
            (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new esm_trace_sampler_AlwaysOffSampler_AlwaysOffSampler();
        this._localParentSampled =
            (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new esm_trace_sampler_AlwaysOnSampler_AlwaysOnSampler();
        this._localParentNotSampled =
            (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new esm_trace_sampler_AlwaysOffSampler_AlwaysOffSampler();
    }
    ParentBasedSampler.prototype.shouldSample = function (context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
            return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & TraceFlags.SAMPLED) {
                return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            }
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function () {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}());

//# sourceMappingURL=ParentBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples a given fraction of traces based of trace id deterministically.
 */
var esm_trace_sampler_TraceIdRatioBasedSampler_TraceIdRatioBasedSampler = /** @class */ (function () {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === void 0) { _ratio = 0; }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function (context, traceId) {
        return {
            decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound
                ? SamplingDecision.RECORD_AND_SAMPLED
                : SamplingDecision.NOT_RECORD,
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function () {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function (ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio))
            return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function (traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}());

//# sourceMappingURL=TraceIdRatioBasedSampler.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * based on lodash in order to support esm builds without esModuleInterop.
 * lodash is using MIT License.
 **/
var build_esm_utils_lodash_merge_objectTag = '[object Object]';
var build_esm_utils_lodash_merge_nullTag = '[object Null]';
var build_esm_utils_lodash_merge_undefinedTag = '[object Undefined]';
var build_esm_utils_lodash_merge_funcProto = Function.prototype;
var build_esm_utils_lodash_merge_funcToString = build_esm_utils_lodash_merge_funcProto.toString;
var build_esm_utils_lodash_merge_objectCtorString = build_esm_utils_lodash_merge_funcToString.call(Object);
var build_esm_utils_lodash_merge_getPrototype = build_esm_utils_lodash_merge_overArg(Object.getPrototypeOf, Object);
var build_esm_utils_lodash_merge_objectProto = Object.prototype;
var core_build_esm_utils_lodash_merge_hasOwnProperty = build_esm_utils_lodash_merge_objectProto.hasOwnProperty;
var build_esm_utils_lodash_merge_symToStringTag = Symbol ? Symbol.toStringTag : undefined;
var build_esm_utils_lodash_merge_nativeObjectToString = build_esm_utils_lodash_merge_objectProto.toString;
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function build_esm_utils_lodash_merge_overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function core_build_esm_utils_lodash_merge_isPlainObject(value) {
    if (!build_esm_utils_lodash_merge_isObjectLike(value) || build_esm_utils_lodash_merge_baseGetTag(value) !== build_esm_utils_lodash_merge_objectTag) {
        return false;
    }
    var proto = build_esm_utils_lodash_merge_getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = core_build_esm_utils_lodash_merge_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        build_esm_utils_lodash_merge_funcToString.call(Ctor) === build_esm_utils_lodash_merge_objectCtorString;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function build_esm_utils_lodash_merge_isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function build_esm_utils_lodash_merge_baseGetTag(value) {
    if (value == null) {
        return value === undefined ? build_esm_utils_lodash_merge_undefinedTag : build_esm_utils_lodash_merge_nullTag;
    }
    return (build_esm_utils_lodash_merge_symToStringTag && build_esm_utils_lodash_merge_symToStringTag in Object(value))
        ? build_esm_utils_lodash_merge_getRawTag(value)
        : build_esm_utils_lodash_merge_objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function build_esm_utils_lodash_merge_getRawTag(value) {
    var isOwn = core_build_esm_utils_lodash_merge_hasOwnProperty.call(value, build_esm_utils_lodash_merge_symToStringTag), tag = value[build_esm_utils_lodash_merge_symToStringTag];
    var unmasked = false;
    try {
        value[build_esm_utils_lodash_merge_symToStringTag] = undefined;
        unmasked = true;
    }
    catch (e) {
        // silence
    }
    var result = build_esm_utils_lodash_merge_nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[build_esm_utils_lodash_merge_symToStringTag] = tag;
        }
        else {
            delete value[build_esm_utils_lodash_merge_symToStringTag];
        }
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function build_esm_utils_lodash_merge_objectToString(value) {
    return build_esm_utils_lodash_merge_nativeObjectToString.call(value);
}
//# sourceMappingURL=lodash.merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/utils/merge.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */

var build_esm_utils_merge_MAX_LEVEL = 20;
/**
 * Merges objects together
 * @param args - objects / values to be merged
 */
function build_esm_utils_merge_merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var result = args.shift();
    var objects = new WeakMap();
    while (args.length > 0) {
        result = build_esm_utils_merge_mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
}
function build_esm_utils_merge_takeValue(value) {
    if (build_esm_utils_merge_isArray(value)) {
        return value.slice();
    }
    return value;
}
/**
 * Merges two objects
 * @param one - first object
 * @param two - second object
 * @param level - current deep level
 * @param objects - objects holder that has been already referenced - to prevent
 * cyclic dependency
 */
function build_esm_utils_merge_mergeTwoObjects(one, two, level, objects) {
    if (level === void 0) { level = 0; }
    var result;
    if (level > build_esm_utils_merge_MAX_LEVEL) {
        return undefined;
    }
    level++;
    if (build_esm_utils_merge_isPrimitive(one) || build_esm_utils_merge_isPrimitive(two) || build_esm_utils_merge_isFunction(two)) {
        result = build_esm_utils_merge_takeValue(two);
    }
    else if (build_esm_utils_merge_isArray(one)) {
        result = one.slice();
        if (build_esm_utils_merge_isArray(two)) {
            for (var i = 0, j = two.length; i < j; i++) {
                result.push(build_esm_utils_merge_takeValue(two[i]));
            }
        }
        else if (build_esm_utils_merge_isObject(two)) {
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                result[key] = build_esm_utils_merge_takeValue(two[key]);
            }
        }
    }
    else if (build_esm_utils_merge_isObject(one)) {
        if (build_esm_utils_merge_isObject(two)) {
            if (!build_esm_utils_merge_shouldMerge(one, two)) {
                return two;
            }
            result = Object.assign({}, one);
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                var twoValue = two[key];
                if (build_esm_utils_merge_isPrimitive(twoValue)) {
                    if (typeof twoValue === 'undefined') {
                        delete result[key];
                    }
                    else {
                        // result[key] = takeValue(twoValue);
                        result[key] = twoValue;
                    }
                }
                else {
                    var obj1 = result[key];
                    var obj2 = twoValue;
                    if (build_esm_utils_merge_wasObjectReferenced(one, key, objects) ||
                        build_esm_utils_merge_wasObjectReferenced(two, key, objects)) {
                        delete result[key];
                    }
                    else {
                        if (build_esm_utils_merge_isObject(obj1) && build_esm_utils_merge_isObject(obj2)) {
                            var arr1 = objects.get(obj1) || [];
                            var arr2 = objects.get(obj2) || [];
                            arr1.push({ obj: one, key: key });
                            arr2.push({ obj: two, key: key });
                            objects.set(obj1, arr1);
                            objects.set(obj2, arr2);
                        }
                        result[key] = build_esm_utils_merge_mergeTwoObjects(result[key], twoValue, level, objects);
                    }
                }
            }
        }
        else {
            result = two;
        }
    }
    return result;
}
/**
 * Function to check if object has been already reference
 * @param obj
 * @param key
 * @param objects
 */
function build_esm_utils_merge_wasObjectReferenced(obj, key, objects) {
    var arr = objects.get(obj[key]) || [];
    for (var i = 0, j = arr.length; i < j; i++) {
        var info = arr[i];
        if (info.key === key && info.obj === obj) {
            return true;
        }
    }
    return false;
}
function build_esm_utils_merge_isArray(value) {
    return Array.isArray(value);
}
function build_esm_utils_merge_isFunction(value) {
    return typeof value === 'function';
}
function build_esm_utils_merge_isObject(value) {
    return !build_esm_utils_merge_isPrimitive(value) && !build_esm_utils_merge_isArray(value) && !build_esm_utils_merge_isFunction(value) && typeof value === 'object';
}
function build_esm_utils_merge_isPrimitive(value) {
    return typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean' ||
        typeof value === 'undefined' ||
        value instanceof Date ||
        value instanceof RegExp ||
        value === null;
}
function build_esm_utils_merge_shouldMerge(one, two) {
    if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
    }
    return true;
}
//# sourceMappingURL=merge.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/utils/url.js
var build_esm_utils_url_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function esm_utils_url_urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === 'string') {
        return url === urlToMatch;
    }
    else {
        return !!url.match(urlToMatch);
    }
}
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */
function esm_utils_url_isUrlIgnored(url, ignoredUrls) {
    var e_1, _a;
    if (!ignoredUrls) {
        return false;
    }
    try {
        for (var ignoredUrls_1 = build_esm_utils_url_values(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
            var ignoreUrl = ignoredUrls_1_1.value;
            if (esm_utils_url_urlMatches(url, ignoreUrl)) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return)) _a.call(ignoredUrls_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}
//# sourceMappingURL=url.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/utils/promise.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var core_build_esm_utils_promise_Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function (val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function (err) {
        this._reject(err);
    };
    return Deferred;
}());

//# sourceMappingURL=promise.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/utils/callback.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var core_build_esm_utils_callback_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var core_build_esm_utils_callback_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */
var build_esm_utils_callback_BindOnceFuture = /** @class */ (function () {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new core_build_esm_utils_promise_Deferred();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function () {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function () {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, core_build_esm_utils_callback_spreadArray([this._that], core_build_esm_utils_callback_read(args), false)))
                    .then(function (val) { return _this._deferred.resolve(val); }, function (err) { return _this._deferred.reject(err); });
            }
            catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}());

//# sourceMappingURL=callback.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





























//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/LastValue.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LastValue_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};



var LastValueAccumulation = /** @class */ (function () {
    function LastValueAccumulation(startTime, _current, sampleTime) {
        if (_current === void 0) { _current = 0; }
        if (sampleTime === void 0) { sampleTime = [0, 0]; }
        this.startTime = startTime;
        this._current = _current;
        this.sampleTime = sampleTime;
    }
    LastValueAccumulation.prototype.record = function (value) {
        this._current = value;
        this.sampleTime = build_esm_common_time_hrTime();
    };
    LastValueAccumulation.prototype.setStartTime = function (startTime) {
        this.startTime = startTime;
    };
    LastValueAccumulation.prototype.toPointValue = function () {
        return this._current;
    };
    return LastValueAccumulation;
}());

/** Basic aggregator which calculates a LastValue from individual measurements. */
var LastValueAggregator = /** @class */ (function () {
    function LastValueAggregator() {
        this.kind = AggregatorKind.LAST_VALUE;
    }
    LastValueAggregator.prototype.createAccumulation = function (startTime) {
        return new LastValueAccumulation(startTime);
    };
    /**
     * Returns the result of the merge of the given accumulations.
     *
     * Return the newly captured (delta) accumulation for LastValueAggregator.
     */
    LastValueAggregator.prototype.merge = function (previous, delta) {
        // nanoseconds may lose precisions.
        var latestAccumulation = build_esm_common_time_hrTimeToMicroseconds(delta.sampleTime) >= build_esm_common_time_hrTimeToMicroseconds(previous.sampleTime) ? delta : previous;
        return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
    };
    /**
     * Returns a new DELTA aggregation by comparing two cumulative measurements.
     *
     * A delta aggregation is not meaningful to LastValueAggregator, just return
     * the newly captured (delta) accumulation for LastValueAggregator.
     */
    LastValueAggregator.prototype.diff = function (previous, current) {
        // nanoseconds may lose precisions.
        var latestAccumulation = build_esm_common_time_hrTimeToMicroseconds(current.sampleTime) >= build_esm_common_time_hrTimeToMicroseconds(previous.sampleTime) ? current : previous;
        return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
    };
    LastValueAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
            descriptor: descriptor,
            aggregationTemporality: aggregationTemporality,
            dataPointType: MetricData_DataPointType.GAUGE,
            dataPoints: accumulationByAttributes.map(function (_a) {
                var _b = LastValue_read(_a, 2), attributes = _b[0], accumulation = _b[1];
                return {
                    attributes: attributes,
                    startTime: accumulation.startTime,
                    endTime: endTime,
                    value: accumulation.toPointValue(),
                };
            })
        };
    };
    return LastValueAggregator;
}());

//# sourceMappingURL=LastValue.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/Sum.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Sum_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};


var SumAccumulation = /** @class */ (function () {
    function SumAccumulation(startTime, monotonic, _current, reset) {
        if (_current === void 0) { _current = 0; }
        if (reset === void 0) { reset = false; }
        this.startTime = startTime;
        this.monotonic = monotonic;
        this._current = _current;
        this.reset = reset;
    }
    SumAccumulation.prototype.record = function (value) {
        if (this.monotonic && value < 0) {
            return;
        }
        this._current += value;
    };
    SumAccumulation.prototype.setStartTime = function (startTime) {
        this.startTime = startTime;
    };
    SumAccumulation.prototype.toPointValue = function () {
        return this._current;
    };
    return SumAccumulation;
}());

/** Basic aggregator which calculates a Sum from individual measurements. */
var SumAggregator = /** @class */ (function () {
    function SumAggregator(monotonic) {
        this.monotonic = monotonic;
        this.kind = AggregatorKind.SUM;
    }
    SumAggregator.prototype.createAccumulation = function (startTime) {
        return new SumAccumulation(startTime, this.monotonic);
    };
    /**
     * Returns the result of the merge of the given accumulations.
     */
    SumAggregator.prototype.merge = function (previous, delta) {
        var prevPv = previous.toPointValue();
        var deltaPv = delta.toPointValue();
        if (delta.reset) {
            return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);
        }
        return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);
    };
    /**
     * Returns a new DELTA aggregation by comparing two cumulative measurements.
     */
    SumAggregator.prototype.diff = function (previous, current) {
        var prevPv = previous.toPointValue();
        var currPv = current.toPointValue();
        /**
         * If the SumAggregator is a monotonic one and the previous point value is
         * greater than the current one, a reset is deemed to be happened.
         * Return the current point value to prevent the value from been reset.
         */
        if (this.monotonic && (prevPv > currPv)) {
            return new SumAccumulation(current.startTime, this.monotonic, currPv, true);
        }
        return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);
    };
    SumAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
            descriptor: descriptor,
            aggregationTemporality: aggregationTemporality,
            dataPointType: MetricData_DataPointType.SUM,
            dataPoints: accumulationByAttributes.map(function (_a) {
                var _b = Sum_read(_a, 2), attributes = _b[0], accumulation = _b[1];
                return {
                    attributes: attributes,
                    startTime: accumulation.startTime,
                    endTime: endTime,
                    value: accumulation.toPointValue(),
                };
            }),
            isMonotonic: this.monotonic
        };
    };
    return SumAggregator;
}());

//# sourceMappingURL=Sum.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/view/Aggregation.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Aggregation_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



/**
 * Configures how measurements are combined into metrics for views.
 *
 * Aggregation provides a set of built-in aggregations via static methods.
 */
var Aggregation = /** @class */ (function () {
    function Aggregation() {
    }
    Aggregation.Drop = function () {
        return DROP_AGGREGATION;
    };
    Aggregation.Sum = function () {
        return SUM_AGGREGATION;
    };
    Aggregation.LastValue = function () {
        return LAST_VALUE_AGGREGATION;
    };
    Aggregation.Histogram = function () {
        return HISTOGRAM_AGGREGATION;
    };
    Aggregation.Default = function () {
        return DEFAULT_AGGREGATION;
    };
    return Aggregation;
}());

/**
 * The default drop aggregation.
 */
var DropAggregation = /** @class */ (function (_super) {
    Aggregation_extends(DropAggregation, _super);
    function DropAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DropAggregation.prototype.createAggregator = function (_instrument) {
        return DropAggregation.DEFAULT_INSTANCE;
    };
    DropAggregation.DEFAULT_INSTANCE = new DropAggregator();
    return DropAggregation;
}(Aggregation));

/**
 * The default sum aggregation.
 */
var SumAggregation = /** @class */ (function (_super) {
    Aggregation_extends(SumAggregation, _super);
    function SumAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SumAggregation.prototype.createAggregator = function (instrument) {
        switch (instrument.type) {
            case InstrumentType.COUNTER:
            case InstrumentType.OBSERVABLE_COUNTER:
            case InstrumentType.HISTOGRAM: {
                return SumAggregation.MONOTONIC_INSTANCE;
            }
            default: {
                return SumAggregation.NON_MONOTONIC_INSTANCE;
            }
        }
    };
    SumAggregation.MONOTONIC_INSTANCE = new SumAggregator(true);
    SumAggregation.NON_MONOTONIC_INSTANCE = new SumAggregator(false);
    return SumAggregation;
}(Aggregation));

/**
 * The default last value aggregation.
 */
var LastValueAggregation = /** @class */ (function (_super) {
    Aggregation_extends(LastValueAggregation, _super);
    function LastValueAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LastValueAggregation.prototype.createAggregator = function (_instrument) {
        return LastValueAggregation.DEFAULT_INSTANCE;
    };
    LastValueAggregation.DEFAULT_INSTANCE = new LastValueAggregator();
    return LastValueAggregation;
}(Aggregation));

/**
 * The default histogram aggregation.
 */
var HistogramAggregation = /** @class */ (function (_super) {
    Aggregation_extends(HistogramAggregation, _super);
    function HistogramAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HistogramAggregation.prototype.createAggregator = function (_instrument) {
        return HistogramAggregation.DEFAULT_INSTANCE;
    };
    HistogramAggregation.DEFAULT_INSTANCE = new HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 1000], true);
    return HistogramAggregation;
}(Aggregation));

/**
 * The explicit bucket histogram aggregation.
 */
var ExplicitBucketHistogramAggregation = /** @class */ (function (_super) {
    Aggregation_extends(ExplicitBucketHistogramAggregation, _super);
    /**
     * @param boundaries the bucket boundaries of the histogram aggregation
     * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
     */
    function ExplicitBucketHistogramAggregation(boundaries, _recordMinMax) {
        if (_recordMinMax === void 0) { _recordMinMax = true; }
        var _this = _super.call(this) || this;
        _this._recordMinMax = _recordMinMax;
        if (boundaries === undefined || boundaries.length === 0) {
            throw new Error('HistogramAggregator should be created with boundaries.');
        }
        // Copy the boundaries array for modification.
        boundaries = boundaries.concat();
        // We need to an ordered set to be able to correctly compute count for each
        // boundary since we'll iterate on each in order.
        boundaries = boundaries.sort(function (a, b) { return a - b; });
        // Remove all Infinity from the boundaries.
        var minusInfinityIndex = boundaries.lastIndexOf(-Infinity);
        var infinityIndex = boundaries.indexOf(Infinity);
        if (infinityIndex === -1) {
            infinityIndex = undefined;
        }
        _this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);
        return _this;
    }
    ExplicitBucketHistogramAggregation.prototype.createAggregator = function (_instrument) {
        return new HistogramAggregator(this._boundaries, this._recordMinMax);
    };
    return ExplicitBucketHistogramAggregation;
}(Aggregation));

/**
 * The default aggregation.
 */
var DefaultAggregation = /** @class */ (function (_super) {
    Aggregation_extends(DefaultAggregation, _super);
    function DefaultAggregation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultAggregation.prototype._resolve = function (instrument) {
        // cast to unknown to disable complaints on the (unreachable) fallback.
        switch (instrument.type) {
            case InstrumentType.COUNTER:
            case InstrumentType.UP_DOWN_COUNTER:
            case InstrumentType.OBSERVABLE_COUNTER:
            case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {
                return SUM_AGGREGATION;
            }
            case InstrumentType.OBSERVABLE_GAUGE: {
                return LAST_VALUE_AGGREGATION;
            }
            case InstrumentType.HISTOGRAM: {
                return HISTOGRAM_AGGREGATION;
            }
        }
        esm_diag.warn("Unable to recognize instrument type: " + instrument.type);
        return DROP_AGGREGATION;
    };
    DefaultAggregation.prototype.createAggregator = function (instrument) {
        return this._resolve(instrument).createAggregator(instrument);
    };
    return DefaultAggregation;
}(Aggregation));

var DROP_AGGREGATION = new DropAggregation();
var SUM_AGGREGATION = new SumAggregation();
var LAST_VALUE_AGGREGATION = new LastValueAggregation();
var HISTOGRAM_AGGREGATION = new HistogramAggregation();
var DEFAULT_AGGREGATION = new DefaultAggregation();
//# sourceMappingURL=Aggregation.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/export/AggregationSelector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var DEFAULT_AGGREGATION_SELECTOR = function (_instrumentType) { return Aggregation.Default(); };
var DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = function (_instrumentType) { return AggregationTemporality_AggregationTemporality.CUMULATIVE; };
//# sourceMappingURL=AggregationSelector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/export/MetricReader.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MetricReader_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var MetricReader_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



/**
 * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global
 * control over metrics.
 */
var MetricReader = /** @class */ (function () {
    function MetricReader(options) {
        var _a, _b;
        // Tracks the shutdown state.
        // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.
        this._shutdown = false;
        this._aggregationSelector = (_a = options === null || options === void 0 ? void 0 : options.aggregationSelector) !== null && _a !== void 0 ? _a : DEFAULT_AGGREGATION_SELECTOR;
        this._aggregationTemporalitySelector = (_b = options === null || options === void 0 ? void 0 : options.aggregationTemporalitySelector) !== null && _b !== void 0 ? _b : DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
    }
    /**
     * Set the {@link MetricProducer} used by this instance.
     *
     * @param metricProducer
     */
    MetricReader.prototype.setMetricProducer = function (metricProducer) {
        if (this._metricProducer) {
            throw new Error('MetricReader can not be bound to a MeterProvider again.');
        }
        this._metricProducer = metricProducer;
        this.onInitialized();
    };
    /**
     * Select the {@link Aggregation} for the given {@link InstrumentType} for this
     * reader.
     */
    MetricReader.prototype.selectAggregation = function (instrumentType) {
        return this._aggregationSelector(instrumentType);
    };
    /**
     * Select the {@link AggregationTemporality} for the given
     * {@link InstrumentType} for this reader.
     */
    MetricReader.prototype.selectAggregationTemporality = function (instrumentType) {
        return this._aggregationTemporalitySelector(instrumentType);
    };
    /**
     * Handle once the SDK has initialized this {@link MetricReader}
     * Overriding this method is optional.
     */
    MetricReader.prototype.onInitialized = function () {
        // Default implementation is empty.
    };
    /**
     * Collect all metrics from the associated {@link MetricProducer}
     */
    MetricReader.prototype.collect = function (options) {
        return MetricReader_awaiter(this, void 0, void 0, function () {
            return MetricReader_generator(this, function (_a) {
                if (this._metricProducer === undefined) {
                    throw new Error('MetricReader is not bound to a MetricProducer');
                }
                // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.
                if (this._shutdown) {
                    throw new Error('MetricReader is shutdown');
                }
                return [2 /*return*/, this._metricProducer.collect({
                        timeoutMillis: options === null || options === void 0 ? void 0 : options.timeoutMillis,
                    })];
            });
        });
    };
    /**
     * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.
     *
     * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
     * @param options options with timeout.
     */
    MetricReader.prototype.shutdown = function (options) {
        return MetricReader_awaiter(this, void 0, void 0, function () {
            return MetricReader_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Do not call shutdown again if it has already been called.
                        if (this._shutdown) {
                            esm_diag.error('Cannot call shutdown twice.');
                            return [2 /*return*/];
                        }
                        if (!((options === null || options === void 0 ? void 0 : options.timeoutMillis) == null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.onShutdown()];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, callWithTimeout(this.onShutdown(), options.timeoutMillis)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        this._shutdown = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.
     *
     * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
     * @param options options with timeout.
     */
    MetricReader.prototype.forceFlush = function (options) {
        return MetricReader_awaiter(this, void 0, void 0, function () {
            return MetricReader_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._shutdown) {
                            esm_diag.warn('Cannot forceFlush on already shutdown MetricReader.');
                            return [2 /*return*/];
                        }
                        if (!((options === null || options === void 0 ? void 0 : options.timeoutMillis) == null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.onForceFlush()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                    case 2: return [4 /*yield*/, callWithTimeout(this.onForceFlush(), options.timeoutMillis)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return MetricReader;
}());

//# sourceMappingURL=MetricReader.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/export/PeriodicExportingMetricReader.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PeriodicExportingMetricReader_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PeriodicExportingMetricReader_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var PeriodicExportingMetricReader_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var PeriodicExportingMetricReader_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var PeriodicExportingMetricReader_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};




/**
 * {@link MetricReader} which collects metrics based on a user-configurable time interval, and passes the metrics to
 * the configured {@link PushMetricExporter}
 */
var PeriodicExportingMetricReader = /** @class */ (function (_super) {
    PeriodicExportingMetricReader_extends(PeriodicExportingMetricReader, _super);
    function PeriodicExportingMetricReader(options) {
        var _a, _b, _c, _d;
        var _this = _super.call(this, {
            aggregationSelector: (_a = options.exporter.selectAggregation) === null || _a === void 0 ? void 0 : _a.bind(options.exporter),
            aggregationTemporalitySelector: (_b = options.exporter.selectAggregationTemporality) === null || _b === void 0 ? void 0 : _b.bind(options.exporter)
        }) || this;
        if (options.exportIntervalMillis !== undefined && options.exportIntervalMillis <= 0) {
            throw Error('exportIntervalMillis must be greater than 0');
        }
        if (options.exportTimeoutMillis !== undefined && options.exportTimeoutMillis <= 0) {
            throw Error('exportTimeoutMillis must be greater than 0');
        }
        if (options.exportTimeoutMillis !== undefined &&
            options.exportIntervalMillis !== undefined &&
            options.exportIntervalMillis < options.exportTimeoutMillis) {
            throw Error('exportIntervalMillis must be greater than or equal to exportTimeoutMillis');
        }
        _this._exportInterval = (_c = options.exportIntervalMillis) !== null && _c !== void 0 ? _c : 60000;
        _this._exportTimeout = (_d = options.exportTimeoutMillis) !== null && _d !== void 0 ? _d : 30000;
        _this._exporter = options.exporter;
        return _this;
    }
    PeriodicExportingMetricReader.prototype._runOnce = function () {
        return PeriodicExportingMetricReader_awaiter(this, void 0, void 0, function () {
            var _a, resourceMetrics, errors;
            var _b;
            var _this = this;
            return PeriodicExportingMetricReader_generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.collect({})];
                    case 1:
                        _a = _c.sent(), resourceMetrics = _a.resourceMetrics, errors = _a.errors;
                        if (errors.length > 0) {
                            (_b = esm_diag).error.apply(_b, PeriodicExportingMetricReader_spreadArray(['PeriodicExportingMetricReader: metrics collection errors'], PeriodicExportingMetricReader_read(errors), false));
                        }
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                _this._exporter.export(resourceMetrics, function (result) {
                                    var _a;
                                    if (result.code !== core_build_esm_ExportResult_ExportResultCode.SUCCESS) {
                                        reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error("PeriodicExportingMetricReader: metrics export failed (error " + result.error + ")"));
                                    }
                                    else {
                                        resolve();
                                    }
                                });
                            })];
                }
            });
        });
    };
    PeriodicExportingMetricReader.prototype.onInitialized = function () {
        var _this = this;
        // start running the interval as soon as this reader is initialized and keep handle for shutdown.
        this._interval = setInterval(function () { return PeriodicExportingMetricReader_awaiter(_this, void 0, void 0, function () {
            var err_1;
            return PeriodicExportingMetricReader_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, callWithTimeout(this._runOnce(), this._exportTimeout)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        err_1 = _a.sent();
                        if (err_1 instanceof TimeoutError) {
                            esm_diag.error('Export took longer than %s milliseconds and timed out.', this._exportTimeout);
                            return [2 /*return*/];
                        }
                        build_esm_common_global_error_handler_globalErrorHandler(err_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        }); }, this._exportInterval);
        timer_util_unrefTimer(this._interval);
    };
    PeriodicExportingMetricReader.prototype.onForceFlush = function () {
        return PeriodicExportingMetricReader_awaiter(this, void 0, void 0, function () {
            return PeriodicExportingMetricReader_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._exporter.forceFlush()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    PeriodicExportingMetricReader.prototype.onShutdown = function () {
        return PeriodicExportingMetricReader_awaiter(this, void 0, void 0, function () {
            return PeriodicExportingMetricReader_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._interval) {
                            clearInterval(this._interval);
                        }
                        return [4 /*yield*/, this._exporter.shutdown()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return PeriodicExportingMetricReader;
}(MetricReader));

//# sourceMappingURL=PeriodicExportingMetricReader.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/export/InMemoryMetricExporter.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * In-memory Metrics Exporter is a Push Metric Exporter
 * which accumulates metrics data in the local memory and
 * allows to inspect it (useful for e.g. unit tests).
 */
var InMemoryMetricExporter = /** @class */ (function () {
    function InMemoryMetricExporter(aggregationTemporality) {
        this._shutdown = false;
        this._metrics = [];
        this._aggregationTemporality = aggregationTemporality;
    }
    /**
     * @inheritedDoc
     */
    InMemoryMetricExporter.prototype.export = function (metrics, resultCallback) {
        // Avoid storing metrics when exporter is shutdown
        if (this._shutdown) {
            setTimeout(function () { return resultCallback({ code: core_build_esm_ExportResult_ExportResultCode.FAILED }); }, 0);
            return;
        }
        this._metrics.push(metrics);
        setTimeout(function () { return resultCallback({ code: core_build_esm_ExportResult_ExportResultCode.SUCCESS }); }, 0);
    };
    /**
     * Returns all the collected resource metrics
     * @returns ResourceMetrics[]
     */
    InMemoryMetricExporter.prototype.getMetrics = function () {
        return this._metrics;
    };
    InMemoryMetricExporter.prototype.forceFlush = function () {
        return Promise.resolve();
    };
    InMemoryMetricExporter.prototype.reset = function () {
        this._metrics = [];
    };
    InMemoryMetricExporter.prototype.selectAggregationTemporality = function (_instrumentType) {
        return this._aggregationTemporality;
    };
    InMemoryMetricExporter.prototype.shutdown = function () {
        this._shutdown = true;
        return Promise.resolve();
    };
    return InMemoryMetricExporter;
}());

//# sourceMappingURL=InMemoryMetricExporter.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/export/ConsoleMetricExporter.js
var ConsoleMetricExporter_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* eslint-disable no-console */
var ConsoleMetricExporter = /** @class */ (function () {
    function ConsoleMetricExporter() {
        this._shutdown = false;
    }
    ConsoleMetricExporter.prototype.export = function (metrics, resultCallback) {
        if (this._shutdown) {
            // If the exporter is shutting down, by spec, we need to return FAILED as export result
            setImmediate(resultCallback, { code: core_build_esm_ExportResult_ExportResultCode.FAILED });
            return;
        }
        return ConsoleMetricExporter._sendMetrics(metrics, resultCallback);
    };
    ConsoleMetricExporter.prototype.forceFlush = function () {
        return Promise.resolve();
    };
    ConsoleMetricExporter.prototype.selectAggregationTemporality = function (_instrumentType) {
        return AggregationTemporality_AggregationTemporality.CUMULATIVE;
    };
    ConsoleMetricExporter.prototype.shutdown = function () {
        this._shutdown = true;
        return Promise.resolve();
    };
    ConsoleMetricExporter._sendMetrics = function (metrics, done) {
        var e_1, _a, e_2, _b;
        try {
            for (var _c = ConsoleMetricExporter_values(metrics.scopeMetrics), _d = _c.next(); !_d.done; _d = _c.next()) {
                var scopeMetrics = _d.value;
                try {
                    for (var _e = (e_2 = void 0, ConsoleMetricExporter_values(scopeMetrics.metrics)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var metric = _f.value;
                        console.dir({
                            descriptor: metric.descriptor,
                            dataPointType: metric.dataPointType,
                            dataPoints: metric.dataPoints
                        });
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        done({ code: core_build_esm_ExportResult_ExportResultCode.SUCCESS });
    };
    return ConsoleMetricExporter;
}());

//# sourceMappingURL=ConsoleMetricExporter.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/platform/browser/default-service-name.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function default_service_name_defaultServiceName() {
    return 'unknown_service';
}
//# sourceMappingURL=default-service-name.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/platform/browser/detect-resources.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var detect_resources_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var detect_resources_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


/**
 * Runs all resource detectors and returns the results merged into a single
 * Resource.
 *
 * @param config Configuration for resource detection
 */
var detectResources = function (config) {
    if (config === void 0) { config = {}; }
    return detect_resources_awaiter(void 0, void 0, void 0, function () {
        var internalConfig, resources;
        return detect_resources_generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    internalConfig = Object.assign(config);
                    return [4 /*yield*/, Promise.all((internalConfig.detectors || []).map(function (d) { return detect_resources_awaiter(void 0, void 0, void 0, function () {
                            var resource, e_1;
                            return detect_resources_generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 2, , 3]);
                                        return [4 /*yield*/, d.detect(internalConfig)];
                                    case 1:
                                        resource = _a.sent();
                                        diag.debug(d.constructor.name + " found resource.", resource);
                                        return [2 /*return*/, resource];
                                    case 2:
                                        e_1 = _a.sent();
                                        diag.debug(d.constructor.name + " failed: " + e_1.message);
                                        return [2 /*return*/, Resource.empty()];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 1:
                    resources = _a.sent();
                    return [2 /*return*/, resources.reduce(function (acc, resource) { return acc.merge(resource); }, Resource.empty())];
            }
        });
    });
};
//# sourceMappingURL=detect-resources.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/detectors/NoopDetector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NoopDetector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var NoopDetector_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var NoopDetector = /** @class */ (function () {
    function NoopDetector() {
    }
    NoopDetector.prototype.detect = function () {
        return NoopDetector_awaiter(this, void 0, void 0, function () {
            return NoopDetector_generator(this, function (_a) {
                return [2 /*return*/, new esm_Resource_Resource({})];
            });
        });
    };
    return NoopDetector;
}());

var NoopDetector_noopDetector = new NoopDetector();
//# sourceMappingURL=NoopDetector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/platform/browser/HostDetector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var hostDetector = (/* unused pure expression or super */ null && (noopDetector));
//# sourceMappingURL=HostDetector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/platform/browser/OSDetector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var osDetector = (/* unused pure expression or super */ null && (noopDetector));
//# sourceMappingURL=OSDetector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/platform/browser/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/Resource.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * A Resource describes the entity for which a signals (metrics or trace) are
 * collected.
 */
var esm_Resource_Resource = /** @class */ (function () {
    function Resource(
    /**
     * A dictionary of attributes with string keys and values that provide
     * information about the entity as numbers, strings or booleans
     * TODO: Consider to add check/validation on attributes.
     */
    attributes) {
        this.attributes = attributes;
    }
    /**
     * Returns an empty Resource
     */
    Resource.empty = function () {
        return Resource.EMPTY;
    };
    /**
     * Returns a Resource that indentifies the SDK in use.
     */
    Resource.default = function () {
        var _a;
        return new Resource((_a = {},
            _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.SERVICE_NAME] = default_service_name_defaultServiceName(),
            _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = esm_platform_browser_sdk_info_SDK_INFO[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE],
            _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_NAME] = esm_platform_browser_sdk_info_SDK_INFO[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_NAME],
            _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = esm_platform_browser_sdk_info_SDK_INFO[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.TELEMETRY_SDK_VERSION],
            _a));
    };
    /**
     * Returns a new, merged {@link Resource} by merging the current Resource
     * with the other Resource. In case of a collision, other Resource takes
     * precedence.
     *
     * @param other the Resource that will be merged with this.
     * @returns the newly merged Resource.
     */
    Resource.prototype.merge = function (other) {
        if (!other || !Object.keys(other.attributes).length)
            return this;
        // SpanAttributes from resource overwrite attributes from other resource.
        var mergedAttributes = Object.assign({}, this.attributes, other.attributes);
        return new Resource(mergedAttributes);
    };
    Resource.EMPTY = new Resource({});
    return Resource;
}());

//# sourceMappingURL=Resource.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/detectors/BrowserDetector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BrowserDetector_assign = (undefined && undefined.__assign) || function () {
    BrowserDetector_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return BrowserDetector_assign.apply(this, arguments);
};
var BrowserDetector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var BrowserDetector_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



/**
 * BrowserDetector will be used to detect the resources related to browser.
 */
var BrowserDetector = /** @class */ (function () {
    function BrowserDetector() {
    }
    BrowserDetector.prototype.detect = function (config) {
        return BrowserDetector_awaiter(this, void 0, void 0, function () {
            var isBrowser, browserResource;
            var _a;
            return BrowserDetector_generator(this, function (_b) {
                isBrowser = typeof navigator !== 'undefined';
                if (!isBrowser) {
                    return [2 /*return*/, esm_Resource_Resource.empty()];
                }
                browserResource = (_a = {},
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = 'browser',
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = 'Web Browser',
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = navigator.userAgent,
                    _a);
                return [2 /*return*/, this._getResourceAttributes(browserResource, config)];
            });
        });
    };
    /**
     * Validates process resource attribute map from process variables
     *
     * @param browserResource The un-sanitized resource attributes from process as key/value pairs.
     * @param config: Config
     * @returns The sanitized resource attributes.
     */
    BrowserDetector.prototype._getResourceAttributes = function (browserResource, _config) {
        if (browserResource[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === '') {
            esm_diag.debug('BrowserDetector failed: Unable to find required browser resources. ');
            return esm_Resource_Resource.empty();
        }
        else {
            return new esm_Resource_Resource(BrowserDetector_assign({}, browserResource));
        }
    };
    return BrowserDetector;
}());
var browserDetector = new BrowserDetector();
//# sourceMappingURL=BrowserDetector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/detectors/EnvDetector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EnvDetector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var EnvDetector_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var EnvDetector_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var EnvDetector_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};




/**
 * EnvDetector can be used to detect the presence of and create a Resource
 * from the OTEL_RESOURCE_ATTRIBUTES environment variable.
 */
var EnvDetector = /** @class */ (function () {
    function EnvDetector() {
        // Type, attribute keys, and attribute values should not exceed 256 characters.
        this._MAX_LENGTH = 255;
        // OTEL_RESOURCE_ATTRIBUTES is a comma-separated list of attributes.
        this._COMMA_SEPARATOR = ',';
        // OTEL_RESOURCE_ATTRIBUTES contains key value pair separated by '='.
        this._LABEL_KEY_VALUE_SPLITTER = '=';
        this._ERROR_MESSAGE_INVALID_CHARS = 'should be a ASCII string with a length greater than 0 and not exceed ' +
            this._MAX_LENGTH +
            ' characters.';
        this._ERROR_MESSAGE_INVALID_VALUE = 'should be a ASCII string with a length not exceed ' +
            this._MAX_LENGTH +
            ' characters.';
    }
    /**
     * Returns a {@link Resource} populated with attributes from the
     * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
     * function to conform to the Detector interface.
     *
     * @param config The resource detection config
     */
    EnvDetector.prototype.detect = function (_config) {
        return EnvDetector_awaiter(this, void 0, void 0, function () {
            var attributes, env, rawAttributes, serviceName, parsedAttributes;
            return EnvDetector_generator(this, function (_a) {
                attributes = {};
                env = esm_platform_browser_environment_getEnv();
                rawAttributes = env.OTEL_RESOURCE_ATTRIBUTES;
                serviceName = env.OTEL_SERVICE_NAME;
                if (rawAttributes) {
                    try {
                        parsedAttributes = this._parseResourceAttributes(rawAttributes);
                        Object.assign(attributes, parsedAttributes);
                    }
                    catch (e) {
                        esm_diag.debug("EnvDetector failed: " + e.message);
                    }
                }
                if (serviceName) {
                    attributes[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.SERVICE_NAME] = serviceName;
                }
                return [2 /*return*/, new esm_Resource_Resource(attributes)];
            });
        });
    };
    /**
     * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment
     * variable.
     *
     * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing
     * the source in more detail, e.g. “key1=val1,key2=val2”. Domain names and
     * paths are accepted as attribute keys. Values may be quoted or unquoted in
     * general. If a value contains whitespaces, =, or " characters, it must
     * always be quoted.
     *
     * @param rawEnvAttributes The resource attributes as a comma-seperated list
     * of key/value pairs.
     * @returns The sanitized resource attributes.
     */
    EnvDetector.prototype._parseResourceAttributes = function (rawEnvAttributes) {
        var e_1, _a;
        if (!rawEnvAttributes)
            return {};
        var attributes = {};
        var rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        try {
            for (var rawAttributes_1 = EnvDetector_values(rawAttributes), rawAttributes_1_1 = rawAttributes_1.next(); !rawAttributes_1_1.done; rawAttributes_1_1 = rawAttributes_1.next()) {
                var rawAttribute = rawAttributes_1_1.value;
                var keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
                if (keyValuePair.length !== 2) {
                    continue;
                }
                var _b = EnvDetector_read(keyValuePair, 2), key = _b[0], value = _b[1];
                // Leading and trailing whitespaces are trimmed.
                key = key.trim();
                value = value.trim().split('^"|"$').join('');
                if (!this._isValidAndNotEmpty(key)) {
                    throw new Error("Attribute key " + this._ERROR_MESSAGE_INVALID_CHARS);
                }
                if (!this._isValid(value)) {
                    throw new Error("Attribute value " + this._ERROR_MESSAGE_INVALID_VALUE);
                }
                attributes[key] = value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (rawAttributes_1_1 && !rawAttributes_1_1.done && (_a = rawAttributes_1.return)) _a.call(rawAttributes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return attributes;
    };
    /**
     * Determines whether the given String is a valid printable ASCII string with
     * a length not exceed _MAX_LENGTH characters.
     *
     * @param str The String to be validated.
     * @returns Whether the String is valid.
     */
    EnvDetector.prototype._isValid = function (name) {
        return name.length <= this._MAX_LENGTH && this._isPrintableString(name);
    };
    EnvDetector.prototype._isPrintableString = function (str) {
        for (var i = 0; i < str.length; i++) {
            var ch = str.charAt(i);
            if (ch <= ' ' || ch >= '~') {
                return false;
            }
        }
        return true;
    };
    /**
     * Determines whether the given String is a valid printable ASCII string with
     * a length greater than 0 and not exceed _MAX_LENGTH characters.
     *
     * @param str The String to be validated.
     * @returns Whether the String is valid and not empty.
     */
    EnvDetector.prototype._isValidAndNotEmpty = function (str) {
        return str.length > 0 && this._isValid(str);
    };
    return EnvDetector;
}());
var envDetector = new EnvDetector();
//# sourceMappingURL=EnvDetector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/detectors/ProcessDetector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ProcessDetector_assign = (undefined && undefined.__assign) || function () {
    ProcessDetector_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ProcessDetector_assign.apply(this, arguments);
};
var ProcessDetector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var ProcessDetector_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



/**
 * ProcessDetector will be used to detect the resources related current process running
 * and being instrumented from the NodeJS Process module.
 */
var ProcessDetector = /** @class */ (function () {
    function ProcessDetector() {
    }
    ProcessDetector.prototype.detect = function (config) {
        return ProcessDetector_awaiter(this, void 0, void 0, function () {
            var processResource;
            var _a;
            return ProcessDetector_generator(this, function (_b) {
                // Skip if not in Node.js environment.
                if (typeof process !== 'object') {
                    return [2 /*return*/, esm_Resource_Resource.empty()];
                }
                processResource = (_a = {},
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_PID] = process.pid,
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] = process.title || '',
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1] || '',
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_COMMAND_LINE] = process.argv.join(' ') || '',
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = process.versions.node,
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = 'nodejs',
                    _a[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = 'Node.js',
                    _a);
                return [2 /*return*/, this._getResourceAttributes(processResource, config)];
            });
        });
    };
    /**
     * Validates process resource attribute map from process varaibls
     *
     * @param processResource The unsantized resource attributes from process as key/value pairs.
     * @param config: Config
     * @returns The sanitized resource attributes.
     */
    ProcessDetector.prototype._getResourceAttributes = function (processResource, _config) {
        if (processResource[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] ===
            '' ||
            processResource[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH] ===
                '' ||
            processResource[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_COMMAND] === '' ||
            processResource[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_COMMAND_LINE] === '' ||
            processResource[build_esm_resource_SemanticResourceAttributes_SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === '') {
            esm_diag.debug('ProcessDetector failed: Unable to find required process resources. ');
            return esm_Resource_Resource.empty();
        }
        else {
            return new esm_Resource_Resource(ProcessDetector_assign({}, processResource));
        }
    };
    return ProcessDetector;
}());
var processDetector = new ProcessDetector();
//# sourceMappingURL=ProcessDetector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/detectors/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/view/ViewRegistry.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ViewRegistry = /** @class */ (function () {
    function ViewRegistry() {
        this._registeredViews = [];
    }
    ViewRegistry.prototype.addView = function (view) {
        this._registeredViews.push(view);
    };
    ViewRegistry.prototype.findViews = function (instrument, meter) {
        var _this = this;
        var views = this._registeredViews
            .filter(function (registeredView) {
            return _this._matchInstrument(registeredView.instrumentSelector, instrument) &&
                _this._matchMeter(registeredView.meterSelector, meter);
        });
        return views;
    };
    ViewRegistry.prototype._matchInstrument = function (selector, instrument) {
        return (selector.getType() === undefined || instrument.type === selector.getType()) &&
            selector.getNameFilter().match(instrument.name);
    };
    ViewRegistry.prototype._matchMeter = function (selector, meter) {
        return selector.getNameFilter().match(meter.name) &&
            (meter.version === undefined || selector.getVersionFilter().match(meter.version)) &&
            (meter.schemaUrl === undefined || selector.getSchemaUrlFilter().match(meter.schemaUrl));
    };
    return ViewRegistry;
}());

//# sourceMappingURL=ViewRegistry.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/Instruments.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Instruments_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var SyncInstrument = /** @class */ (function () {
    function SyncInstrument(_writableMetricStorage, _descriptor) {
        this._writableMetricStorage = _writableMetricStorage;
        this._descriptor = _descriptor;
    }
    SyncInstrument.prototype._record = function (value, attributes, context) {
        if (attributes === void 0) { attributes = {}; }
        if (context === void 0) { context = esm_context.active(); }
        if (this._descriptor.valueType === Metric_ValueType.INT && !Number.isInteger(value)) {
            esm_diag.warn("INT value type cannot accept a floating-point value for " + this._descriptor.name + ", ignoring the fractional digits.");
            value = Math.trunc(value);
        }
        this._writableMetricStorage.record(value, attributes, context, build_esm_common_time_hrTime());
    };
    return SyncInstrument;
}());

/**
 * The class implements {@link metrics.UpDownCounter} interface.
 */
var UpDownCounterInstrument = /** @class */ (function (_super) {
    Instruments_extends(UpDownCounterInstrument, _super);
    function UpDownCounterInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Increment value of counter by the input. Inputs may be negative.
     */
    UpDownCounterInstrument.prototype.add = function (value, attributes, ctx) {
        this._record(value, attributes, ctx);
    };
    return UpDownCounterInstrument;
}(SyncInstrument));

/**
 * The class implements {@link metrics.Counter} interface.
 */
var CounterInstrument = /** @class */ (function (_super) {
    Instruments_extends(CounterInstrument, _super);
    function CounterInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Increment value of counter by the input. Inputs may not be negative.
     */
    CounterInstrument.prototype.add = function (value, attributes, ctx) {
        if (value < 0) {
            esm_diag.warn("negative value provided to counter " + this._descriptor.name + ": " + value);
            return;
        }
        this._record(value, attributes, ctx);
    };
    return CounterInstrument;
}(SyncInstrument));

/**
 * The class implements {@link metrics.Histogram} interface.
 */
var HistogramInstrument = /** @class */ (function (_super) {
    Instruments_extends(HistogramInstrument, _super);
    function HistogramInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Records a measurement. Value of the measurement must not be negative.
     */
    HistogramInstrument.prototype.record = function (value, attributes, ctx) {
        if (value < 0) {
            esm_diag.warn("negative value provided to histogram " + this._descriptor.name + ": " + value);
            return;
        }
        this._record(value, attributes, ctx);
    };
    return HistogramInstrument;
}(SyncInstrument));

var ObservableInstrument = /** @class */ (function () {
    function ObservableInstrument(descriptor, metricStorages, _observableRegistry) {
        this._observableRegistry = _observableRegistry;
        this._descriptor = descriptor;
        this._metricStorages = metricStorages;
    }
    /**
     * @see {metrics.Observable.addCallback}
     */
    ObservableInstrument.prototype.addCallback = function (callback) {
        this._observableRegistry.addCallback(callback, this);
    };
    /**
     * @see {metrics.Observable.removeCallback}
     */
    ObservableInstrument.prototype.removeCallback = function (callback) {
        this._observableRegistry.removeCallback(callback, this);
    };
    return ObservableInstrument;
}());

var ObservableCounterInstrument = /** @class */ (function (_super) {
    Instruments_extends(ObservableCounterInstrument, _super);
    function ObservableCounterInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ObservableCounterInstrument;
}(ObservableInstrument));

var ObservableGaugeInstrument = /** @class */ (function (_super) {
    Instruments_extends(ObservableGaugeInstrument, _super);
    function ObservableGaugeInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ObservableGaugeInstrument;
}(ObservableInstrument));

var ObservableUpDownCounterInstrument = /** @class */ (function (_super) {
    Instruments_extends(ObservableUpDownCounterInstrument, _super);
    function ObservableUpDownCounterInstrument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ObservableUpDownCounterInstrument;
}(ObservableInstrument));

function isObservableInstrument(it) {
    return it instanceof ObservableInstrument;
}
//# sourceMappingURL=Instruments.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/Meter.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * This class implements the {@link metrics.Meter} interface.
 */
var Meter = /** @class */ (function () {
    function Meter(_meterSharedState) {
        this._meterSharedState = _meterSharedState;
    }
    /**
     * Create a {@link metrics.Histogram} instrument.
     */
    Meter.prototype.createHistogram = function (name, options) {
        var descriptor = createInstrumentDescriptor(name, InstrumentType.HISTOGRAM, options);
        var storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new HistogramInstrument(storage, descriptor);
    };
    /**
     * Create a {@link metrics.Counter} instrument.
     */
    Meter.prototype.createCounter = function (name, options) {
        var descriptor = createInstrumentDescriptor(name, InstrumentType.COUNTER, options);
        var storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new CounterInstrument(storage, descriptor);
    };
    /**
     * Create a {@link metrics.UpDownCounter} instrument.
     */
    Meter.prototype.createUpDownCounter = function (name, options) {
        var descriptor = createInstrumentDescriptor(name, InstrumentType.UP_DOWN_COUNTER, options);
        var storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new UpDownCounterInstrument(storage, descriptor);
    };
    /**
     * Create a {@link metrics.ObservableGauge} instrument.
     */
    Meter.prototype.createObservableGauge = function (name, options) {
        var descriptor = createInstrumentDescriptor(name, InstrumentType.OBSERVABLE_GAUGE, options);
        var storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new ObservableGaugeInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
    };
    /**
     * Create a {@link metrics.ObservableCounter} instrument.
     */
    Meter.prototype.createObservableCounter = function (name, options) {
        var descriptor = createInstrumentDescriptor(name, InstrumentType.OBSERVABLE_COUNTER, options);
        var storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new ObservableCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
    };
    /**
     * Create a {@link metrics.ObservableUpDownCounter} instrument.
     */
    Meter.prototype.createObservableUpDownCounter = function (name, options) {
        var descriptor = createInstrumentDescriptor(name, InstrumentType.OBSERVABLE_UP_DOWN_COUNTER, options);
        var storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new ObservableUpDownCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
    };
    /**
     * @see {@link metrics.Meter.addBatchObservableCallback}
     */
    Meter.prototype.addBatchObservableCallback = function (callback, observables) {
        this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);
    };
    /**
     * @see {@link metrics.Meter.removeBatchObservableCallback}
     */
    Meter.prototype.removeBatchObservableCallback = function (callback, observables) {
        this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);
    };
    return Meter;
}());

//# sourceMappingURL=Meter.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/MetricStorage.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Internal interface.
 *
 * Represents a storage from which we can collect metrics.
 */
var MetricStorage = /** @class */ (function () {
    function MetricStorage(_instrumentDescriptor) {
        this._instrumentDescriptor = _instrumentDescriptor;
    }
    MetricStorage.prototype.getInstrumentDescriptor = function () {
        return this._instrumentDescriptor;
    };
    MetricStorage.prototype.updateDescription = function (description) {
        this._instrumentDescriptor = createInstrumentDescriptor(this._instrumentDescriptor.name, this._instrumentDescriptor.type, {
            description: description,
            valueType: this._instrumentDescriptor.valueType,
            unit: this._instrumentDescriptor.unit
        });
    };
    return MetricStorage;
}());

//# sourceMappingURL=MetricStorage.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/HashMap.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var HashMap_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var HashMap_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var HashMap = /** @class */ (function () {
    function HashMap(_hash) {
        this._hash = _hash;
        this._valueMap = new Map();
        this._keyMap = new Map();
    }
    HashMap.prototype.get = function (key, hashCode) {
        hashCode !== null && hashCode !== void 0 ? hashCode : (hashCode = this._hash(key));
        return this._valueMap.get(hashCode);
    };
    HashMap.prototype.getOrDefault = function (key, defaultFactory) {
        var hash = this._hash(key);
        if (this._valueMap.has(hash)) {
            return this._valueMap.get(hash);
        }
        var val = defaultFactory();
        if (!this._keyMap.has(hash)) {
            this._keyMap.set(hash, key);
        }
        this._valueMap.set(hash, val);
        return val;
    };
    HashMap.prototype.set = function (key, value, hashCode) {
        hashCode !== null && hashCode !== void 0 ? hashCode : (hashCode = this._hash(key));
        if (!this._keyMap.has(hashCode)) {
            this._keyMap.set(hashCode, key);
        }
        this._valueMap.set(hashCode, value);
    };
    HashMap.prototype.has = function (key, hashCode) {
        hashCode !== null && hashCode !== void 0 ? hashCode : (hashCode = this._hash(key));
        return this._valueMap.has(hashCode);
    };
    HashMap.prototype.keys = function () {
        var keyIterator, next;
        return HashMap_generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    keyIterator = this._keyMap.entries();
                    next = keyIterator.next();
                    _a.label = 1;
                case 1:
                    if (!(next.done !== true)) return [3 /*break*/, 3];
                    return [4 /*yield*/, [next.value[1], next.value[0]]];
                case 2:
                    _a.sent();
                    next = keyIterator.next();
                    return [3 /*break*/, 1];
                case 3: return [2 /*return*/];
            }
        });
    };
    HashMap.prototype.entries = function () {
        var valueIterator, next;
        return HashMap_generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    valueIterator = this._valueMap.entries();
                    next = valueIterator.next();
                    _a.label = 1;
                case 1:
                    if (!(next.done !== true)) return [3 /*break*/, 3];
                    // next.value[0] here can not be undefined
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    return [4 /*yield*/, [this._keyMap.get(next.value[0]), next.value[1], next.value[0]]];
                case 2:
                    // next.value[0] here can not be undefined
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    _a.sent();
                    next = valueIterator.next();
                    return [3 /*break*/, 1];
                case 3: return [2 /*return*/];
            }
        });
    };
    Object.defineProperty(HashMap.prototype, "size", {
        get: function () {
            return this._valueMap.size;
        },
        enumerable: false,
        configurable: true
    });
    return HashMap;
}());

var AttributeHashMap = /** @class */ (function (_super) {
    HashMap_extends(AttributeHashMap, _super);
    function AttributeHashMap() {
        return _super.call(this, hashAttributes) || this;
    }
    return AttributeHashMap;
}(HashMap));

//# sourceMappingURL=HashMap.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/DeltaMetricProcessor.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DeltaMetricProcessor_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

/**
 * Internal interface.
 *
 * Allows synchronous collection of metrics. This processor should allow
 * allocation of new aggregation cells for metrics and convert cumulative
 * recording to delta data points.
 */
var DeltaMetricProcessor = /** @class */ (function () {
    function DeltaMetricProcessor(_aggregator) {
        this._aggregator = _aggregator;
        this._activeCollectionStorage = new AttributeHashMap();
        // TODO: find a reasonable mean to clean the memo;
        // https://github.com/open-telemetry/opentelemetry-specification/pull/2208
        this._cumulativeMemoStorage = new AttributeHashMap();
    }
    DeltaMetricProcessor.prototype.record = function (value, attributes, _context, collectionTime) {
        var _this = this;
        var accumulation = this._activeCollectionStorage.getOrDefault(attributes, function () { return _this._aggregator.createAccumulation(collectionTime); });
        accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);
    };
    DeltaMetricProcessor.prototype.batchCumulate = function (measurements, collectionTime) {
        var _this = this;
        Array.from(measurements.entries()).forEach(function (_a) {
            var _b = DeltaMetricProcessor_read(_a, 3), attributes = _b[0], value = _b[1], hashCode = _b[2];
            var accumulation = _this._aggregator.createAccumulation(collectionTime);
            accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);
            var delta = accumulation;
            if (_this._cumulativeMemoStorage.has(attributes, hashCode)) {
                // has() returned true, previous is present.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var previous = _this._cumulativeMemoStorage.get(attributes, hashCode);
                delta = _this._aggregator.diff(previous, accumulation);
            }
            // Save the current record and the delta record.
            _this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);
            _this._activeCollectionStorage.set(attributes, delta, hashCode);
        });
    };
    /**
     * Returns a collection of delta metrics. Start time is the when first
     * time event collected.
     */
    DeltaMetricProcessor.prototype.collect = function () {
        var unreportedDelta = this._activeCollectionStorage;
        this._activeCollectionStorage = new AttributeHashMap();
        return unreportedDelta;
    };
    return DeltaMetricProcessor;
}());

//# sourceMappingURL=DeltaMetricProcessor.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/TemporalMetricProcessor.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TemporalMetricProcessor_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var TemporalMetricProcessor_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};


/**
 * Internal interface.
 *
 * Provides unique reporting for each collector. Allows synchronous collection
 * of metrics and reports given temporality values.
 */
var TemporalMetricProcessor = /** @class */ (function () {
    function TemporalMetricProcessor(_aggregator) {
        this._aggregator = _aggregator;
        this._unreportedAccumulations = new Map();
        this._reportHistory = new Map();
    }
    /**
     * Builds the {@link MetricData} streams to report against a specific MetricCollector.
     * @param collector The information of the MetricCollector.
     * @param collectors The registered collectors.
     * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.
     * @param currentAccumulations The current accumulation of metric data from instruments.
     * @param collectionTime The current collection timestamp.
     * @returns The {@link MetricData} points or `null`.
     */
    TemporalMetricProcessor.prototype.buildMetrics = function (collector, collectors, instrumentDescriptor, currentAccumulations, collectionTime) {
        this._stashAccumulations(collectors, currentAccumulations);
        var unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);
        var result = unreportedAccumulations;
        var aggregationTemporality;
        // Check our last report time.
        if (this._reportHistory.has(collector)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var last = this._reportHistory.get(collector);
            var lastCollectionTime = last.collectionTime;
            aggregationTemporality = last.aggregationTemporality;
            // Use aggregation temporality + instrument to determine if we do a merge or a diff of
            // previous. We have the following four scenarios:
            // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).
            //    Here we merge with our last record to get a cumulative aggregation.
            // 2. Cumulative Aggregation + Cumulative recording (async instrument).
            //    Cumulative records are converted to delta recording with DeltaMetricProcessor.
            //    Here we merge with our last record to get a cumulative aggregation.
            // 3. Delta Aggregation + Delta recording
            //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.
            // 4. Delta Aggregation + Cumulative recording.
            //    Cumulative records are converted to delta recording with DeltaMetricProcessor.
            //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.
            if (aggregationTemporality === AggregationTemporality_AggregationTemporality.CUMULATIVE) {
                // We need to make sure the current delta recording gets merged into the previous cumulative
                // for the next cumulative recording.
                result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);
            }
            else {
                result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);
            }
        }
        else {
            // Call into user code to select aggregation temporality for the instrument.
            aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);
        }
        // Update last reported (cumulative) accumulation.
        this._reportHistory.set(collector, {
            accumulations: result,
            collectionTime: collectionTime,
            aggregationTemporality: aggregationTemporality,
        });
        return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, AttributesMapToAccumulationRecords(result), 
        /* endTime */ collectionTime);
    };
    TemporalMetricProcessor.prototype._stashAccumulations = function (collectors, currentAccumulation) {
        var _this = this;
        collectors.forEach(function (it) {
            var stash = _this._unreportedAccumulations.get(it);
            if (stash === undefined) {
                stash = [];
                _this._unreportedAccumulations.set(it, stash);
            }
            stash.push(currentAccumulation);
        });
    };
    TemporalMetricProcessor.prototype._getMergedUnreportedAccumulations = function (collector) {
        var e_1, _a;
        var result = new AttributeHashMap();
        var unreportedList = this._unreportedAccumulations.get(collector);
        this._unreportedAccumulations.set(collector, []);
        if (unreportedList === undefined) {
            return result;
        }
        try {
            for (var unreportedList_1 = TemporalMetricProcessor_values(unreportedList), unreportedList_1_1 = unreportedList_1.next(); !unreportedList_1_1.done; unreportedList_1_1 = unreportedList_1.next()) {
                var it_1 = unreportedList_1_1.value;
                result = TemporalMetricProcessor.merge(result, it_1, this._aggregator);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (unreportedList_1_1 && !unreportedList_1_1.done && (_a = unreportedList_1.return)) _a.call(unreportedList_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    };
    TemporalMetricProcessor.merge = function (last, current, aggregator) {
        var result = last;
        var iterator = current.entries();
        var next = iterator.next();
        while (next.done !== true) {
            var _a = TemporalMetricProcessor_read(next.value, 3), key = _a[0], record = _a[1], hash = _a[2];
            if (last.has(key, hash)) {
                var lastAccumulation = last.get(key, hash);
                // last.has() returned true, lastAccumulation is present.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var accumulation = aggregator.merge(lastAccumulation, record);
                result.set(key, accumulation, hash);
            }
            else {
                result.set(key, record, hash);
            }
            next = iterator.next();
        }
        return result;
    };
    /**
     * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves
     * the new stream to be the initial observation time unchanged.
     */
    TemporalMetricProcessor.calibrateStartTime = function (last, current, lastCollectionTime) {
        var e_2, _a;
        try {
            for (var _b = TemporalMetricProcessor_values(last.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = TemporalMetricProcessor_read(_c.value, 2), key = _d[0], hash = _d[1];
                var currentAccumulation = current.get(key, hash);
                currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return current;
    };
    return TemporalMetricProcessor;
}());

// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.
function AttributesMapToAccumulationRecords(map) {
    return Array.from(map.entries());
}
//# sourceMappingURL=TemporalMetricProcessor.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/AsyncMetricStorage.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var AsyncMetricStorage_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var AsyncMetricStorage_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};




/**
 * Internal interface.
 *
 * Stores and aggregates {@link MetricData} for asynchronous instruments.
 */
var AsyncMetricStorage = /** @class */ (function (_super) {
    AsyncMetricStorage_extends(AsyncMetricStorage, _super);
    function AsyncMetricStorage(_instrumentDescriptor, aggregator, _attributesProcessor) {
        var _this = _super.call(this, _instrumentDescriptor) || this;
        _this._attributesProcessor = _attributesProcessor;
        _this._deltaMetricStorage = new DeltaMetricProcessor(aggregator);
        _this._temporalMetricStorage = new TemporalMetricProcessor(aggregator);
        return _this;
    }
    AsyncMetricStorage.prototype.record = function (measurements, observationTime) {
        var _this = this;
        var processed = new AttributeHashMap();
        Array.from(measurements.entries()).forEach(function (_a) {
            var _b = AsyncMetricStorage_read(_a, 2), attributes = _b[0], value = _b[1];
            processed.set(_this._attributesProcessor.process(attributes), value);
        });
        this._deltaMetricStorage.batchCumulate(processed, observationTime);
    };
    /**
     * Collects the metrics from this storage. The ObservableCallback is invoked
     * during the collection.
     *
     * Note: This is a stateful operation and may reset any interval-related
     * state for the MetricCollector.
     */
    AsyncMetricStorage.prototype.collect = function (collector, collectors, collectionTime) {
        var accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, collectors, this._instrumentDescriptor, accumulations, collectionTime);
    };
    return AsyncMetricStorage;
}(MetricStorage));

//# sourceMappingURL=AsyncMetricStorage.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/view/RegistrationConflicts.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getIncompatibilityDetails(existing, otherDescriptor) {
    var incompatibility = '';
    if (existing.unit !== otherDescriptor.unit) {
        incompatibility += "\t- Unit '" + existing.unit + "' does not match '" + otherDescriptor.unit + "'\n";
    }
    if (existing.type !== otherDescriptor.type) {
        incompatibility += "\t- Type '" + existing.type + "' does not match '" + otherDescriptor.type + "'\n";
    }
    if (existing.valueType !== otherDescriptor.valueType) {
        incompatibility += "\t- Value Type '" + existing.valueType + "' does not match '" + otherDescriptor.valueType + "'\n";
    }
    if (existing.description !== otherDescriptor.description) {
        incompatibility += "\t- Description '" + existing.description + "' does not match '" + otherDescriptor.description + "'\n";
    }
    return incompatibility;
}
function getValueTypeConflictResolutionRecipe(existing, otherDescriptor) {
    return "\t- use valueType '" + existing.valueType + "' on instrument creation or use an instrument name other than '" + otherDescriptor.name + "'";
}
function getUnitConflictResolutionRecipe(existing, otherDescriptor) {
    return "\t- use unit '" + existing.unit + "' on instrument creation or use an instrument name other than '" + otherDescriptor.name + "'";
}
function getTypeConflictResolutionRecipe(existing, otherDescriptor) {
    var selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type
    };
    var selectorString = JSON.stringify(selector);
    return "\t- create a new view with a name other than '" + existing.name + "' and InstrumentSelector '" + selectorString + "'";
}
function getDescriptionResolutionRecipe(existing, otherDescriptor) {
    var selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type
    };
    var selectorString = JSON.stringify(selector);
    return "\t- create a new view with a name other than '" + existing.name + "' and InstrumentSelector '" + selectorString + "'\n    \t- OR - create a new view with the name " + existing.name + " and description '" + existing.description + "' and InstrumentSelector " + selectorString + "\n    \t- OR - create a new view with the name " + otherDescriptor.name + " and description '" + existing.description + "' and InstrumentSelector " + selectorString;
}
function getConflictResolutionRecipe(existing, otherDescriptor) {
    // Conflicts that cannot be solved via views.
    if (existing.valueType !== otherDescriptor.valueType) {
        return getValueTypeConflictResolutionRecipe(existing, otherDescriptor);
    }
    if (existing.unit !== otherDescriptor.unit) {
        return getUnitConflictResolutionRecipe(existing, otherDescriptor);
    }
    // Conflicts that can be solved via views.
    if (existing.type !== otherDescriptor.type) {
        // this will automatically solve possible description conflicts.
        return getTypeConflictResolutionRecipe(existing, otherDescriptor);
    }
    if (existing.description !== otherDescriptor.description) {
        return getDescriptionResolutionRecipe(existing, otherDescriptor);
    }
    return '';
}
//# sourceMappingURL=RegistrationConflicts.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/MetricStorageRegistry.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MetricStorageRegistry_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};



/**
 * Internal class for storing {@link MetricStorage}
 */
var MetricStorageRegistry = /** @class */ (function () {
    function MetricStorageRegistry() {
        this._sharedRegistry = new Map();
        this._perCollectorRegistry = new Map();
    }
    MetricStorageRegistry.create = function () {
        return new MetricStorageRegistry();
    };
    MetricStorageRegistry.prototype.getStorages = function (collector) {
        var e_1, _a, e_2, _b;
        var storages = [];
        try {
            for (var _c = MetricStorageRegistry_values(this._sharedRegistry.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var metricStorages = _d.value;
                storages = storages.concat(metricStorages);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var perCollectorStorages = this._perCollectorRegistry.get(collector);
        if (perCollectorStorages != null) {
            try {
                for (var _e = MetricStorageRegistry_values(perCollectorStorages.values()), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var metricStorages = _f.value;
                    storages = storages.concat(metricStorages);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        return storages;
    };
    MetricStorageRegistry.prototype.register = function (storage) {
        this._registerStorage(storage, this._sharedRegistry);
    };
    MetricStorageRegistry.prototype.registerForCollector = function (collector, storage) {
        var storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap == null) {
            storageMap = new Map();
            this._perCollectorRegistry.set(collector, storageMap);
        }
        this._registerStorage(storage, storageMap);
    };
    MetricStorageRegistry.prototype.findOrUpdateCompatibleStorage = function (expectedDescriptor) {
        var storages = this._sharedRegistry.get(expectedDescriptor.name);
        if (storages === undefined) {
            return null;
        }
        // If the descriptor is compatible, the type of their metric storage
        // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.
        return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
    };
    MetricStorageRegistry.prototype.findOrUpdateCompatibleCollectorStorage = function (collector, expectedDescriptor) {
        var storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap === undefined) {
            return null;
        }
        var storages = this._sharedRegistry.get(expectedDescriptor.name);
        if (storages === undefined) {
            return null;
        }
        // If the descriptor is compatible, the type of their metric storage
        // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.
        return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
    };
    MetricStorageRegistry.prototype._registerStorage = function (storage, storageMap) {
        var descriptor = storage.getInstrumentDescriptor();
        var storages = storageMap.get(descriptor.name);
        if (storages === undefined) {
            storageMap.set(descriptor.name, [storage]);
            return;
        }
        storages.push(storage);
    };
    MetricStorageRegistry.prototype._findOrUpdateCompatibleStorage = function (expectedDescriptor, existingStorages) {
        var e_3, _a;
        var compatibleStorage = null;
        try {
            for (var existingStorages_1 = MetricStorageRegistry_values(existingStorages), existingStorages_1_1 = existingStorages_1.next(); !existingStorages_1_1.done; existingStorages_1_1 = existingStorages_1.next()) {
                var existingStorage = existingStorages_1_1.value;
                var existingDescriptor = existingStorage.getInstrumentDescriptor();
                if (isDescriptorCompatibleWith(existingDescriptor, expectedDescriptor)) {
                    // Use the longer description if it does not match.
                    if (existingDescriptor.description !== expectedDescriptor.description) {
                        if (expectedDescriptor.description.length > existingDescriptor.description.length) {
                            existingStorage.updateDescription(expectedDescriptor.description);
                        }
                        esm_diag.warn('A view or instrument with the name ', expectedDescriptor.name, ' has already been registered, but has a different description and is incompatible with another registered view.\n', 'Details:\n', getIncompatibilityDetails(existingDescriptor, expectedDescriptor), 'The longer description will be used.\nTo resolve the conflict:', getConflictResolutionRecipe(existingDescriptor, expectedDescriptor));
                    }
                    // Storage is fully compatible. There will never be more than one pre-existing fully compatible storage.
                    compatibleStorage = existingStorage;
                }
                else {
                    // The implementation SHOULD warn about duplicate instrument registration
                    // conflicts after applying View configuration.
                    esm_diag.warn('A view or instrument with the name ', expectedDescriptor.name, ' has already been registered and is incompatible with another registered view.\n', 'Details:\n', getIncompatibilityDetails(existingDescriptor, expectedDescriptor), 'To resolve the conflict:\n', getConflictResolutionRecipe(existingDescriptor, expectedDescriptor));
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (existingStorages_1_1 && !existingStorages_1_1.done && (_a = existingStorages_1.return)) _a.call(existingStorages_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return compatibleStorage;
    };
    return MetricStorageRegistry;
}());

//# sourceMappingURL=MetricStorageRegistry.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/MultiWritableMetricStorage.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal interface.
 */
var MultiMetricStorage = /** @class */ (function () {
    function MultiMetricStorage(_backingStorages) {
        this._backingStorages = _backingStorages;
    }
    MultiMetricStorage.prototype.record = function (value, attributes, context, recordTime) {
        this._backingStorages.forEach(function (it) {
            it.record(value, attributes, context, recordTime);
        });
    };
    return MultiMetricStorage;
}());

//# sourceMappingURL=MultiWritableMetricStorage.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/ObservableResult.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * The class implements {@link metrics.ObservableResult} interface.
 */
var ObservableResultImpl = /** @class */ (function () {
    function ObservableResultImpl(_descriptor) {
        this._descriptor = _descriptor;
        /**
         * @internal
         */
        this._buffer = new AttributeHashMap();
    }
    /**
     * Observe a measurement of the value associated with the given attributes.
     */
    ObservableResultImpl.prototype.observe = function (value, attributes) {
        if (attributes === void 0) { attributes = {}; }
        if (this._descriptor.valueType === Metric_ValueType.INT && !Number.isInteger(value)) {
            esm_diag.warn("INT value type cannot accept a floating-point value for " + this._descriptor.name + ", ignoring the fractional digits.");
            value = Math.trunc(value);
        }
        this._buffer.set(attributes, value);
    };
    return ObservableResultImpl;
}());

/**
 * The class implements {@link metrics.BatchObservableCallback} interface.
 */
var BatchObservableResultImpl = /** @class */ (function () {
    function BatchObservableResultImpl() {
        /**
         * @internal
         */
        this._buffer = new Map();
    }
    /**
     * Observe a measurement of the value associated with the given attributes.
     */
    BatchObservableResultImpl.prototype.observe = function (metric, value, attributes) {
        if (attributes === void 0) { attributes = {}; }
        if (!isObservableInstrument(metric)) {
            return;
        }
        var map = this._buffer.get(metric);
        if (map == null) {
            map = new AttributeHashMap();
            this._buffer.set(metric, map);
        }
        if (metric._descriptor.valueType === Metric_ValueType.INT && !Number.isInteger(value)) {
            esm_diag.warn("INT value type cannot accept a floating-point value for " + metric._descriptor.name + ", ignoring the fractional digits.");
            value = Math.trunc(value);
        }
        map.set(attributes, value);
    };
    return BatchObservableResultImpl;
}());

//# sourceMappingURL=ObservableResult.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/ObservableRegistry.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ObservableRegistry_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var ObservableRegistry_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var ObservableRegistry_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var ObservableRegistry_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};




/**
 * An internal interface for managing ObservableCallbacks.
 *
 * Every registered callback associated with a set of instruments are be evaluated
 * exactly once during collection prior to reading data for that instrument.
 */
var ObservableRegistry = /** @class */ (function () {
    function ObservableRegistry() {
        this._callbacks = [];
        this._batchCallbacks = [];
    }
    ObservableRegistry.prototype.addCallback = function (callback, instrument) {
        var idx = this._findCallback(callback, instrument);
        if (idx >= 0) {
            return;
        }
        this._callbacks.push({ callback: callback, instrument: instrument });
    };
    ObservableRegistry.prototype.removeCallback = function (callback, instrument) {
        var idx = this._findCallback(callback, instrument);
        if (idx < 0) {
            return;
        }
        this._callbacks.splice(idx, 1);
    };
    ObservableRegistry.prototype.addBatchCallback = function (callback, instruments) {
        // Create a set of unique instruments.
        var observableInstruments = new Set(instruments.filter(isObservableInstrument));
        if (observableInstruments.size === 0) {
            esm_diag.error('BatchObservableCallback is not associated with valid instruments', instruments);
            return;
        }
        var idx = this._findBatchCallback(callback, observableInstruments);
        if (idx >= 0) {
            return;
        }
        this._batchCallbacks.push({ callback: callback, instruments: observableInstruments });
    };
    ObservableRegistry.prototype.removeBatchCallback = function (callback, instruments) {
        // Create a set of unique instruments.
        var observableInstruments = new Set(instruments.filter(isObservableInstrument));
        var idx = this._findBatchCallback(callback, observableInstruments);
        if (idx < 0) {
            return;
        }
        this._batchCallbacks.splice(idx, 1);
    };
    /**
     * @returns a promise of rejected reasons for invoking callbacks.
     */
    ObservableRegistry.prototype.observe = function (collectionTime, timeoutMillis) {
        return ObservableRegistry_awaiter(this, void 0, void 0, function () {
            var callbackFutures, batchCallbackFutures, results, rejections;
            return ObservableRegistry_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis);
                        batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);
                        return [4 /*yield*/, PromiseAllSettled(ObservableRegistry_spreadArray(ObservableRegistry_spreadArray([], ObservableRegistry_read(callbackFutures), false), ObservableRegistry_read(batchCallbackFutures), false))];
                    case 1:
                        results = _a.sent();
                        rejections = results.filter(isPromiseAllSettledRejectionResult)
                            .map(function (it) { return it.reason; });
                        return [2 /*return*/, rejections];
                }
            });
        });
    };
    ObservableRegistry.prototype._observeCallbacks = function (observationTime, timeoutMillis) {
        var _this = this;
        return this._callbacks
            .map(function (_a) {
            var callback = _a.callback, instrument = _a.instrument;
            return ObservableRegistry_awaiter(_this, void 0, void 0, function () {
                var observableResult, callPromise;
                return ObservableRegistry_generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            observableResult = new ObservableResultImpl(instrument._descriptor);
                            callPromise = Promise.resolve(callback(observableResult));
                            if (timeoutMillis != null) {
                                callPromise = callWithTimeout(callPromise, timeoutMillis);
                            }
                            return [4 /*yield*/, callPromise];
                        case 1:
                            _b.sent();
                            instrument._metricStorages.forEach(function (metricStorage) {
                                metricStorage.record(observableResult._buffer, observationTime);
                            });
                            return [2 /*return*/];
                    }
                });
            });
        });
    };
    ObservableRegistry.prototype._observeBatchCallbacks = function (observationTime, timeoutMillis) {
        var _this = this;
        return this._batchCallbacks
            .map(function (_a) {
            var callback = _a.callback, instruments = _a.instruments;
            return ObservableRegistry_awaiter(_this, void 0, void 0, function () {
                var observableResult, callPromise;
                return ObservableRegistry_generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            observableResult = new BatchObservableResultImpl();
                            callPromise = Promise.resolve(callback(observableResult));
                            if (timeoutMillis != null) {
                                callPromise = callWithTimeout(callPromise, timeoutMillis);
                            }
                            return [4 /*yield*/, callPromise];
                        case 1:
                            _b.sent();
                            instruments.forEach(function (instrument) {
                                var buffer = observableResult._buffer.get(instrument);
                                if (buffer == null) {
                                    return;
                                }
                                instrument._metricStorages.forEach(function (metricStorage) {
                                    metricStorage.record(buffer, observationTime);
                                });
                            });
                            return [2 /*return*/];
                    }
                });
            });
        });
    };
    ObservableRegistry.prototype._findCallback = function (callback, instrument) {
        return this._callbacks.findIndex(function (record) {
            return record.callback === callback && record.instrument === instrument;
        });
    };
    ObservableRegistry.prototype._findBatchCallback = function (callback, instruments) {
        return this._batchCallbacks.findIndex(function (record) {
            return record.callback === callback && setEquals(record.instruments, instruments);
        });
    };
    return ObservableRegistry;
}());

//# sourceMappingURL=ObservableRegistry.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/SyncMetricStorage.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SyncMetricStorage_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



/**
 * Internal interface.
 *
 * Stores and aggregates {@link MetricData} for synchronous instruments.
 */
var SyncMetricStorage = /** @class */ (function (_super) {
    SyncMetricStorage_extends(SyncMetricStorage, _super);
    function SyncMetricStorage(instrumentDescriptor, aggregator, _attributesProcessor) {
        var _this = _super.call(this, instrumentDescriptor) || this;
        _this._attributesProcessor = _attributesProcessor;
        _this._deltaMetricStorage = new DeltaMetricProcessor(aggregator);
        _this._temporalMetricStorage = new TemporalMetricProcessor(aggregator);
        return _this;
    }
    SyncMetricStorage.prototype.record = function (value, attributes, context, recordTime) {
        attributes = this._attributesProcessor.process(attributes, context);
        this._deltaMetricStorage.record(value, attributes, context, recordTime);
    };
    /**
     * Collects the metrics from this storage.
     *
     * Note: This is a stateful operation and may reset any interval-related
     * state for the MetricCollector.
     */
    SyncMetricStorage.prototype.collect = function (collector, collectors, collectionTime) {
        var accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, collectors, this._instrumentDescriptor, accumulations, collectionTime);
    };
    return SyncMetricStorage;
}(MetricStorage));

//# sourceMappingURL=SyncMetricStorage.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/view/AttributesProcessor.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var AttributesProcessor_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * The {@link AttributesProcessor} is responsible for customizing which
 * attribute(s) are to be reported as metrics dimension(s) and adding
 * additional dimension(s) from the {@link Context}.
 */
var AttributesProcessor = /** @class */ (function () {
    function AttributesProcessor() {
    }
    AttributesProcessor.Noop = function () {
        return NOOP;
    };
    return AttributesProcessor;
}());

var NoopAttributesProcessor = /** @class */ (function (_super) {
    AttributesProcessor_extends(NoopAttributesProcessor, _super);
    function NoopAttributesProcessor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopAttributesProcessor.prototype.process = function (incoming, _context) {
        return incoming;
    };
    return NoopAttributesProcessor;
}(AttributesProcessor));

/**
 * {@link AttributesProcessor} that filters by allowed attribute names and drops any names that are not in the
 * allow list.
 */
var FilteringAttributesProcessor = /** @class */ (function (_super) {
    AttributesProcessor_extends(FilteringAttributesProcessor, _super);
    function FilteringAttributesProcessor(_allowedAttributeNames) {
        var _this = _super.call(this) || this;
        _this._allowedAttributeNames = _allowedAttributeNames;
        return _this;
    }
    FilteringAttributesProcessor.prototype.process = function (incoming, _context) {
        var _this = this;
        var filteredAttributes = {};
        Object.keys(incoming)
            .filter(function (attributeName) { return _this._allowedAttributeNames.includes(attributeName); })
            .forEach(function (attributeName) { return filteredAttributes[attributeName] = incoming[attributeName]; });
        return filteredAttributes;
    };
    return FilteringAttributesProcessor;
}(AttributesProcessor));

var NOOP = new NoopAttributesProcessor;
//# sourceMappingURL=AttributesProcessor.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/MeterSharedState.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MeterSharedState_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var MeterSharedState_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var MeterSharedState_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};









/**
 * An internal record for shared meter provider states.
 */
var MeterSharedState = /** @class */ (function () {
    function MeterSharedState(_meterProviderSharedState, _instrumentationScope) {
        this._meterProviderSharedState = _meterProviderSharedState;
        this._instrumentationScope = _instrumentationScope;
        this.metricStorageRegistry = new MetricStorageRegistry();
        this.observableRegistry = new ObservableRegistry();
        this.meter = new Meter(this);
    }
    MeterSharedState.prototype.registerMetricStorage = function (descriptor) {
        var storages = this._registerMetricStorage(descriptor, SyncMetricStorage);
        if (storages.length === 1) {
            return storages[0];
        }
        return new MultiMetricStorage(storages);
    };
    MeterSharedState.prototype.registerAsyncMetricStorage = function (descriptor) {
        var storages = this._registerMetricStorage(descriptor, AsyncMetricStorage);
        return storages;
    };
    /**
     * @param collector opaque handle of {@link MetricCollector} which initiated the collection.
     * @param collectionTime the HrTime at which the collection was initiated.
     * @param options options for collection.
     * @returns the list of metric data collected.
     */
    MeterSharedState.prototype.collect = function (collector, collectionTime, options) {
        return MeterSharedState_awaiter(this, void 0, void 0, function () {
            var errors, metricDataList;
            var _this = this;
            return MeterSharedState_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.observableRegistry.observe(collectionTime, options === null || options === void 0 ? void 0 : options.timeoutMillis)];
                    case 1:
                        errors = _a.sent();
                        metricDataList = Array.from(this.metricStorageRegistry.getStorages(collector))
                            .map(function (metricStorage) {
                            return metricStorage.collect(collector, _this._meterProviderSharedState.metricCollectors, collectionTime);
                        })
                            .filter(isNotNullish);
                        return [2 /*return*/, {
                                scopeMetrics: {
                                    scope: this._instrumentationScope,
                                    metrics: metricDataList.filter(isNotNullish),
                                },
                                errors: errors,
                            }];
                }
            });
        });
    };
    MeterSharedState.prototype._registerMetricStorage = function (descriptor, MetricStorageType) {
        var _this = this;
        var views = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope);
        var storages = views
            .map(function (view) {
            var viewDescriptor = createInstrumentDescriptorWithView(view, descriptor);
            var compatibleStorage = _this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);
            if (compatibleStorage != null) {
                return compatibleStorage;
            }
            var aggregator = view.aggregation.createAggregator(viewDescriptor);
            var viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor);
            _this.metricStorageRegistry.register(viewStorage);
            return viewStorage;
        });
        // Fallback to the per-collector aggregations if no view is configured for the instrument.
        if (storages.length === 0) {
            var perCollectorAggregations = this._meterProviderSharedState.selectAggregations(descriptor.type);
            var collectorStorages = perCollectorAggregations.map(function (_a) {
                var _b = MeterSharedState_read(_a, 2), collector = _b[0], aggregation = _b[1];
                var compatibleStorage = _this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);
                if (compatibleStorage != null) {
                    return compatibleStorage;
                }
                var aggregator = aggregation.createAggregator(descriptor);
                var storage = new MetricStorageType(descriptor, aggregator, AttributesProcessor.Noop());
                _this.metricStorageRegistry.registerForCollector(collector, storage);
                return storage;
            });
            storages = storages.concat(collectorStorages);
        }
        return storages;
    };
    return MeterSharedState;
}());

//# sourceMappingURL=MeterSharedState.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/MeterProviderSharedState.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MeterProviderSharedState_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};



/**
 * An internal record for shared meter provider states.
 */
var MeterProviderSharedState = /** @class */ (function () {
    function MeterProviderSharedState(resource) {
        this.resource = resource;
        this.viewRegistry = new ViewRegistry();
        this.metricCollectors = [];
        this.meterSharedStates = new Map();
    }
    MeterProviderSharedState.prototype.getMeterSharedState = function (instrumentationScope) {
        var id = instrumentationScopeId(instrumentationScope);
        var meterSharedState = this.meterSharedStates.get(id);
        if (meterSharedState == null) {
            meterSharedState = new MeterSharedState(this, instrumentationScope);
            this.meterSharedStates.set(id, meterSharedState);
        }
        return meterSharedState;
    };
    MeterProviderSharedState.prototype.selectAggregations = function (instrumentType) {
        var e_1, _a;
        var result = [];
        try {
            for (var _b = MeterProviderSharedState_values(this.metricCollectors), _c = _b.next(); !_c.done; _c = _b.next()) {
                var collector = _c.value;
                result.push([collector, collector.selectAggregation(instrumentType)]);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    };
    return MeterProviderSharedState;
}());

//# sourceMappingURL=MeterProviderSharedState.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/state/MetricCollector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MetricCollector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var MetricCollector_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


/**
 * An internal opaque interface that the MetricReader receives as
 * MetricProducer. It acts as the storage key to the internal metric stream
 * state for each MetricReader.
 */
var MetricCollector = /** @class */ (function () {
    function MetricCollector(_sharedState, _metricReader) {
        this._sharedState = _sharedState;
        this._metricReader = _metricReader;
    }
    MetricCollector.prototype.collect = function (options) {
        return MetricCollector_awaiter(this, void 0, void 0, function () {
            var collectionTime, meterCollectionPromises, result;
            var _this = this;
            return MetricCollector_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        collectionTime = build_esm_common_time_hrTime();
                        meterCollectionPromises = Array.from(this._sharedState.meterSharedStates.values())
                            .map(function (meterSharedState) { return meterSharedState.collect(_this, collectionTime, options); });
                        return [4 /*yield*/, Promise.all(meterCollectionPromises)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, {
                                resourceMetrics: {
                                    resource: this._sharedState.resource,
                                    scopeMetrics: result.map(function (it) { return it.scopeMetrics; }),
                                },
                                errors: FlatMap(result, function (it) { return it.errors; }),
                            }];
                }
            });
        });
    };
    /**
     * Delegates for MetricReader.forceFlush.
     */
    MetricCollector.prototype.forceFlush = function (options) {
        return MetricCollector_awaiter(this, void 0, void 0, function () {
            return MetricCollector_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._metricReader.forceFlush(options)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delegates for MetricReader.shutdown.
     */
    MetricCollector.prototype.shutdown = function (options) {
        return MetricCollector_awaiter(this, void 0, void 0, function () {
            return MetricCollector_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._metricReader.shutdown(options)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    MetricCollector.prototype.selectAggregationTemporality = function (instrumentType) {
        return this._metricReader.selectAggregationTemporality(instrumentType);
    };
    MetricCollector.prototype.selectAggregation = function (instrumentType) {
        return this._metricReader.selectAggregation(instrumentType);
    };
    return MetricCollector;
}());

//# sourceMappingURL=MetricCollector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/MeterProvider.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MeterProvider_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var MeterProvider_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var MeterProvider_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};





/**
 * This class implements the {@link metrics.MeterProvider} interface.
 */
var MeterProvider = /** @class */ (function () {
    function MeterProvider(options) {
        var e_1, _a;
        var _b;
        this._shutdown = false;
        this._sharedState = new MeterProviderSharedState((_b = options === null || options === void 0 ? void 0 : options.resource) !== null && _b !== void 0 ? _b : esm_Resource_Resource.empty());
        if ((options === null || options === void 0 ? void 0 : options.views) != null && options.views.length > 0) {
            try {
                for (var _c = MeterProvider_values(options.views), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var view = _d.value;
                    this._sharedState.viewRegistry.addView(view);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    /**
     * Get a meter with the configuration of the MeterProvider.
     */
    MeterProvider.prototype.getMeter = function (name, version, options) {
        if (version === void 0) { version = ''; }
        if (options === void 0) { options = {}; }
        // https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#meter-creation
        if (this._shutdown) {
            esm_diag.warn('A shutdown MeterProvider cannot provide a Meter');
            return createNoopMeter();
        }
        return this._sharedState
            .getMeterSharedState({ name: name, version: version, schemaUrl: options.schemaUrl })
            .meter;
    };
    /**
     * Register a {@link MetricReader} to the meter provider. After the
     * registration, the MetricReader can start metrics collection.
     *
     * @param metricReader the metric reader to be registered.
     */
    MeterProvider.prototype.addMetricReader = function (metricReader) {
        var collector = new MetricCollector(this._sharedState, metricReader);
        metricReader.setMetricProducer(collector);
        this._sharedState.metricCollectors.push(collector);
    };
    /**
     * Flush all buffered data and shut down the MeterProvider and all registered
     * MetricReaders.
     *
     * Returns a promise which is resolved when all flushes are complete.
     */
    MeterProvider.prototype.shutdown = function (options) {
        return MeterProvider_awaiter(this, void 0, void 0, function () {
            return MeterProvider_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._shutdown) {
                            esm_diag.warn('shutdown may only be called once per MeterProvider');
                            return [2 /*return*/];
                        }
                        this._shutdown = true;
                        return [4 /*yield*/, Promise.all(this._sharedState.metricCollectors.map(function (collector) {
                                return collector.shutdown(options);
                            }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Notifies all registered MetricReaders to flush any buffered data.
     *
     * Returns a promise which is resolved when all flushes are complete.
     */
    MeterProvider.prototype.forceFlush = function (options) {
        return MeterProvider_awaiter(this, void 0, void 0, function () {
            return MeterProvider_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // do not flush after shutdown
                        if (this._shutdown) {
                            esm_diag.warn('invalid attempt to force flush after MeterProvider shutdown');
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Promise.all(this._sharedState.metricCollectors.map(function (collector) {
                                return collector.forceFlush(options);
                            }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return MeterProvider;
}());

//# sourceMappingURL=MeterProvider.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/view/Predicate.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// https://tc39.es/proposal-regex-escaping
// escape ^ $ \ .  + ? ( ) [ ] { } |
// do not need to escape * as we interpret it as wildcard
var ESCAPE = /[\^$\\.+?()[\]{}|]/g;
/**
 * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.
 */
var PatternPredicate = /** @class */ (function () {
    function PatternPredicate(pattern) {
        if (pattern === '*') {
            this._matchAll = true;
            this._regexp = /.*/;
        }
        else {
            this._matchAll = false;
            this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));
        }
    }
    PatternPredicate.prototype.match = function (str) {
        if (this._matchAll) {
            return true;
        }
        return this._regexp.test(str);
    };
    PatternPredicate.escapePattern = function (pattern) {
        return "^" + pattern.replace(ESCAPE, '\\$&').replace('*', '.*') + "$";
    };
    PatternPredicate.hasWildcard = function (pattern) {
        return pattern.includes('*');
    };
    return PatternPredicate;
}());

var ExactPredicate = /** @class */ (function () {
    function ExactPredicate(pattern) {
        this._matchAll = pattern === undefined;
        this._pattern = pattern;
    }
    ExactPredicate.prototype.match = function (str) {
        if (this._matchAll) {
            return true;
        }
        if (str === this._pattern) {
            return true;
        }
        return false;
    };
    return ExactPredicate;
}());

//# sourceMappingURL=Predicate.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/view/InstrumentSelector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var InstrumentSelector = /** @class */ (function () {
    function InstrumentSelector(criteria) {
        var _a;
        this._nameFilter = new PatternPredicate((_a = criteria === null || criteria === void 0 ? void 0 : criteria.name) !== null && _a !== void 0 ? _a : '*');
        this._type = criteria === null || criteria === void 0 ? void 0 : criteria.type;
    }
    InstrumentSelector.prototype.getType = function () {
        return this._type;
    };
    InstrumentSelector.prototype.getNameFilter = function () {
        return this._nameFilter;
    };
    return InstrumentSelector;
}());

//# sourceMappingURL=InstrumentSelector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/view/MeterSelector.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MeterSelector = /** @class */ (function () {
    function MeterSelector(criteria) {
        this._nameFilter = new ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.name);
        this._versionFilter = new ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.version);
        this._schemaUrlFilter = new ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.schemaUrl);
    }
    MeterSelector.prototype.getNameFilter = function () {
        return this._nameFilter;
    };
    /**
     * TODO: semver filter? no spec yet.
     */
    MeterSelector.prototype.getVersionFilter = function () {
        return this._versionFilter;
    };
    MeterSelector.prototype.getSchemaUrlFilter = function () {
        return this._schemaUrlFilter;
    };
    return MeterSelector;
}());

//# sourceMappingURL=MeterSelector.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/view/View.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





function isSelectorNotProvided(options) {
    return (options.instrumentName == null &&
        options.instrumentType == null &&
        options.meterName == null &&
        options.meterVersion == null &&
        options.meterSchemaUrl == null);
}
/**
 * Can be passed to a {@link MeterProvider} to select instruments and alter their metric stream.
 */
var View = /** @class */ (function () {
    /**
     * Create a new {@link View} instance.
     *
     * Parameters can be categorized as two types:
     *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.
     *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).
     *
     *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.
     *
     * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.
     * @param viewOptions.name
     * Alters the metric stream:
     *  This will be used as the name of the metrics stream.
     *  If not provided, the original Instrument name will be used.
     * @param viewOptions.description
     * Alters the metric stream:
     *  This will be used as the description of the metrics stream.
     *  If not provided, the original Instrument description will be used by default.
     * @param viewOptions.attributeKeys
     * Alters the metric stream:
     *  If provided, the attributes that are not in the list will be ignored.
     *  If not provided, all attribute keys will be used by default.
     * @param viewOptions.aggregation
     * Alters the metric stream:
     *  Alters the {@link Aggregation} of the metric stream.
     * @param viewOptions.instrumentName
     * Instrument selection criteria:
     *  Original name of the Instrument(s) with wildcard support.
     * @param viewOptions.instrumentType
     * Instrument selection criteria:
     *  The original type of the Instrument(s).
     * @param viewOptions.meterName
     * Instrument selection criteria:
     *  The name of the Meter. No wildcard support, name must match the meter exactly.
     * @param viewOptions.meterVersion
     * Instrument selection criteria:
     *  The version of the Meter. No wildcard support, version must match exactly.
     * @param viewOptions.meterSchemaUrl
     * Instrument selection criteria:
     *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.
     *
     * @example
     * // Create a view that changes the Instrument 'my.instrument' to use to an
     * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]
     * new View({
     *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),
     *   instrumentName: 'my.instrument'
     * })
     */
    function View(viewOptions) {
        var _a;
        // If no criteria is provided, the SDK SHOULD treat it as an error.
        // It is recommended that the SDK implementations fail fast.
        if (isSelectorNotProvided(viewOptions)) {
            throw new Error('Cannot create view with no selector arguments supplied');
        }
        // the SDK SHOULD NOT allow Views with a specified name to be declared with instrument selectors that
        // may select more than one instrument (e.g. wild card instrument name) in the same Meter.
        if (viewOptions.name != null &&
            ((viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.instrumentName) == null ||
                PatternPredicate.hasWildcard(viewOptions.instrumentName))) {
            throw new Error('Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.');
        }
        // Create AttributesProcessor if attributeKeys are defined set.
        if (viewOptions.attributeKeys != null) {
            this.attributesProcessor = new FilteringAttributesProcessor(viewOptions.attributeKeys);
        }
        else {
            this.attributesProcessor = AttributesProcessor.Noop();
        }
        this.name = viewOptions.name;
        this.description = viewOptions.description;
        this.aggregation = (_a = viewOptions.aggregation) !== null && _a !== void 0 ? _a : Aggregation.Default();
        this.instrumentSelector = new InstrumentSelector({
            name: viewOptions.instrumentName,
            type: viewOptions.instrumentType,
        });
        this.meterSelector = new MeterSelector({
            name: viewOptions.meterName,
            version: viewOptions.meterVersion,
            schemaUrl: viewOptions.meterSchemaUrl
        });
    }
    return View;
}());

//# sourceMappingURL=View.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/sdk-metrics/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/build/esm/metrics/internal.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




function internal_toResourceMetrics(resourceMetrics) {
    return {
        resource: {
            attributes: toAttributes(resourceMetrics.resource.attributes),
            droppedAttributesCount: 0
        },
        schemaUrl: undefined,
        scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics)
    };
}
function toScopeMetrics(scopeMetrics) {
    return Array.from(scopeMetrics.map(function (metrics) {
        var scopeMetrics = {
            scope: {
                name: metrics.scope.name,
                version: metrics.scope.version,
            },
            metrics: metrics.metrics.map(function (metricData) { return toMetric(metricData); }),
            schemaUrl: metrics.scope.schemaUrl
        };
        return scopeMetrics;
    }));
}
function toMetric(metricData) {
    var out = {
        name: metricData.descriptor.name,
        description: metricData.descriptor.description,
        unit: metricData.descriptor.unit,
    };
    var aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);
    if (metricData.dataPointType === DataPointType.SUM) {
        out.sum = {
            aggregationTemporality: aggregationTemporality,
            isMonotonic: metricData.isMonotonic,
            dataPoints: toSingularDataPoints(metricData)
        };
    }
    else if (metricData.dataPointType === DataPointType.GAUGE) {
        // Instrument is a gauge.
        out.gauge = {
            dataPoints: toSingularDataPoints(metricData)
        };
    }
    else if (metricData.dataPointType === DataPointType.HISTOGRAM) {
        out.histogram = {
            aggregationTemporality: aggregationTemporality,
            dataPoints: toHistogramDataPoints(metricData)
        };
    }
    return out;
}
function toSingularDataPoint(dataPoint, valueType) {
    var out = {
        attributes: toAttributes(dataPoint.attributes),
        startTimeUnixNano: hrTimeToNanoseconds(dataPoint.startTime),
        timeUnixNano: hrTimeToNanoseconds(dataPoint.endTime),
    };
    if (valueType === ValueType.INT) {
        out.asInt = dataPoint.value;
    }
    else if (valueType === ValueType.DOUBLE) {
        out.asDouble = dataPoint.value;
    }
    return out;
}
function toSingularDataPoints(metricData) {
    return metricData.dataPoints.map(function (dataPoint) {
        return toSingularDataPoint(dataPoint, metricData.descriptor.valueType);
    });
}
function toHistogramDataPoints(metricData) {
    return metricData.dataPoints.map(function (dataPoint) {
        var histogram = dataPoint.value;
        return {
            attributes: toAttributes(dataPoint.attributes),
            bucketCounts: histogram.buckets.counts,
            explicitBounds: histogram.buckets.boundaries,
            count: histogram.count,
            sum: histogram.sum,
            min: histogram.min,
            max: histogram.max,
            startTimeUnixNano: hrTimeToNanoseconds(dataPoint.startTime),
            timeUnixNano: hrTimeToNanoseconds(dataPoint.endTime),
        };
    });
}
function toAggregationTemporality(temporality) {
    if (temporality === AggregationTemporality.DELTA) {
        return 1 /* AGGREGATION_TEMPORALITY_DELTA */;
    }
    if (temporality === AggregationTemporality.CUMULATIVE) {
        return 2 /* AGGREGATION_TEMPORALITY_CUMULATIVE */;
    }
    return 0 /* AGGREGATION_TEMPORALITY_UNSPECIFIED */;
}
//# sourceMappingURL=internal.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/build/esm/metrics/index.js

function createExportMetricsServiceRequest(resourceMetrics) {
    return {
        resourceMetrics: resourceMetrics.map(function (metrics) { return toResourceMetrics(metrics); })
    };
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/otlp-transformer/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/browser/OTLPTraceExporter.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var OTLPTraceExporter_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var DEFAULT_COLLECTOR_RESOURCE_PATH = 'v1/traces';
var DEFAULT_COLLECTOR_URL = "http://localhost:4318/" + DEFAULT_COLLECTOR_RESOURCE_PATH;
/**
 * Collector Trace Exporter for Web
 */
var OTLPTraceExporter = /** @class */ (function (_super) {
    OTLPTraceExporter_extends(OTLPTraceExporter, _super);
    function OTLPTraceExporter(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, config) || this;
        _this._headers = Object.assign(_this._headers, utils_parseKeyPairsIntoRecord(environment_getEnv().OTEL_EXPORTER_OTLP_TRACES_HEADERS));
        return _this;
    }
    OTLPTraceExporter.prototype.convert = function (spans) {
        return createExportTraceServiceRequest(spans, true);
    };
    OTLPTraceExporter.prototype.getDefaultUrl = function (config) {
        return typeof config.url === 'string'
            ? config.url
            : environment_getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT.length > 0
                ? appendRootPathToUrlIfNeeded(environment_getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT, DEFAULT_COLLECTOR_RESOURCE_PATH)
                : environment_getEnv().OTEL_EXPORTER_OTLP_ENDPOINT.length > 0
                    ? appendResourcePathToUrl(environment_getEnv().OTEL_EXPORTER_OTLP_ENDPOINT, DEFAULT_COLLECTOR_RESOURCE_PATH)
                    : DEFAULT_COLLECTOR_URL;
    };
    return OTLPTraceExporter;
}(OTLPExporterBrowserBase));

//# sourceMappingURL=OTLPTraceExporter.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/browser/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/index.js
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./src/SmTelemetry.ts





var DEFAULT_URL = 'http://localhost:4318/v1/traces';
var SmTracerProvider = (function () {
    var _tracerProvider;
    var _instance;
    return {
        init: function (opts) {
            var _a;
            if (_instance) {
                return;
            }
            opts.url = opts.url || DEFAULT_URL;
            opts.webSDKVersion = opts.webSDKVersion || 'unknown';
            _tracerProvider = new WebTracerProvider({
                resource: new Resource_Resource((_a = {},
                    _a[SemanticResourceAttributes.SERVICE_NAME] = 'smwebsdk',
                    _a[SemanticResourceAttributes.SERVICE_VERSION] = opts.webSDKVersion,
                    _a)),
            });
            _tracerProvider.addSpanProcessor(new BatchSpanProcessor(new OTLPTraceExporter({
                url: opts.url,
                headers: {
                    Authorization: 'Bearer ' + opts.jwt,
                },
            })));
            _tracerProvider.register();
            _instance = _tracerProvider.getTracer('smwebsdk');
        },
        isInitialized: function () {
            return !!_instance;
        },
        getTracer: function () {
            return _instance;
        },
        defaultUrl: DEFAULT_URL,
    };
})();
Object.freeze(SmTracerProvider);

;// CONCATENATED MODULE: ./src/env-vars.ts
/*
WARNING
- We have three different bundles, only one is built with webpack and supports environment variables.
- This file gets string replaced at build time, which is a temporary solution until we can use webpack (or a similar bundler) for all bundles
*/
var websdkVersion = (typeof process !== 'undefined' && '15.7.0') ||
    'unknown';

;// CONCATENATED MODULE: ./src/Scene.ts
/**
 * @module smwebsdk
 */

/*
 * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.
 */





















function sleep(t) {
    return new Promise(function (resolve) { return setTimeout(function () { return resolve(); }, t); });
}
var DEFAULT_RETRY_COUNT = 50;
var DEFAULT_RETRY_DELAY = 200;
var DEFAULT_PERSONA_ID = 1;
function retry(task, retryOptions, scene) {
    if (retryOptions === void 0) { retryOptions = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var errors, count, delay, result, i, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    errors = [];
                    count = retryOptions.maxRetries || DEFAULT_RETRY_COUNT;
                    delay = retryOptions.delayMs || DEFAULT_RETRY_DELAY;
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < count)) return [3 /*break*/, 8];
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 6]);
                    return [4 /*yield*/, task()];
                case 3:
                    result = _a.sent();
                    // store the result on the scene object
                    scene.connectionResult = {
                        message: 'success',
                        value: result,
                        retries: errors,
                    };
                    return [3 /*break*/, 6];
                case 4:
                    error_1 = _a.sent();
                    // collect a history of errors encountered during connect
                    errors.push(error_1);
                    // store the result on the scene object
                    scene.connectionResult = {
                        message: 'failed',
                        retries: errors,
                    };
                    //if error is 'noResumeSession` should cleanup session storage
                    if (error_1 instanceof Error && error_1.name === 'noSessionToResume') {
                        clearSessionData();
                    }
                    // any error other than 'noScene' should throw immediately
                    // and should not retry repeatedly.
                    // allows for proper errors and also string errors
                    if (!(error_1 instanceof Error) || error_1.name !== 'noScene') {
                        throw error_1;
                    }
                    // when we have reached the max number of retries,
                    // we should give up and throw the error
                    if (errors.length === count) {
                        console.warn("Retry gave up after ".concat(count, " retries:\n").concat(errors
                            .map(function (e) {
                            return e instanceof Error ? e.message : e.toString();
                        })
                            .join('\n')));
                        // throw the most recent error as the primary cause of failure
                        throw error_1;
                    }
                    return [4 /*yield*/, sleep(delay)];
                case 5:
                    _a.sent();
                    return [3 /*break*/, 7];
                case 6: return [3 /*break*/, 8];
                case 7:
                    i++;
                    return [3 /*break*/, 1];
                case 8: return [2 /*return*/, result];
            }
        });
    });
}
function storeSessionData(server, sessionId, apiKey) {
    sessionStorage.setItem('sm-server', server);
    sessionStorage.setItem('sm-session-id', sessionId);
    sessionStorage.setItem('sm-api-key', apiKey);
}
function getSessionData() {
    return {
        server: sessionStorage.getItem('sm-server'),
        resumeSessionId: sessionStorage.getItem('sm-session-id'),
        savedApiKey: sessionStorage.getItem('sm-api-key'),
    };
}
function clearSessionData() {
    sessionStorage.removeItem('sm-server');
    sessionStorage.removeItem('sm-session-id');
    sessionStorage.removeItem('sm-api-key');
}
/**
 * Scene class to hold a webrtc connection to a scene containing a persona.
 * @public
 */
var Scene = /** @class */ (function () {
    function Scene(videoOrOptions, audioOnly, requestedUserMedia, requiredUserMedia, contentAwarenessDebounceTime, loggingConfig, tracerOptions) {
        if (audioOnly === void 0) { audioOnly = false; }
        if (requestedUserMedia === void 0) { requestedUserMedia = UserMedia.MicrophoneAndCamera; }
        if (requiredUserMedia === void 0) { requiredUserMedia = UserMedia.Microphone; }
        var _this = this;
        this._onConversationResultEvents = {}; // persona id -> SmEvent with function(persona, result)
        this._onSpeechMarkerEvents = {}; // persona id -> SmEvent function(persona, marker)
        this._session = undefined;
        this._isWebSocketOnly = false;
        this._transactionId = 0;
        this._pendingResponses = {};
        this._microphoneUnmuteTimer = undefined;
        this._echoCancellationEnabled = true;
        this._serverControlledCameras = false;
        this._stopSpeakingWhenNotVisible = true;
        this._loggingConfig = {
            session: {},
            contentAwareness: {},
        };
        this._logger = new Logger();
        this._tracerOptions = {
            disableTracing: false,
            parentCtx: ROOT_CONTEXT,
            url: SmTracerProvider.defaultUrl,
        };
        this._sessionResumeEnabled = false;
        this._isResumedSession = false;
        this._sendMetadata = { pageUrl: false };
        this._onMicrophoneActive = new SmEvent();
        this._onCameraActive = new SmEvent();
        this.currentPersonaId = DEFAULT_PERSONA_ID;
        /** Returns the version of the webSdk and platformSdk */
        this.version = {
            webSdk: websdkVersion,
            platformSdk: 'unknown',
        };
        this.iosVisibilityChange = function () {
            var visible = document.visibilityState === 'visible';
            setTimeout(function () {
                if (_this._session) {
                    _this._session.sendRtcEvent('ui', { visible: visible });
                }
            }, 500); // allow 100ms for the H.264 decoder to become fully available again
        };
        this.stopSpeakingWhenNotVisible = function () {
            if (document.visibilityState !== 'visible') {
                _this.sendRequest('stopSpeaking', { personaId: _this.currentPersonaId });
            }
        };
        this.stopSpeakingWhenUnloaded = function () {
            _this.sendRequest('stopSpeaking', { personaId: _this.currentPersonaId });
        };
        // use the first parameter of the constructor to figure out
        // whether it was constructed using SceneOptions, or using
        // the deprecated multi-param format.
        if (this.isSceneOptions(videoOrOptions)) {
            // pull all private property initial values from the config object,
            // with fallbacks to the constructor property defaults if not provided
            var options = videoOrOptions;
            this._videoElement = options.videoElement;
            this._apiKey = options.apiKey;
            this._audioOnly = options.audioOnly || audioOnly;
            // default is "true" so can't use a shorthand falsy assessment to read this config option
            if (options.stopSpeakingWhenNotVisible === false) {
                this._stopSpeakingWhenNotVisible = false;
            }
            this._requestedUserMedia = utils_convertToUserMedia(options.requestedMediaDevices, requestedUserMedia);
            this._requiredUserMedia = utils_convertToUserMedia(options.requiredMediaDevices, requiredUserMedia);
            this.contentAwarenessDebounceTime = options.contentAwarenessDebounceTime;
            this._loggingConfig = __assign(__assign({}, this._loggingConfig), (options.loggingConfig || {}));
            if (options.sendMetadata) {
                this._sendMetadata = options.sendMetadata;
            }
            if (options.tracerOptions) {
                this._tracerOptions = options.tracerOptions;
            }
        }
        else {
            // take all private property initial values directly from the constructor props
            this._videoElement = videoOrOptions;
            this._audioOnly = audioOnly;
            this._requestedUserMedia = requestedUserMedia;
            this._requiredUserMedia = requiredUserMedia;
            this.contentAwarenessDebounceTime = contentAwarenessDebounceTime;
            this._loggingConfig = __assign(__assign({}, this._loggingConfig), loggingConfig);
            if (tracerOptions) {
                this._tracerOptions = tracerOptions;
            }
        }
        this._logger = new Logger(this._loggingConfig.session.minLogLevel, this._loggingConfig.session.enabled);
        /**
         * call onStateEvent.addListener(function(scene, state)) to be called when a state message is received as per the scene protocol
         * call onStateEvent.removeListener(function(scene, state)) to deregister a listener.
         */
        this._onStateEvent = new SmEvent();
        this._onStateEvent.addListener(function (scene, state) {
            if (_this._onState) {
                _this._onState(scene, state);
            }
        });
        /**
         * call onRecognizeResultsEvent.addListener(function(scene, status, errorMessage, results)) to be called when speech to text results are recognized, results are documented in scene protocol.
         * call onRecognizeResultsEvent.removeListener(function(scene, status, errorMessage, results)) to deregister a listener.
         */
        this._onRecognizeResultsEvent = new SmEvent();
        this._onRecognizeResultsEvent.addListener(function (scene, status, errorMessage, results) {
            if (_this._onRecognizeResults) {
                _this._onRecognizeResults(scene, status, errorMessage, results);
            }
        });
        /**
         * call onDisconnectedEvent.addListener(function(scene, sessionId, reason)) to be  called when the session is disconnected.
         * call onDisconnectedEvent.removeListener(function(scene, sessionId, reason)) to deregister a listener.
         */
        this._onDisconnectedEvent = new SmEvent();
        this._onDisconnectedEvent.addListener(function (scene, sessionId, reason) {
            clearSessionData();
            _this.cleanupEventListeners();
            if (_this._onDisconnected) {
                _this._onDisconnected(scene, sessionId, reason);
            }
        });
        /**
         * call onUserTextEvent.addListener(function(scene, text)) to be called when a custom text message is sent from the orchestration server
         * call onUserTextEvent.removeListener(function(scene, text)) to deregister a listener.
         */
        this._onUserTextEvent = new SmEvent();
        this._onUserTextEvent.addListener(function (scene, text) {
            if (_this._onUserText) {
                _this._onUserText(scene, text);
            }
        });
        this._onDemoModeEvent = new SmEvent();
        this._underRuntimeHost = Boolean(window.SmIsUnderRuntimeHost);
        // Generate a random id for the scene. This is used internally with the _transactionId
        // to ensure unique transaction ids when mulitple Scene instances access the same BL instances
        // eg multiple Soul Studio windows
        var randArray = new Uint32Array(3);
        window.crypto.getRandomValues(randArray);
        this._sceneId = randArray.toString().replace(/,/g, '-');
        this.conversation = new Conversation();
        this.connectionState = new ConnectionState();
        this._metadataSender = new MetadataSender(this);
        this._logger.log('debug', 'websdk version:', this.version.webSdk);
    }
    /**
     * Tests the first value of the Scene construtor to decide if
     * it matches the new-style config options format.
     */
    Scene.prototype.isSceneOptions = function (videoOrOptions) {
        // scene options must be defined, even if they're an empty object
        var isDefined = !!videoOrOptions;
        // scene options object will not have a tagName
        var isHTMLElement = !!(videoOrOptions === null || videoOrOptions === void 0 ? void 0 : videoOrOptions.tagName);
        return isDefined && !isHTMLElement;
    };
    Scene.prototype.connectionValid = function () {
        if (this._underRuntimeHost) {
            return true;
        }
        if (this._session && this._session.serverConnection) {
            return true;
        }
        return false;
    };
    /**
     * Check if the scene connection is open and valid.
     *
     * @returns Returns true if the connection is open and valid otherwise false.
     */
    Scene.prototype.isConnected = function () {
        if (this.connectionValid() &&
            this._session &&
            this._session.serverConnection &&
            this._session.serverConnection.readyState ===
                this._session.serverConnection.OPEN) {
            return true;
        }
        return false;
    };
    /**
     * Extends the server side timeout. This also happens automatically whenever the persona speaks.
     */
    Scene.prototype.keepAlive = function () {
        if (this._session && this._session.peerConnection !== null) {
            this._session.sendRtcEvent('keepAlive', {});
        }
    };
    /**
     * Disconnects the session
     */
    Scene.prototype.disconnect = function () {
        var _a, _b;
        clearSessionData();
        this.cleanupEventListeners();
        this.connectionState.reset();
        this.conversation.reset();
        (_a = this.contentAwareness) === null || _a === void 0 ? void 0 : _a.disconnect();
        this._metadataSender.disconnect();
        (_b = this._session) === null || _b === void 0 ? void 0 : _b.close(true);
        this._session = undefined;
    };
    Scene.prototype.connect = function (serverUriOrOptions, userText, accessToken, retryOptions) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var connectStartTime, config, span, recordEventsToSpan, hasPassedInTokenServerAuth, response, data, server, error_2, _d, initTracerStartTime, initTracerEndTime;
            var _this = this;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        connectStartTime = Date.now();
                        config = this.connectArgsToConfig(serverUriOrOptions, userText, accessToken, retryOptions);
                        recordEventsToSpan = function (event) {
                            span === null || span === void 0 ? void 0 : span.addEvent(event.name);
                        };
                        this.connectionState.onConnectionStateUpdated.addListener(recordEventsToSpan);
                        if (!this._underRuntimeHost) return [3 /*break*/, 1];
                        this._session = new LocalSession(this._videoElement, this._logger);
                        return [3 /*break*/, 8];
                    case 1:
                        hasPassedInTokenServerAuth = config.tokenServerUri || config.tokenServerAccessToken;
                        if (this._apiKey && hasPassedInTokenServerAuth) {
                            this._logger.log('warn', 'You are trying to connect via an API key and a token server. Please use one or the other');
                        }
                        if (!(this._apiKey && !hasPassedInTokenServerAuth)) return [3 /*break*/, 6];
                        _e.label = 2;
                    case 2:
                        _e.trys.push([2, 5, , 6]);
                        return [4 /*yield*/, this.fetchAuthConfig(this._apiKey)];
                    case 3:
                        response = _e.sent();
                        return [4 /*yield*/, response.json()];
                    case 4:
                        data = _e.sent();
                        server = getSessionData().server;
                        config.tokenServerUri = data.url;
                        config.tokenServerAccessToken = data.jwt;
                        if (server) {
                            config.tokenServerUri = getUrlHost(data.url) + 'server/' + server;
                        }
                        return [3 /*break*/, 6];
                    case 5:
                        error_2 = _e.sent();
                        if (error_2 instanceof Error && error_2.message === 'Broken API key') {
                            this._logger.log('error', 'Broken API key. Please check your key or re copy the key from DDNA Studio.');
                        }
                        else {
                            this._logger.log('error', 'Invalid API key: Please check your key configuration in DDNA Studio. For more information click here https://soulmachines-support.atlassian.net/wiki/spaces/SSAS/pages/1320058919/Connecting+Using+API+Keys#Troubleshooting');
                        }
                        throw makeError('Invalid API key', 'serverConnectionFailed');
                    case 6:
                        if (!config.tokenServerUri || !config.tokenServerAccessToken) {
                            throw makeError('Please authenticate via an API key or with a serverUri and accessToken', 'serverConnectionFailed');
                        }
                        return [4 /*yield*/, this.initializeTracer(config.tokenServerUri, config.tokenServerAccessToken)];
                    case 7:
                        _d = _e.sent(), initTracerStartTime = _d.initTracerStartTime, initTracerEndTime = _d.initTracerEndTime;
                        span = (_c = (_b = (_a = SmTracerProvider.getTracer()) === null || _a === void 0 ? void 0 : _a.startSpan('createSessionAndConnect')) === null || _b === void 0 ? void 0 : _b.setAttribute('sm.websdk.connection.pretraceinitduration.milliseconds', initTracerStartTime - connectStartTime)) === null || _c === void 0 ? void 0 : _c.setAttribute('sm.websdk.connection.traceinitduration.milliseconds', initTracerEndTime - initTracerStartTime);
                        if (this._isWebSocketOnly) {
                            this._session = new WebSocketSession(config.tokenServerUri, config.tokenServerAccessToken, this._logger);
                        }
                        else {
                            this._session = new Session(this._videoElement, config.tokenServerUri, config.userText, config.tokenServerAccessToken, this._audioOnly, this._requestedUserMedia, this._requiredUserMedia, this._echoCancellationEnabled, this._logger, this.connectionState);
                        }
                        _e.label = 8;
                    case 8:
                        if (!this._session) {
                            throw makeError('Failed to create session', 'unknown');
                        }
                        this._session.onConnected = this.sessionConnected.bind(this);
                        this._session.onMessage = this.onMessage.bind(this);
                        this._session.onClose = this.sessionClosed.bind(this);
                        this._session.onUserText = this.rtcUserText.bind(this);
                        if ('microphoneActiveCallbacks' in this._session) {
                            this._session.microphoneActiveCallbacks = this._onMicrophoneActive;
                        }
                        if ('cameraActiveCallbacks' in this._session) {
                            this._session.cameraActiveCallbacks = this._onCameraActive;
                        }
                        if (this._session.features.isIos) {
                            document.addEventListener('visibilitychange', this.iosVisibilityChange);
                        }
                        return [4 /*yield*/, retry(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this._session.connect()];
                                        case 1: 
                                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                        return [2 /*return*/, _a.sent()];
                                    }
                                });
                            }); }, config.retryOptions, this).finally(function () {
                                _this.connectionState.onConnectionStateUpdated.removeListener(recordEventsToSpan);
                                span === null || span === void 0 ? void 0 : span.end();
                            })];
                    case 9: return [2 /*return*/, _e.sent()];
                }
            });
        });
    };
    Scene.prototype.initializeTracer = function (tokenServerUri, tokenServerAccessToken) {
        return __awaiter(this, void 0, Promise, function () {
            var initTracerStartTime, error_3, base;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        initTracerStartTime = Date.now();
                        if (!(!this._tracerOptions.disableTracing &&
                            !SmTracerProvider.isInitialized())) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.initTelemetryToken({
                                tokenServerUri: tokenServerUri,
                                authToken: tokenServerAccessToken,
                            })];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_3 = _a.sent();
                        base = 'Could not initialize tracer telemetry token: ';
                        if (error_3 instanceof ReferenceError &&
                            error_3.message === 'fetch is not defined') {
                            // This happens in a non-browser environment (usually a test
                            // environment), so we can't get a telemetry token. Just log to
                            // debug.
                            this._logger.log('debug', base + error_3.name + ': ' + error_3.message);
                        }
                        else if (error_3 instanceof Error) {
                            this._logger.log('warn', base + error_3.name + ': ' + error_3.message);
                        }
                        else {
                            this._logger.log('warn', base + 'unknown error type');
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, { initTracerStartTime: initTracerStartTime, initTracerEndTime: Date.now() }];
                }
            });
        });
    };
    Scene.prototype.initTelemetryToken = function (_a) {
        var tokenServerUri = _a.tokenServerUri, authToken = _a.authToken;
        return __awaiter(this, void 0, Promise, function () {
            var otelJwtEndpoint, tracesEndpoint, telemetryHost, resp, otelResponse;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        otelJwtEndpoint = 'api/telemetry/jwt';
                        tracesEndpoint = 'api/telemetry/v1/traces';
                        telemetryHost = getUrlHost(convertWssToHttps(tokenServerUri));
                        if (!telemetryHost) {
                            this._logger.log('debug', 'Could not initialize tracer telemetry token: invalid token server URI');
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, fetch(telemetryHost + otelJwtEndpoint, {
                                headers: {
                                    Authorization: 'Bearer ' + authToken,
                                },
                            })];
                    case 1:
                        resp = _b.sent();
                        if (!resp) {
                            this._logger.log('warn', 'Failed to receive response from otel token endpoint');
                            return [2 /*return*/];
                        }
                        if (!resp.ok) {
                            this._logger.log('warn', 'Failed to fetch otel token: ' + resp.status + ': ' + resp.statusText);
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, resp.json()];
                    case 2:
                        otelResponse = _b.sent();
                        if (!otelResponse.success) {
                            this._logger.log('warn', 'Failed: otel response not successful');
                            return [2 /*return*/];
                        }
                        try {
                            SmTracerProvider.init({
                                jwt: otelResponse.telemetryJwt,
                                url: telemetryHost + tracesEndpoint,
                                webSDKVersion: this.version.webSdk,
                            });
                            this._logger.log('log', 'Telemetry initialized');
                        }
                        catch (error) {
                            if (error instanceof Error) {
                                this._logger.log('warn', 'Failed to initialize tracer: ' + error.message);
                            }
                            else {
                                this._logger.log('warn', 'Failed to initialize tracer: unknown error');
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Scene.prototype.onMessage = function (message) {
        var category = message.category;
        if (category === 'scene') {
            var sceneMessage = message;
            this.onSceneMessage(sceneMessage);
            return;
        }
    };
    Scene.prototype.sendOnewaySceneRequest = function (name, body) {
        if (!this._session) {
            return;
        }
        var payload = {
            name: name,
            body: body,
            category: WebsocketCategory.Scene,
            kind: WebsocketKind.Request,
        };
        this._session.sendMessage(payload);
    };
    /**
     * The internal method used for sending request messages.
     *
     * All offically supported message have their own public methods (e.g. `conversationSend()` or `scene.startRecognize()`). \
     * Please use those instead.
     *
     * @internal
     */
    Scene.prototype.sendRequest = function (name, body) {
        var _this = this;
        if (body === void 0) { body = {}; }
        return new Promise(function (resolve, reject) {
            if (!_this._session) {
                reject(makeError('No session available', 'noSession'));
                return;
            }
            var transaction = _this._sceneId + '_' + ++_this._transactionId;
            var payload = {
                transaction: transaction,
                name: name,
                body: body,
                category: WebsocketCategory.Scene,
                kind: WebsocketKind.Request,
            };
            var pending = { resolve: resolve, reject: reject };
            _this._pendingResponses[transaction] = pending;
            if (_this._session) {
                _this._session.sendMessage(payload);
            }
        });
    };
    Scene.prototype.onSceneMessage = function (message) {
        var _a, _b, _c;
        var name = message.name, body = message.body, kind = message.kind, status = message.status, transaction = message.transaction;
        // Process events
        if (body && name === 'state') {
            var responseBody = body;
            this._onStateEvent.call(this, responseBody);
            if ((_a = responseBody.scene) === null || _a === void 0 ? void 0 : _a.featureFlags) {
                this.enableFlaggedFeatures(responseBody.scene.featureFlags);
            }
            if ((_b = responseBody.scene) === null || _b === void 0 ? void 0 : _b.sdkVersion) {
                this.version.platformSdk = (_c = responseBody.scene) === null || _c === void 0 ? void 0 : _c.sdkVersion;
                this._logger.log('debug', 'platformSdk version:', this.version.platformSdk);
            }
            this.conversation.processStateMessage(responseBody);
            // mute the microphone while a persona is speaking
            this.controlMicrophoneMute(body);
        }
        else if (body && name === 'recognizeResults') {
            var _d = body, status_1 = _d.status, errorMessage = _d.errorMessage, results = _d.results;
            this.conversation.processRecognizeResultsMessage(body);
            this._onRecognizeResultsEvent.call(this, status_1, errorMessage, results);
        }
        else if (body && name === 'conversationResult') {
            this.conversation.onConversationResult(body);
            var personaId = body.personaId;
            if (personaId) {
                var persona = new Persona(this, personaId);
                var event = this._onConversationResultEvents[personaId];
                event.call(persona, body);
                this.currentPersonaId = personaId;
            }
        }
        else if (body && name === 'speechMarker') {
            this.conversation.onSpeechMarker(body);
            var personaId = body.personaId;
            if (personaId) {
                var persona = new Persona(this, personaId);
                var event = this._onSpeechMarkerEvents[personaId];
                event.call(persona, body);
                this.currentPersonaId = personaId;
            }
        }
        else if (body && name === 'demoMode') {
            this._onDemoModeEvent.call(this, body);
        }
        // Process responses, message should always be a response as far as we're aware
        if (kind === WebsocketKind.Response && transaction) {
            this.processResponse(body, name, status, transaction);
        }
    };
    Scene.prototype.processResponse = function (body, name, status, transaction) {
        // Check for a pending response
        var pending = this._pendingResponses[transaction];
        if (pending) {
            if (status === 0) {
                // Success
                pending.resolve(body);
            }
            else {
                // Failure
                var error = new SceneResponseError();
                error.requestName = name;
                error.status = status;
                error.responseBody = body;
                pending.reject(error);
            }
            delete this._pendingResponses[transaction];
        }
    };
    Scene.prototype.controlMicrophoneMute = function (state) {
        var _this = this;
        // Watch for speaking state transitions and mute the
        // microphone during persona speech to prevent self interruption
        if (state.persona &&
            this._session &&
            this._session.microphoneMuteDelay !== -1) {
            // iterate through the personas looking for speaking state changes
            for (var personaId in state.persona) {
                var persona_state = state.persona[personaId];
                if (!persona_state.speechState) {
                    continue;
                }
                if (persona_state.speechState === SpeechState.Speaking) {
                    // A persona is speaking, mute the microphone
                    if (!this._session.microphoneMuted) {
                        this._logger.log('warn', 'Persona is speaking - mute microphone');
                        this._session.microphoneMuted = true;
                    }
                    if (this._microphoneUnmuteTimer) {
                        // ensure an in-progress timeout doesn't incorrectly unmute
                        clearTimeout(this._microphoneUnmuteTimer);
                        this._microphoneUnmuteTimer = undefined;
                    }
                }
                else {
                    // A persona has stopped speaking, unmute the microphone after
                    // the microphone mute delay
                    if (this._session.microphoneMuted && !this._microphoneUnmuteTimer) {
                        this._microphoneUnmuteTimer = setTimeout(function () {
                            if (!_this._session || !_this._microphoneUnmuteTimer) {
                                return;
                            }
                            _this._logger.log("warn", 'Persona is no longer speaking - unmute microphone');
                            _this._session.microphoneMuted = false;
                            _this._microphoneUnmuteTimer = undefined;
                        }, this._session.microphoneMuteDelay);
                    }
                }
            }
        }
    };
    /** Close the current scene connection */
    Scene.prototype.close = function () {
        // close/disconnect the session
        if (this._session) {
            this._session.close(true);
        }
    };
    Scene.prototype.sessionConnected = function (resumeRequested, isResumedSession, server, sessionId) {
        this.contentAwareness = new ContentAwareness(this, this.contentAwarenessDebounceTime, new Logger(this._loggingConfig.contentAwareness.minLogLevel, this._loggingConfig.contentAwareness.enabled));
        /*
        Interrupt DP from speaking so it does not continue talking when user switches tabs
        */
        if (this._stopSpeakingWhenNotVisible) {
            document.addEventListener('visibilitychange', this.stopSpeakingWhenNotVisible);
        }
        //when user navigates to a new page, widget DP should stop speaking to allow new welcome message coming through in the new page
        //however browser doesn't trigger visibilitychange event, only "beforeunload" event is sure to be triggered
        window.addEventListener('beforeunload', this.stopSpeakingWhenUnloaded);
        if (this._sendMetadata.pageUrl) {
            this._metadataSender.observeUrlChanges();
        }
        //update resume session data
        this._isResumedSession = isResumedSession;
        if (resumeRequested) {
            this._sessionResumeEnabled = true;
            storeSessionData(server, sessionId, this._apiKey || '');
        }
        // When page navigation happens, check if any value in _sendMetadata is true and send it back to NLP so conversation writers can use it
        if (isResumedSession && this._sendMetadata.pageUrl) {
            this._metadataSender.send();
        }
    };
    Scene.prototype.cleanupEventListeners = function () {
        var _a;
        if ((_a = this._session) === null || _a === void 0 ? void 0 : _a.features.isIos) {
            document.removeEventListener('visibilitychange', this.iosVisibilityChange);
        }
        if (this._stopSpeakingWhenNotVisible) {
            document.removeEventListener('visibilitychange', this.stopSpeakingWhenNotVisible);
        }
        window.removeEventListener('beforeunload', this.stopSpeakingWhenUnloaded);
    };
    Scene.prototype.sessionClosed = function (reason) {
        clearSessionData();
        this.cleanupEventListeners();
        if (this._session) {
            this.connectionState.reset();
            this.conversation.reset();
            this._onDisconnectedEvent.call(this, this._session.sessionId, reason);
        }
    };
    Scene.prototype.rtcUserText = function (text) {
        this._onUserTextEvent.call(this, text);
    };
    Scene.prototype.enableFlaggedFeatures = function (featureFlags) {
        this._serverControlledCameras = featureFlags.includes(FeatureFlag.UI_SDK_CAMERA_CONTROL);
    };
    Scene.prototype.sendContent = function () {
        var _a;
        if (!this.contentAwareness) {
            console.warn('ContentAwareness is not enabled for this project');
        }
        (_a = this.contentAwareness) === null || _a === void 0 ? void 0 : _a.measure();
    };
    /**
     * Sends updated video element size to server
     * this gives the app the chance to choose what size should be rendered on server
     * and the application is responsible to register for a video element size change
     * event and call this method to maintain best possible video quality for the size
     * and/or to set an updated video element size and then call this method.
     * @param width - The width in pixels to render the video
     * @param height - The height in pixels to render the video
     */
    Scene.prototype.sendVideoBounds = function (width, height) {
        if (this._session) {
            this._session.sendVideoBounds(width, height);
        }
    };
    /**
     * Send configuration to the scene
     * @param configuration - Scene configuration as per the scene protocol
     */
    Scene.prototype.configure = function (configuration) {
        return this.sendRequest('configure', configuration);
    };
    /**
     * Send a custom user text message to the orchestration server
     * @param text - Custom text sent to the orchestration server
     */
    Scene.prototype.sendUserText = function (text) {
        if (this._session) {
            this._session.sendUserText(text);
        }
    };
    /**
     * Start the speech to text recognizer
     * @param audioSource - The audio source either smwebsdk.audioSource.processed or
     *                    smwebsdk.audioSource.squelched, defaults to processed.
     */
    Scene.prototype.startRecognize = function (audioSource) {
        var body = {};
        if (audioSource !== undefined) {
            body.audioSource = audioSource;
        }
        return this.sendRequest('startRecognize', body);
    };
    /** Stop the speech to text reconizer */
    Scene.prototype.stopRecognize = function () {
        return this.sendRequest('stopRecognize');
    };
    /** Is the microphone connected in the session */
    Scene.prototype.isMicrophoneConnected = function () {
        // public function rather than getter for back compatibility
        if (this._session) {
            return this._session.isMicrophoneConnected;
        }
        return false;
    };
    /** Is the camera connected in the session */
    Scene.prototype.isCameraConnected = function () {
        // public function rather than getter for back compatibility
        if (this._session) {
            return this._session.isCameraConnected;
        }
        return false;
    };
    Scene.prototype.session = function () {
        // public function rather than getter for back compatibility
        return this._session;
    };
    Scene.prototype.hasContentAwareness = function () {
        return !!this.contentAwareness;
    };
    Scene.prototype.hasServerControlledCameras = function () {
        return this._serverControlledCameras;
    };
    /**
     * Check if session persistence feature is supported in current session
     *
     * @returns `boolean`
     *
     * Usage:
     * ```javascript
     * const isSessionPersistenceSupported = scene.supportsSessionPersistence();
     * ```
     */
    Scene.prototype.supportsSessionPersistence = function () {
        return this._sessionResumeEnabled;
    };
    /**
     * Check if current session is a new session or a resumed session
     *
     * @returns `boolean`
     *
     * Usage:
     * ```javascript
     * const isResumedSession = scene.isResumedSession();
     * ```
     */
    Scene.prototype.isResumedSession = function () {
        return this._isResumedSession;
    };
    Object.defineProperty(Scene.prototype, "onConversationResultEvents", {
        get: function () {
            return this._onConversationResultEvents;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onSpeechMarkerEvents", {
        get: function () {
            return this._onSpeechMarkerEvents;
        },
        enumerable: false,
        configurable: true
    });
    /** Get the current scene state */
    Scene.prototype.getState = function () {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendRequest('getState')];
            });
        });
    };
    Object.defineProperty(Scene.prototype, "onStateEvent", {
        get: function () {
            return this._onStateEvent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onState", {
        // eslint-disable-next-line @typescript-eslint/ban-types
        set: function (onState) {
            this._onState = onState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onDisconnectedEvent", {
        get: function () {
            return this._onDisconnectedEvent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onDisconnected", {
        // eslint-disable-next-line @typescript-eslint/ban-types
        set: function (onDisconnected) {
            this._onDisconnected = onDisconnected;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onRecognizeResultsEvent", {
        get: function () {
            return this._onRecognizeResultsEvent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onRecognizeResults", {
        // eslint-disable-next-line @typescript-eslint/ban-types
        set: function (onRecognizeResults) {
            this._onRecognizeResults = onRecognizeResults;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onUserTextEvent", {
        get: function () {
            return this._onUserTextEvent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onUserText", {
        // eslint-disable-next-line @typescript-eslint/ban-types
        set: function (onUserText) {
            this._onUserText = onUserText;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "echoCancellationEnabled", {
        get: function () {
            return this._echoCancellationEnabled;
        },
        set: function (enabled) {
            this._echoCancellationEnabled = enabled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onDemoModeEvent", {
        /**
         * @internal
         */
        get: function () {
            return this._onDemoModeEvent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "videoElement", {
        get: function () {
            return this._videoElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "viewerOffsetX", {
        get: function () {
            if (this._session) {
                return this._session.offsetX;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "viewerOffsetY", {
        get: function () {
            if (this._session) {
                return this._session.offsetY;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "isWebSocketOnly", {
        get: function () {
            return this._isWebSocketOnly;
        },
        set: function (isWebSocketOnly) {
            this._isWebSocketOnly = isWebSocketOnly;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scene.prototype, "onMicrophoneActive", {
        /**
         * @returns an {@link SmEvent} associated with the microphone.
         *
         * Listeners can then be added to this event allowing you to call functions when the microphone active status changes.
         *
         * Usage:
         * ```javascript
         * scene.onMicrophoneActive.addListener(
         *   (active) => console.log('Microphone Active: ', active));
         * ```
         */
        get: function () {
            return this._onMicrophoneActive;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Specifies if the microphone is currently active and streaming audio
     * to the server.
     *
     * @returns `boolean`
     *
     * Usage:
     * ```javascript
     * const isMicrophoneActive = scene.isMicrophoneActive();
     * ```
     */
    Scene.prototype.isMicrophoneActive = function () {
        var _a;
        return Boolean((_a = this._session) === null || _a === void 0 ? void 0 : _a.isMicrophoneActive());
    };
    Object.defineProperty(Scene.prototype, "onCameraActive", {
        /**
         * @returns an {@link SmEvent} associated with the camera.
         *
         * Listeners can then be added to this event allowing you to call functions when the camera active status changes.
         *
         * Usage:
         * ```javascript
         * scene.onCameraActive.addListener(
         *   (active) => console.log('Camera Active: ', active));
         * ```
         */
        get: function () {
            return this._onCameraActive;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Specifies if the camera is currently active and streaming video
     * to the server.
     *
     * @returns `boolean`
     *
     * Usage:
     * ```javascript
     * const isCameraActive = scene.isCameraActive();
     * ```
     */
    Scene.prototype.isCameraActive = function () {
        var _a;
        return Boolean((_a = this._session) === null || _a === void 0 ? void 0 : _a.isCameraActive());
    };
    /**
     * On success, starts or stops streaming video/audio to the server based on the values of `microphone` and `camera`.
     *
     * @param options.microphone - If `true`, activates the microphone and starts streaming audio. \
     * If `false` deactivates the microphone and stops streaming audio. \
     * If not set, microphone will retain its existing state.
     * @param options.camera - If `true`, activates the camera and starts streaming video. \
     * If `false` deactivates the camera and stops streaming video. \
     * If not set, microphone will retain its existing state.
     *
     * @returns Returns a promise which is fulfilled when the media active state has been successfully changed. \
     * If the session is not defined it will return `undefined`. \
     * If the active state could not be changed, the promise is rejected with an Error object having the format:
     * ```javascript
     * {
     *   message: string;
     *   name: errorCode;
     * }
     * ```
     * Where `errorCode` is one of:
     *    - `noUserMedia` - the microphone/camera is either not available, not usable or the user declined permission to use them
     *    - `failedUpgrade` - the media upgrade failed
     *    - `notSupported` - user’s browser does not support the getUserMedia API
     *    - `noConnection` - connection has not been established - ensure scene.connect() has been called previously
     *
     * Usage:
     * ```javascript
     * scene.setMediaDeviceActive({ microphone: true, camera: false })
     *   .then(console.log('microphone activated, camera deactivated'));
     *   .catch((error) => console.log('error occurred: ', error);
     * ```
     */
    Scene.prototype.setMediaDeviceActive = function (options) {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.isConnected()) return [3 /*break*/, 2];
                        return [4 /*yield*/, ((_a = this._session) === null || _a === void 0 ? void 0 : _a.setMediaDeviceActive({
                                microphone: options.microphone,
                                camera: options.camera,
                            }))];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2: throw makeError('Connection has not been established', 'noConnection');
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Play the video element and return results. Different browsers have different restrictions on autoplay.
     * Using this method can handle all the cases browsers can have on inital video playback.
     * @param videoElement - Optional parameter specifying the video element hosting the Digital Person. If not specified the video element passed to the Scene constructor will be used.
     * @returns Returns a promise which is fulfilled when the video playback is successful, with indication of video and audio status.
     * If the video element is not defined or video play fails the promise is rejected with an Error object having the format:
     * ```javascript
     * {
     *   message: string;
     *   name: errorCode;
     * }
     * ```
     * Where `errorCode` is one of:
     *    - `noVideoElement` - no HTMLVideoElement found from `videoElement` or `Scene` constructor
     *    - `userInteractionRequired` - cannot start media playback due to browser restriction; user interaction is required before playing again
     *
     * Usage:
     * ```javascript
     * scene.startVideo()
     *      .then(({ video, audio }) => {
     *         if (!audio) {
     *          //video is muted, ask user to unmute video
     *         }
     *      })
     *      .catch((error) => {
     *         if (error.name === 'userInteractionRequired') {
     *          //ask user to interact with the UI
     *          //unmute video and play again
     *          video.muted = false;
     *          video.play();
     *         }
     *      });
     * ```
     */
    Scene.prototype.startVideo = function (videoElement) {
        return __awaiter(this, void 0, Promise, function () {
            var video;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        video = videoElement || this._videoElement;
                        if (!video) {
                            throw makeError('Cannot find HTMLVideoElement', 'noVideoElement');
                        }
                        return [4 /*yield*/, this.playVideo(video)];
                    case 1:
                        // best case, play with audio
                        if (_a.sent()) {
                            return [2 /*return*/, {
                                    video: true,
                                    audio: true,
                                }];
                        }
                        //second-best case, play without audio
                        video.muted = true;
                        return [4 /*yield*/, this.playVideo(video)];
                    case 2:
                        if (_a.sent()) {
                            return [2 /*return*/, {
                                    video: true,
                                    audio: false,
                                }];
                        }
                        //worst case, not able to play, require user interaction
                        throw makeError('Cannot start media playback', 'userInteractionRequired');
                }
            });
        });
    };
    Scene.prototype.playVideo = function (videoElement) {
        return __awaiter(this, void 0, Promise, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, videoElement.play()];
                    case 1:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 2:
                        _a = _b.sent();
                        return [2 /*return*/, false];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Scene.prototype.fetchAuthConfig = function (apiKey) {
        var authServer;
        try {
            var decodedApiKey = JSON.parse(atob(apiKey));
            authServer = decodedApiKey.authServer;
        }
        catch (error) {
            throw makeError('Broken API key', 'Failed to decode api key');
        }
        // check if sessionId exists in browser storage
        var _a = getSessionData(), server = _a.server, resumeSessionId = _a.resumeSessionId, savedApiKey = _a.savedApiKey;
        // check if the current api key is same as saved api key (if it is intended to resume to the same DP)
        if (server && resumeSessionId && savedApiKey === apiKey) {
            authServer = authServer + '?sessionId=' + resumeSessionId;
        }
        return fetch(authServer, {
            headers: {
                key: apiKey,
            },
        });
    };
    // Use the first parameter of the constructor to figure out
    // whether it was constructed using ConnectOptions, or using the deprecated multi-param format.
    Scene.prototype.connectArgsToConfig = function (serverUriOrOptions, userText, accessToken, retryOptions) {
        var _a, _b;
        if (typeof serverUriOrOptions === 'string') {
            return {
                tokenServerUri: serverUriOrOptions,
                tokenServerAccessToken: accessToken,
                userText: userText,
                retryOptions: retryOptions,
            };
        }
        else {
            return {
                tokenServerUri: ((_a = serverUriOrOptions === null || serverUriOrOptions === void 0 ? void 0 : serverUriOrOptions.tokenServer) === null || _a === void 0 ? void 0 : _a.uri) || '',
                tokenServerAccessToken: (_b = serverUriOrOptions === null || serverUriOrOptions === void 0 ? void 0 : serverUriOrOptions.tokenServer) === null || _b === void 0 ? void 0 : _b.token,
                userText: serverUriOrOptions === null || serverUriOrOptions === void 0 ? void 0 : serverUriOrOptions.userText,
                retryOptions: serverUriOrOptions === null || serverUriOrOptions === void 0 ? void 0 : serverUriOrOptions.retryOptions,
            };
        }
    };
    /**
     * Check if the session logging is enabled.
     *
     * @returns Returns true if the session logging is enabled otherwise false.
     */
    Scene.prototype.isLoggingEnabled = function () {
        return this._logger.isEnabled;
    };
    /**
     * Check minimal log level of session logging.
     *
     * @returns Returns minimal log setting of session logging, type is LogLevel.
     */
    Scene.prototype.getMinLogLevel = function () {
        return this._logger.getMinLogLevel();
    };
    /**
     * Enable/disable session logging
     * @param enable - set true to enable session log, false to disable
     */
    Scene.prototype.setLogging = function (enable) {
        this._logger.enableLogging(enable);
    };
    /**
     * Set minimal log level of session logging.
     * @param level - use LogLevel type to set minimal log level of session logging
     */
    Scene.prototype.setMinLogLevel = function (level) {
        this._logger.setMinLogLevel(level);
    };
    return Scene;
}());


;// CONCATENATED MODULE: ./src/SmWebSdk.ts
/**
 * smwebsdk.js creates the global namespace variable _smwebsdk_ to access the API from.
 *
 * ```ts
 * window.smwebsdk
 * ```
 * @module smwebsdk
 * @preferred
 */
/**
 * Copyright 2017-2020 Soul Machines Ltd. All Rights Reserved.
 */




var userMedia;
(function (userMedia) {
    userMedia[userMedia["none"] = UserMedia.None] = "none";
    userMedia[userMedia["microphone"] = UserMedia.Microphone] = "microphone";
    userMedia[userMedia["microphoneAndCamera"] = UserMedia.MicrophoneAndCamera] = "microphoneAndCamera";
    userMedia[userMedia["camera"] = UserMedia.Camera] = "camera";
})(userMedia || (userMedia = {}));
/**
 * SmWebSdk class for legacy compatibility
 * @deprecated - please use the other top level classes such as {@link Scene} or {@link Persona} instead
 */
var SmWebSdk = /** @class */ (function () {
    function SmWebSdk() {
        this.Scene = Scene;
        this.Persona = Persona;
        this.userMedia = {
            none: UserMedia.None,
            microphone: UserMedia.Microphone,
            microphoneAndCamera: UserMedia.MicrophoneAndCamera,
            camera: UserMedia.Camera,
        };
        this.DetectCapabilities = function () {
            return new Features_Features().detectWebRTCFeatures();
        };
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.setLogging = function (value) { };
    }
    return SmWebSdk;
}());

/**
 * @deprecated - please use the other top level classes such as {@link Scene} or {@link Persona} instead
 * @public
 */
var smwebsdk = new SmWebSdk();
// This is here purely to coerce the documentation
/**
 * Detect the browser capabilities
 */
function DetectCapabilities() {
    return new Features().detectWebRTCFeatures();
}
// This is here purely to coerce the documentation
/**
 * Set logging for smbwebsdk to enabled or disabled, defaults to enabled
 */
// eslint-disable-next-line @typescript-eslint/no-empty-function
function setLogging(value) { }

;// CONCATENATED MODULE: ./src/index.ts
















/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=smwebsdk.js.map